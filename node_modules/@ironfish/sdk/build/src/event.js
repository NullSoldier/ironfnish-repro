"use strict";
/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/. */
Object.defineProperty(exports, "__esModule", { value: true });
exports.waitForEmit = exports.Event = void 0;
class Event {
    constructor() {
        this.handlers = new Set();
    }
    /**
     * @returns true if the Event has no listeners
     */
    get isEmpty() {
        return this.handlers.size === 0;
    }
    /**
     * @returns the amount of subscriptions on this event
     */
    get subscribers() {
        return this.handlers.size;
    }
    /**
     * Adds a handler for when the event is emitted
     * Make sure you unsubscribe using [[Event.off]]
     */
    on(handler) {
        this.handlers.add(handler);
    }
    /**
     * Removes an event handler by reference
     *
     * @returns true if the handler was removed
     */
    off(handler) {
        return this.handlers.delete(handler);
    }
    /**
     * Adds an event handler that's removed after the next event is emitted
     */
    once(handler) {
        const wrapper = (...args) => {
            this.off(wrapper);
            return handler(...args);
        };
        this.handlers.add(wrapper);
    }
    /**
     * Emits the event, calling all handlers for this event
     */
    emit(...args) {
        void this.emitAsync(...args);
    }
    /**
     * Emits the event, calling all handlers, and returns a promise that awaits any async handlers
     */
    async emitAsync(...args) {
        const promises = [];
        for (const handler of Array.from(this.handlers)) {
            if (this.handlers.has(handler)) {
                promises.push(handler.call(undefined, ...args));
            }
        }
        await Promise.all(promises);
    }
    /**
     * Removes all handlers from the event
     */
    clear() {
        this.handlers.clear();
    }
    /**
     * Removes all handlers from the event in the next tick.
     * Useful if you want to clear an event, but allow remaining
     * handlers to execute
     */
    clearAfter() {
        setImmediate(() => {
            this.handlers.clear();
        });
    }
}
exports.Event = Event;
/**
 * A utility function that accepts an Event and returns a
 * promise that resolves the first time the event emits.
 *
 * @param event The event to wait for
 * @returns a promise that resolves the first time the event emits
 */
const waitForEmit = (event) => {
    return new Promise((resolve) => {
        const handler = (...args) => {
            resolve(args);
            event.off(handler);
        };
        event.on(handler);
    });
};
exports.waitForEmit = waitForEmit;
//# sourceMappingURL=event.js.map