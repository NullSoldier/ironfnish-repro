"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.RecentlyEvictedCache = void 0;
const priorityQueue_1 = require("./priorityQueue");
/**
 * A cache to track transactions that have recently been evicted from the mempool.
 *
 * This is primarily a mechanism to prevent transactions from being re-added to the mempool
 * within a reasonable duration if for some reason they are evicted (i.e. the mempool is full
 * and the transaction is underpriced).
 *
 * When the cache is full, the transaction with the highest fee rate is removed to make room
 * for the new transaction. This transaction is most likely to be re-introduced into the mempool,
 * so by removing it, we allow it to be re-fetched.
 */
class RecentlyEvictedCache {
    /**
     * Creates a new RecentlyEvictedCache.
     * Transactions that are evicted from the mempool should be added here.
     *
     * @constructor
     * @param options.maxSize the maximum number of hashes to store in the cache
     */
    constructor(options) {
        this.maxSize = options.maxSize;
        this.metrics = options.metrics;
        this.logger = options.logger.withTag('RecentlyEvictedCache');
        this.metrics.memPool_RecentlyEvictedCache_MaxSize.value = this.maxSize;
        this.evictionQueue = new priorityQueue_1.PriorityQueue(options.sortFunction, (t) => t.hash.toString('hex'));
        this.removeAtSequenceQueue = new priorityQueue_1.PriorityQueue((t1, t2) => t1.removeAtSequence < t2.removeAtSequence, (t) => t.hash.toString('hex'));
    }
    /**
     * Removes the hash from the cache and eviction + insertion queues
     *
     * @param hash the hash of the transaction to remove
     *
     * @returns true if the hash was removed, false if it was not present in the cache
     */
    remove(hash) {
        const stringHash = hash.toString('hex');
        if (!this.has(stringHash)) {
            return false;
        }
        // keep the items in the two priority queues consistently in sync
        this.removeAtSequenceQueue.remove(stringHash);
        this.evictionQueue.remove(stringHash);
        return true;
    }
    /**
     * Pops the transaction with the highest fee rate from the cache.
     *
     * The eviction and insertion queues will still be in sync after calling this method.
     *
     * @returns the transaction hash that was evicted, or undefined if the cache is empty
     */
    poll() {
        const toEvict = this.evictionQueue.poll();
        if (!toEvict) {
            return;
        }
        const hashToRemove = toEvict.hash;
        this.remove(hashToRemove);
        return hashToRemove;
    }
    /**
     * @returns the number of transactions in the cache
     */
    size() {
        return this.removeAtSequenceQueue.size();
    }
    /**
     *
     * @returns the usage of the recently evicted cache
     */
    saturation() {
        return this.size() / this.maxSize;
    }
    /**
     * Adds a new transaction to the recently evicted cache.
     * If the cache is full, the transaction with the highest fee rate will be evicted.
     *
     * Note that the cache is resized after the transaction is added. Thus, if the cache is above capacity
     * and the new transaction has the highest fee rate in the cache, it will be immediately be evicted.
     *
     * @param transactionHash The hash of the transaction to add
     * @param feeRate the fee/byte rate of the transaction
     * @param currentBlockSequence the current block sequence when the transaction was added
     * @param maxAge The maximum duration, in number of blocks, the transaction can stay in the cache
     *
     * @returns true if the transaction was successfully added to the cache, false if it was already present
     */
    add(transactionHash, feeRate, currentBlockSequence, maxAge) {
        if (this.has(transactionHash.toString('hex'))) {
            // add to metrics that a duplicate was attempted to be added
            return false;
        }
        this.evictionQueue.add({
            hash: transactionHash,
            feeRate,
        });
        this.removeAtSequenceQueue.add({
            hash: transactionHash,
            removeAtSequence: currentBlockSequence + maxAge,
        });
        // keep the cache under max capacity
        while (this.size() > this.maxSize) {
            this.poll();
        }
        this.updateMetrics();
        return true;
    }
    /**
     * Checks if the cache contains a transaction with the given hash.
     *
     * @returns true if the hash exists in the cache
     */
    has(hash) {
        return this.removeAtSequenceQueue.has(hash);
    }
    /**
     * Flushes the cache of any transactions that will expire after adding the given block sequence.
     *
     * @param sequence All transactions with an expiration sequence <= `sequence` will be flushed.
     */
    flush(sequence) {
        let flushCount = 0;
        let toFlush = this.removeAtSequenceQueue.peek();
        while (toFlush && toFlush.removeAtSequence <= sequence) {
            this.remove(toFlush.hash);
            flushCount++;
            toFlush = this.removeAtSequenceQueue.peek();
        }
        this.logger?.debug(`Flushed ${flushCount} transactions from RecentlyEvictedCache after adding block ${sequence}`);
        this.updateMetrics();
        return;
    }
    /**
     * Updates the metrics for the cache. This should be called whenever the cache is modified.
     */
    updateMetrics() {
        this.metrics.memPool_RecentlyEvictedCache_Size.value = this.size();
        this.metrics.memPool_RecentlyEvictedCache_Saturation.value = Math.round(this.saturation() * 100);
    }
}
exports.RecentlyEvictedCache = RecentlyEvictedCache;
//# sourceMappingURL=recentlyEvictedCache.js.map