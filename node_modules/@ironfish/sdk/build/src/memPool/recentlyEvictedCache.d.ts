import { Logger } from '../logger';
import { MetricsMonitor } from '../metrics';
import { TransactionHash } from '../primitives/transaction';
interface EvictionQueueEntry {
    hash: TransactionHash;
    feeRate: bigint;
}
/**
 * A cache to track transactions that have recently been evicted from the mempool.
 *
 * This is primarily a mechanism to prevent transactions from being re-added to the mempool
 * within a reasonable duration if for some reason they are evicted (i.e. the mempool is full
 * and the transaction is underpriced).
 *
 * When the cache is full, the transaction with the highest fee rate is removed to make room
 * for the new transaction. This transaction is most likely to be re-introduced into the mempool,
 * so by removing it, we allow it to be re-fetched.
 */
export declare class RecentlyEvictedCache {
    private readonly logger;
    private readonly metrics;
    /**
     * The maximum size of the cache in number of transactions.
     */
    readonly maxSize: number;
    /**
     * A priority queue of transaction hashes ordered by `feeRate` descending.
     * This is the eviction order for the cache when full.
     */
    private readonly evictionQueue;
    /**
     * A priority queue of transaction hashes ordered by their sequence # when they should be
     * removed from the recently evicted cache.
     */
    private readonly removeAtSequenceQueue;
    /**
     * Creates a new RecentlyEvictedCache.
     * Transactions that are evicted from the mempool should be added here.
     *
     * @constructor
     * @param options.maxSize the maximum number of hashes to store in the cache
     */
    constructor(options: {
        logger: Logger;
        metrics: MetricsMonitor;
        maxSize: number;
        sortFunction: (t1: EvictionQueueEntry, t2: EvictionQueueEntry) => boolean;
    });
    /**
     * Removes the hash from the cache and eviction + insertion queues
     *
     * @param hash the hash of the transaction to remove
     *
     * @returns true if the hash was removed, false if it was not present in the cache
     */
    private remove;
    /**
     * Pops the transaction with the highest fee rate from the cache.
     *
     * The eviction and insertion queues will still be in sync after calling this method.
     *
     * @returns the transaction hash that was evicted, or undefined if the cache is empty
     */
    private poll;
    /**
     * @returns the number of transactions in the cache
     */
    size(): number;
    /**
     *
     * @returns the usage of the recently evicted cache
     */
    saturation(): number;
    /**
     * Adds a new transaction to the recently evicted cache.
     * If the cache is full, the transaction with the highest fee rate will be evicted.
     *
     * Note that the cache is resized after the transaction is added. Thus, if the cache is above capacity
     * and the new transaction has the highest fee rate in the cache, it will be immediately be evicted.
     *
     * @param transactionHash The hash of the transaction to add
     * @param feeRate the fee/byte rate of the transaction
     * @param currentBlockSequence the current block sequence when the transaction was added
     * @param maxAge The maximum duration, in number of blocks, the transaction can stay in the cache
     *
     * @returns true if the transaction was successfully added to the cache, false if it was already present
     */
    add(transactionHash: TransactionHash, feeRate: bigint, currentBlockSequence: number, maxAge: number): boolean;
    /**
     * Checks if the cache contains a transaction with the given hash.
     *
     * @returns true if the hash exists in the cache
     */
    has(hash: string): boolean;
    /**
     * Flushes the cache of any transactions that will expire after adding the given block sequence.
     *
     * @param sequence All transactions with an expiration sequence <= `sequence` will be flushed.
     */
    flush(sequence: number): void;
    /**
     * Updates the metrics for the cache. This should be called whenever the cache is modified.
     */
    private updateMetrics;
}
export {};
//# sourceMappingURL=recentlyEvictedCache.d.ts.map