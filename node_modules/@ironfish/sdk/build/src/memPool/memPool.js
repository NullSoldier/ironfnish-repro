"use strict";
/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/. */
Object.defineProperty(exports, "__esModule", { value: true });
exports.MemPool = exports.mempoolEntryComparator = void 0;
const buffer_map_1 = require("buffer-map");
const assert_1 = require("../assert");
const consensus_1 = require("../consensus");
const logger_1 = require("../logger");
const serializers_1 = require("../network/utils/serializers");
const feeEstimator_1 = require("./feeEstimator");
const priorityQueue_1 = require("./priorityQueue");
const recentlyEvictedCache_1 = require("./recentlyEvictedCache");
function mempoolEntryComparator(firstTransaction, secondTransaction) {
    if (firstTransaction.feeRate !== secondTransaction.feeRate) {
        return firstTransaction.feeRate > secondTransaction.feeRate;
    }
    return firstTransaction.hash.compare(secondTransaction.hash) > 0;
}
exports.mempoolEntryComparator = mempoolEntryComparator;
class MemPool {
    constructor(options) {
        this.transactions = new buffer_map_1.BufferMap();
        this.nullifiers = new buffer_map_1.BufferMap();
        /* Keep track of number of bytes stored in the transaction map */
        this._sizeBytes = 0;
        const logger = options.logger || logger_1.createRootLogger();
        this.maxSizeBytes = options.maxSizeBytes;
        this.consensus = options.consensus;
        this.head = null;
        this.feeRateQueue = new priorityQueue_1.PriorityQueue(mempoolEntryComparator, (t) => t.hash.toString('hex'));
        this.evictionQueue = new priorityQueue_1.PriorityQueue((e1, e2) => !mempoolEntryComparator(e1, e2), (t) => t.hash.toString('hex'));
        this.expirationQueue = new priorityQueue_1.PriorityQueue((t1, t2) => t1.expiration < t2.expiration, (t) => t.hash.toString('hex'));
        this.chain = options.chain;
        this.logger = logger.withTag('mempool');
        this.metrics = options.metrics;
        this.metrics.memPoolMaxSizeBytes.value = this.maxSizeBytes;
        this.feeEstimator = options.feeEstimator;
        this.chain.onConnectBlock.on((block) => {
            this.feeEstimator.onConnectBlock(block, this);
            this.onConnectBlock(block);
        });
        this.chain.onDisconnectBlock.on(async (block) => {
            this.feeEstimator.onDisconnectBlock(block);
            await this.onDisconnectBlock(block);
        });
        this.recentlyEvictedCache = new recentlyEvictedCache_1.RecentlyEvictedCache({
            logger: this.logger,
            metrics: this.metrics,
            maxSize: options.recentlyEvictedCacheSize,
            sortFunction: mempoolEntryComparator,
        });
    }
    async start() {
        await this.feeEstimator.init(this.chain);
    }
    /**
     *
     * @returns The number of transactions in the mempool
     */
    count() {
        return this.transactions.size;
    }
    /**
     * @return The number of bytes stored in the mempool
     */
    sizeBytes() {
        return this._sizeBytes;
    }
    /**
     *
     * @returns The usage of the mempool, as a fraction between 0 and 1
     */
    saturation() {
        return this.sizeBytes() / this.maxSizeBytes;
    }
    /**
     * @returns true if the transaction is either in the mempool or in the
     * recently evicted cache. This does NOT indicate whether the full transaction
     * is stored in the mempool
     */
    exists(hash) {
        return this.transactions.has(hash) || this.recentlyEvicted(hash);
    }
    /*
     * Returns a transaction if a full transaction with that hash exists in the mempool
     * Otherwise, returns undefined
     */
    get(hash) {
        return this.transactions.get(hash);
    }
    *orderedTransactions() {
        const clone = this.feeRateQueue.clone();
        while (clone.size() > 0) {
            const feeAndHash = clone.poll();
            assert_1.Assert.isNotUndefined(feeAndHash);
            const transaction = this.transactions.get(feeAndHash.hash);
            // The queue is cloned above, but this.transactions is not, so the
            // transaction may be removed from this.transactions while iterating.
            if (transaction === undefined) {
                continue;
            }
            yield transaction;
        }
    }
    /**
     * Accepts a transaction from the network.
     * This does not guarantee that the transaction will be added to the mempool.
     *
     * @returns true if the transaction was added to the mempool as a full transaction
     * or just added to a cache like recentlyEvictedCache
     */
    acceptTransaction(transaction) {
        const hash = transaction.hash().toString('hex');
        const sequence = transaction.expiration();
        if (consensus_1.isExpiredSequence(sequence, this.chain.head.sequence)) {
            this.logger.debug(`Invalid transaction '${hash}': expired sequence ${sequence}`);
            return false;
        }
        const added = this.addTransaction(transaction);
        if (!added) {
            return false;
        }
        this.logger.debug(`Accepted tx ${hash}, poolsize ${this.count()}`);
        return true;
    }
    onConnectBlock(block) {
        let deletedTransactions = 0;
        for (const transaction of block.transactions) {
            const didDelete = this.deleteTransaction(transaction);
            if (didDelete) {
                deletedTransactions++;
            }
        }
        let nextExpired = this.expirationQueue.peek();
        while (nextExpired && consensus_1.isExpiredSequence(nextExpired.expiration, this.chain.head.sequence)) {
            const transaction = this.get(nextExpired.hash);
            if (!transaction) {
                continue;
            }
            const didDelete = this.deleteTransaction(transaction);
            if (didDelete) {
                deletedTransactions++;
            }
            nextExpired = this.expirationQueue.peek();
        }
        if (deletedTransactions) {
            this.logger.debug(`Deleted ${deletedTransactions} transactions`);
        }
        this.head = block.header;
        this.recentlyEvictedCache.flush(this.head.sequence);
    }
    async onDisconnectBlock(block) {
        for (const transaction of block.transactions) {
            if (transaction.isMinersFee()) {
                continue;
            }
            this.addTransaction(transaction);
        }
        this.head = await this.chain.getHeader(block.header.previousBlockHash);
    }
    /**
     * Add a new transaction to the mempool. If the mempool is full, the lowest feeRate transactions
     * are evicted from the mempool.
     *
     * Transactions with duplicate nullifers are rejected.
     *
     * @param transaction the transaction to add
     *
     * @returns true if the transaction is valid to be added. This will STILL return true
     * even if the transaction doesn't make it into the mempool because of size constraints
     */
    addTransaction(transaction) {
        const hash = transaction.hash();
        if (this.exists(hash)) {
            return false;
        }
        const { valid } = consensus_1.Verifier.verifyInternalNullifiers(transaction.spends);
        if (!valid) {
            return false;
        }
        // Don't allow transactions with duplicate nullifiers
        // TODO(daniel): Don't delete transactions if we aren't going to add the transaction anyway
        for (const spend of transaction.spends) {
            const existingHash = this.nullifiers.get(spend.nullifier);
            const existingTransaction = existingHash && this.transactions.get(existingHash);
            if (!existingTransaction) {
                continue;
            }
            if (transaction.fee() > existingTransaction.fee()) {
                this.deleteTransaction(existingTransaction);
            }
            else {
                return false;
            }
        }
        this.transactions.set(hash, transaction);
        for (const spend of transaction.spends) {
            this.nullifiers.set(spend.nullifier, hash);
        }
        this.feeRateQueue.add({ hash, feeRate: feeEstimator_1.getFeeRate(transaction) });
        this.evictionQueue.add({ hash, feeRate: feeEstimator_1.getFeeRate(transaction) });
        if (transaction.expiration() > 0) {
            this.expirationQueue.add({ expiration: transaction.expiration(), hash });
        }
        this._sizeBytes += serializers_1.getTransactionSize(transaction);
        this.updateMetrics();
        if (this.full()) {
            const evicted = this.evictTransactions();
            this.metrics.memPoolEvictions.value += evicted.length;
        }
        return true;
    }
    /**
     * @returns true if the mempool is over capacity
     */
    full() {
        return this.sizeBytes() >= this.maxSizeBytes;
    }
    /**
     * @returns true if a transaction hash is in the recently evicted cache
     */
    recentlyEvicted(hash) {
        return this.recentlyEvictedCache.has(hash.toString('hex'));
    }
    /**
     * Get relevant stats about the current state of the recently evicted cache.
     *
     * @returns size - the number of transactions in the mempool
     * @returns maxSize - the maximum number of transactions the mempool can hold
     * @returns saturation - the percentage of the mempool that is full
     */
    recentlyEvictedCacheStats() {
        return {
            size: this.recentlyEvictedCache.size(),
            maxSize: this.recentlyEvictedCache.maxSize,
            saturation: Math.round(this.recentlyEvictedCache.saturation() * 100),
        };
    }
    /**
     * Updates all relevent telemetry metrics.
     * This should be called after any additions / deletions from the mempool.
     */
    updateMetrics() {
        this.metrics.memPoolSize.value = this.count();
        this.metrics.memPoolSizeBytes.value = this.sizeBytes();
        this.metrics.memPoolSaturation.value = this.saturation();
    }
    /**
     * Evicts transactions from the mempool until it is under capacity.
     * Transactions are evicted in order of fee rate (descending).
     *
     * @returns an array of the evicted transactions
     */
    evictTransactions() {
        const evictedTransactions = [];
        while (this.full()) {
            const next = this.evictionQueue.peek();
            const transaction = next && this.transactions.get(next.hash);
            // If mempool is full, we should always have a transaction
            assert_1.Assert.isNotUndefined(transaction);
            this.deleteTransaction(transaction);
            // Transactions are added with a max lifespan of the current mempool size in blocks.
            // This is because the evicted transaction has a lower fee rate than every transaction
            // currently in the mempool.
            this.recentlyEvictedCache.add(transaction.hash(), feeEstimator_1.getFeeRate(transaction), this.chain.head.sequence, this.sizeInBlocks());
            evictedTransactions.push(transaction);
        }
        return evictedTransactions;
    }
    /**
     * @returns the current size of the mempool in blocks
     */
    sizeInBlocks() {
        return Math.floor(this.sizeBytes() / this.consensus.parameters.maxBlockSizeBytes);
    }
    deleteTransaction(transaction) {
        const hash = transaction.hash();
        const deleted = this.transactions.delete(hash);
        if (!deleted) {
            return false;
        }
        this._sizeBytes -= serializers_1.getTransactionSize(transaction);
        for (const spend of transaction.spends) {
            this.nullifiers.delete(spend.nullifier);
        }
        const hashAsString = hash.toString('hex');
        this.feeRateQueue.remove(hashAsString);
        this.evictionQueue.remove(hashAsString);
        this.expirationQueue.remove(hashAsString);
        this.updateMetrics();
        return true;
    }
}
exports.MemPool = MemPool;
//# sourceMappingURL=memPool.js.map