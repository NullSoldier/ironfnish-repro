import { Blockchain } from '../blockchain';
import { Consensus } from '../consensus';
import { Logger } from '../logger';
import { MetricsMonitor } from '../metrics';
import { Block, BlockHeader } from '../primitives';
import { Transaction, TransactionHash } from '../primitives/transaction';
import { FeeEstimator } from './feeEstimator';
interface MempoolEntry {
    hash: TransactionHash;
    feeRate: bigint;
}
export declare function mempoolEntryComparator(firstTransaction: MempoolEntry, secondTransaction: MempoolEntry): boolean;
export declare class MemPool {
    private readonly transactions;
    private readonly nullifiers;
    private readonly feeRateQueue;
    private readonly evictionQueue;
    private readonly expirationQueue;
    private readonly recentlyEvictedCache;
    private _sizeBytes;
    readonly maxSizeBytes: number;
    private readonly consensus;
    head: BlockHeader | null;
    private readonly chain;
    private readonly logger;
    private readonly metrics;
    readonly feeEstimator: FeeEstimator;
    constructor(options: {
        chain: Blockchain;
        consensus: Consensus;
        feeEstimator: FeeEstimator;
        metrics: MetricsMonitor;
        maxSizeBytes: number;
        recentlyEvictedCacheSize: number;
        logger?: Logger;
    });
    start(): Promise<void>;
    /**
     *
     * @returns The number of transactions in the mempool
     */
    count(): number;
    /**
     * @return The number of bytes stored in the mempool
     */
    sizeBytes(): number;
    /**
     *
     * @returns The usage of the mempool, as a fraction between 0 and 1
     */
    saturation(): number;
    /**
     * @returns true if the transaction is either in the mempool or in the
     * recently evicted cache. This does NOT indicate whether the full transaction
     * is stored in the mempool
     */
    exists(hash: TransactionHash): boolean;
    get(hash: TransactionHash): Transaction | undefined;
    orderedTransactions(): Generator<Transaction, void, unknown>;
    /**
     * Accepts a transaction from the network.
     * This does not guarantee that the transaction will be added to the mempool.
     *
     * @returns true if the transaction was added to the mempool as a full transaction
     * or just added to a cache like recentlyEvictedCache
     */
    acceptTransaction(transaction: Transaction): boolean;
    onConnectBlock(block: Block): void;
    onDisconnectBlock(block: Block): Promise<void>;
    /**
     * Add a new transaction to the mempool. If the mempool is full, the lowest feeRate transactions
     * are evicted from the mempool.
     *
     * Transactions with duplicate nullifers are rejected.
     *
     * @param transaction the transaction to add
     *
     * @returns true if the transaction is valid to be added. This will STILL return true
     * even if the transaction doesn't make it into the mempool because of size constraints
     */
    private addTransaction;
    /**
     * @returns true if the mempool is over capacity
     */
    full(): boolean;
    /**
     * @returns true if a transaction hash is in the recently evicted cache
     */
    recentlyEvicted(hash: TransactionHash): boolean;
    /**
     * Get relevant stats about the current state of the recently evicted cache.
     *
     * @returns size - the number of transactions in the mempool
     * @returns maxSize - the maximum number of transactions the mempool can hold
     * @returns saturation - the percentage of the mempool that is full
     */
    recentlyEvictedCacheStats(): {
        size: number;
        maxSize: number;
        saturation: number;
    };
    /**
     * Updates all relevent telemetry metrics.
     * This should be called after any additions / deletions from the mempool.
     */
    private updateMetrics;
    /**
     * Evicts transactions from the mempool until it is under capacity.
     * Transactions are evicted in order of fee rate (descending).
     *
     * @returns an array of the evicted transactions
     */
    private evictTransactions;
    /**
     * @returns the current size of the mempool in blocks
     */
    sizeInBlocks(): number;
    private deleteTransaction;
}
export {};
//# sourceMappingURL=memPool.d.ts.map