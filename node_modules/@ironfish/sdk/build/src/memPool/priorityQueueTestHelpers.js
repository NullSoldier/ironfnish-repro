"use strict";
/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/. */
Object.defineProperty(exports, "__esModule", { value: true });
exports.heapSort = exports.SimpleQueue = void 0;
// Create a very simple queue implementation that is slow but adds and removes
// elements in a predicatable fashion. Used to test the more complicated queue
// implementation against
class SimpleQueue {
    constructor(compare, hash) {
        this._map = {};
        this._sorted = [];
        this.hash = hash;
        this._compare = compare;
    }
    add(item) {
        const hash = this.hash(item);
        if (this._map[hash]) {
            return false;
        }
        this._map[hash] = item;
        this._sorted.push([hash, item]);
        this._reSort();
        return true;
    }
    remove(hash) {
        const val = this._map[hash];
        delete this._map[hash];
        this._sorted.filter(([h, _]) => h !== hash);
        this._reSort();
        return val;
    }
    _reSort() {
        this._sorted.sort((a, b) => (this._compare(a[1], b[1]) ? 1 : -1));
    }
    poll() {
        const toReturn = this._sorted.pop();
        if (toReturn === undefined) {
            return undefined;
        }
        delete this._map[toReturn[0]];
        return toReturn[1];
    }
    has(hash) {
        return this._map[hash] !== undefined;
    }
    size() {
        return this._sorted.length;
    }
}
exports.SimpleQueue = SimpleQueue;
function heapSort(queue, items) {
    for (const item of items) {
        queue.add(item);
    }
    const sorted = [];
    while (queue.size()) {
        const next = queue.poll();
        if (next) {
            sorted.push(next);
        }
    }
    return sorted;
}
exports.heapSort = heapSort;
//# sourceMappingURL=priorityQueueTestHelpers.js.map