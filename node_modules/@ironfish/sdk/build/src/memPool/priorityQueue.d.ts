/**
 * PriorityQueue keeps track of two data structures: a binary heap (_items) and a map
 * of objects to their position in the heap (_positions). This map allows for `log(n)`
 * removal from the heap instead of doing a linear scan of the heap to remove an item
 */
export declare class PriorityQueue<T> {
    private _items;
    private _positions;
    readonly compare: (a: T, b: T) => boolean;
    readonly hash: (item: T) => string;
    /**
     * This data structure is a **Priority Queue** as well as a **Set**. Duplicate entries are
     * not allowed. Entries are identified based on the hash function provided
     *
     * @param compare should return true if a is higher priority than b, otherwise false
     * @param hash should return a unique hash of the item as a string. It should and should
     * be a pure function and very fast (ideally just a field access) because it is called often
     */
    constructor(compare: (a: T, b: T) => boolean, hash: (item: T) => string);
    /**
     * Adds @param item to the queue and returns true.
     * If `hash(item)` already exists in the queue, returns false
     */
    add(item: T): boolean;
    /**
     * Returns the highest priority element in the queue. If the queue is empty, returns `undefined`
     */
    poll(): T | undefined;
    /**
     * Removes the element matching the given @param hash. If no element matches, returns `undefined`
     */
    remove(hash: string): T | undefined;
    /**
     * Look at the highest priority item in the queue without removing it
     */
    peek(): T | undefined;
    /**
     * returns true if the element matching @param hash exists in the queue
     */
    has(hash: string): boolean;
    /**
     * return the number of elements in the queue
     */
    size(): number;
    /**
     * create a new queue copy identical to this queue
     */
    clone(): PriorityQueue<T>;
    /**
     * Removes a node at the specified @param index and returns it. Does this by switching
     * the node with the last item in the heap and then popping it off
     */
    private _remove;
    /**
     * Attempts to move a node (at @param index) up the heap until it is
     * less or equal to it parent and greater than or equal to its siblings
     */
    private _percolateUp;
    /**
     * Attempts to move a node (at @param index) down the heap until it is
     * less or equal to it parent and greater than or equal to its siblings
     */
    private _percolateDown;
    /**
     * Returns the index of the smaller child node. If the given index has
     * no children then returns `undefined`
     */
    private _smallestChildIndex;
    /**
     * Swaps the positions of nodes at @param indexA and @param indexB
     * and updates the map of their positions
     */
    private _swap;
    private _parentIndex;
    private _leftChildIndex;
    private _rightChildIndex;
    print(index: number, toString: (item: T) => string): string;
}
//# sourceMappingURL=priorityQueue.d.ts.map