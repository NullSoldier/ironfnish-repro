"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Meter = void 0;
const ewmAverage_1 = require("./ewmAverage");
const rollingAverage_1 = require("./rollingAverage");
/**
 * A metric type useful for recording metered things like
 *  * blocks per second
 *  * bytes per second
 *
 * This metric will take a sample of how many units were
 * completd each tick cycle and record that in various
 * rolling averages and exponentially weighted moving averages
 *
 * */
class Meter {
    constructor(options) {
        this._started = false;
        this._count = 0;
        this._interval = null;
        this._intervalLastMs = null;
        this._intervalMs = 1000;
        this._rate1s = new ewmAverage_1.EwmAverage(1000 / this._intervalMs);
        this._rate5s = new ewmAverage_1.EwmAverage(5000 / this._intervalMs);
        this._rate1m = new ewmAverage_1.EwmAverage((1 * 60 * 1000) / this._intervalMs);
        this._rate5m = new ewmAverage_1.EwmAverage((5 * 60 * 1000) / this._intervalMs);
        const numSamples = options?.maxRollingAverageSamples ?? 1000;
        this._average = new rollingAverage_1.RollingAverage(numSamples);
        this._rollingRate1s = new rollingAverage_1.RollingAverage(1000 / this._intervalMs);
        this._rollingRate5s = new rollingAverage_1.RollingAverage(5000 / this._intervalMs);
        this._rollingRate1m = new rollingAverage_1.RollingAverage((1 * 60 * 1000) / this._intervalMs);
        this._rollingRate5m = new rollingAverage_1.RollingAverage((5 * 60 * 1000) / this._intervalMs);
    }
    get rate1s() {
        return this._rate1s.average;
    }
    get rate5s() {
        return this._rate5s.average;
    }
    get rate1m() {
        return this._rate1m.average;
    }
    get rate5m() {
        return this._rate5m.average;
    }
    get avg() {
        return this._average.average;
    }
    get rollingRate1s() {
        return this._rollingRate1s.average;
    }
    get rollingRate5s() {
        return this._rollingRate5s.average;
    }
    get rollingRate1m() {
        return this._rollingRate1m.average;
    }
    get rollingRate5m() {
        return this._rollingRate5m.average;
    }
    add(count) {
        if (!this._started) {
            return;
        }
        this._count += count;
        this._average.add(count);
    }
    start() {
        if (this._started) {
            return;
        }
        this._started = true;
        this._interval = setInterval(() => this.update(), this._intervalMs);
    }
    stop() {
        if (!this._started) {
            return;
        }
        this._started = false;
        this._intervalLastMs = null;
        this._count = 0;
        if (this._interval) {
            clearInterval(this._interval);
        }
    }
    reset() {
        this._rate1s.reset();
        this._rate5s.reset();
        this._rate1m.reset();
        this._rate5m.reset();
        this._average.reset();
        this._rollingRate1s.reset();
        this._rollingRate5s.reset();
        this._rollingRate1m.reset();
        this._rollingRate5m.reset();
        this._count = 0;
        this._intervalLastMs = null;
    }
    update() {
        const now = performance.now();
        if (this._intervalLastMs === null) {
            this._intervalLastMs = now;
            return;
        }
        const elapsedMs = now - this._intervalLastMs;
        const rateSec = elapsedMs === 0 ? 0 : (this._count / elapsedMs) * 1000;
        const weight = elapsedMs / this._intervalMs;
        this._rate1s.add(rateSec, weight);
        this._rate5s.add(rateSec, weight);
        this._rate1m.add(rateSec, weight);
        this._rate5m.add(rateSec, weight);
        this._rollingRate1s.add(rateSec);
        this._rollingRate5s.add(rateSec);
        this._rollingRate1m.add(rateSec);
        this._rollingRate5m.add(rateSec);
        this._count = 0;
        this._intervalLastMs = now;
    }
}
exports.Meter = Meter;
//# sourceMappingURL=meter.js.map