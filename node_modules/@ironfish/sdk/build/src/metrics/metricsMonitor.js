"use strict";
/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/. */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.MetricsMonitor = void 0;
const os_1 = __importDefault(require("os"));
const v8_1 = require("v8");
const logger_1 = require("../logger");
const types_1 = require("../network/types");
const utils_1 = require("../utils");
const cpuMeter_1 = require("./cpuMeter");
const gauge_1 = require("./gauge");
const meter_1 = require("./meter");
class MetricsMonitor {
    constructor({ logger }) {
        this._started = false;
        this._meters = [];
        this.p2p_InboundTrafficByMessage = new Map();
        this.p2p_OutboundTrafficByMessage = new Map();
        this.p2p_RpcSuccessRateByMessage = new Map();
        this.p2p_RpcResponseTimeMsByMessage = new Map();
        // Elements of this map are managed by Peer and PeerNetwork
        this.p2p_OutboundMessagesByPeer = new Map();
        this.memoryRefreshPeriodMs = 1000;
        this.cpuMeter = new cpuMeter_1.CPUMeter(500);
        this.logger = logger ?? logger_1.createRootLogger();
        this.mining_newEmptyBlockTemplate = this.addMeter();
        this.mining_newBlockTemplate = this.addMeter();
        this.mining_newBlockTransactions = this.addMeter({ maxRollingAverageSamples: 100 });
        this.chain_newBlock = this.addMeter();
        this.chain_databaseSize = new gauge_1.Gauge();
        this.p2p_InboundTraffic = this.addMeter();
        this.p2p_InboundTraffic_WS = this.addMeter();
        this.p2p_InboundTraffic_WebRTC = this.addMeter();
        this.p2p_OutboundTraffic = this.addMeter();
        this.p2p_OutboundTraffic_WS = this.addMeter();
        this.p2p_OutboundTraffic_WebRTC = this.addMeter();
        for (const value of utils_1.NumberEnumUtils.getNumValues(types_1.NetworkMessageType)) {
            this.p2p_InboundTrafficByMessage.set(value, this.addMeter());
            this.p2p_OutboundTrafficByMessage.set(value, this.addMeter());
            // Should only need to add meters for RPC messages, but makes the code a bit
            // cleaner in the current type system to do it this way
            this.p2p_RpcSuccessRateByMessage.set(value, this.addMeter());
            this.p2p_RpcResponseTimeMsByMessage.set(value, this.addMeter());
        }
        this.p2p_PeersCount = new gauge_1.Gauge();
        this.heapTotal = new gauge_1.Gauge();
        this.heapUsed = new gauge_1.Gauge();
        this.rss = new gauge_1.Gauge();
        this.memFree = new gauge_1.Gauge();
        this.memTotal = os_1.default.totalmem();
        this.memoryInterval = null;
        // mempool metrics
        this.memPoolSize = new gauge_1.Gauge();
        this.memPoolSizeBytes = new gauge_1.Gauge();
        this.memPoolMaxSizeBytes = new gauge_1.Gauge();
        this.memPoolSaturation = new gauge_1.Gauge();
        this.memPoolEvictions = new gauge_1.Gauge();
        this.memPool_RecentlyEvictedCache_Size = new gauge_1.Gauge();
        this.memPool_RecentlyEvictedCache_MaxSize = new gauge_1.Gauge();
        this.memPool_RecentlyEvictedCache_Saturation = new gauge_1.Gauge();
        this.heapMax = v8_1.getHeapStatistics().total_available_size;
        this.cpuCores = os_1.default.cpus().length;
    }
    get started() {
        return this._started;
    }
    start() {
        this._started = true;
        this._meters.forEach((m) => m.start());
        this.cpuMeter.start();
        this.memoryInterval = setInterval(() => this.refreshMemory(), this.memoryRefreshPeriodMs);
    }
    stop() {
        this._started = false;
        this._meters.forEach((m) => m.stop());
        this.cpuMeter.stop();
        if (this.memoryInterval) {
            clearTimeout(this.memoryInterval);
        }
    }
    addMeter(options) {
        const meter = new meter_1.Meter(options);
        this._meters.push(meter);
        if (this._started) {
            meter.start();
        }
        return meter;
    }
    refreshMemory() {
        const memoryUsage = process.memoryUsage();
        this.heapTotal.value = memoryUsage.heapTotal;
        this.heapUsed.value = memoryUsage.heapUsed;
        this.rss.value = memoryUsage.rss;
        this.memFree.value = os_1.default.freemem();
    }
}
exports.MetricsMonitor = MetricsMonitor;
//# sourceMappingURL=metricsMonitor.js.map