/// <reference types="node" />
import LRU from 'blru';
import { Consensus } from '../consensus';
import { VerificationResultReason, Verifier } from '../consensus/verifier';
import { Event } from '../event';
import { Config } from '../fileStores';
import { FileSystem } from '../fileSystems';
import { Logger } from '../logger';
import { MerkleTree } from '../merkletree';
import { MetricsMonitor } from '../metrics';
import { RollingAverage } from '../metrics/rollingAverage';
import { Block, SerializedBlock } from '../primitives/block';
import { BlockHash, BlockHeader } from '../primitives/blockheader';
import { NoteEncrypted, NoteEncryptedHash, SerializedNoteEncrypted, SerializedNoteEncryptedHash } from '../primitives/noteEncrypted';
import { Transaction, TransactionHash } from '../primitives/transaction';
import { IDatabaseTransaction } from '../storage';
import { Strategy } from '../strategy';
import { WorkerPool } from '../workerPool';
import { AssetValue } from './database/assetValue';
import { BlockchainDB } from './database/blockchaindb';
import { TransactionsValue } from './database/transactions';
import { NullifierSet } from './nullifierSet/nullifierSet';
export declare const VERSION_DATABASE_CHAIN = 28;
export declare class Blockchain {
    logger: Logger;
    strategy: Strategy;
    verifier: Verifier;
    metrics: MetricsMonitor;
    location: string;
    files: FileSystem;
    consensus: Consensus;
    seedGenesisBlock: SerializedBlock;
    config: Config;
    readonly blockchainDb: BlockchainDB;
    readonly notes: MerkleTree<NoteEncrypted, NoteEncryptedHash, SerializedNoteEncrypted, SerializedNoteEncryptedHash>;
    readonly nullifiers: NullifierSet;
    synced: boolean;
    opened: boolean;
    addSpeed: RollingAverage;
    invalid: LRU<BlockHash, VerificationResultReason>;
    orphans: LRU<BlockHash, BlockHeader>;
    logAllBlockAdd: boolean;
    autoSeed: boolean;
    onSynced: Event<[]>;
    onConnectBlock: Event<[block: Block, tx?: IDatabaseTransaction | undefined]>;
    onDisconnectBlock: Event<[block: Block, tx?: IDatabaseTransaction | undefined]>;
    onForkBlock: Event<[block: Block, tx?: IDatabaseTransaction | undefined]>;
    onReorganize: Event<[oldHead: BlockHeader, newHead: BlockHeader, fork: BlockHeader]>;
    private _head;
    get head(): BlockHeader;
    set head(newHead: BlockHeader);
    private _latest;
    get latest(): BlockHeader;
    set latest(newLatest: BlockHeader);
    private _genesis;
    get genesis(): BlockHeader;
    set genesis(newGenesis: BlockHeader);
    constructor(options: {
        location: string;
        strategy: Strategy;
        workerPool: WorkerPool;
        logger?: Logger;
        metrics?: MetricsMonitor;
        logAllBlockAdd?: boolean;
        autoSeed?: boolean;
        files: FileSystem;
        consensus: Consensus;
        genesis: SerializedBlock;
        config: Config;
    });
    get isEmpty(): boolean;
    get hasGenesisBlock(): boolean;
    getProgress(): number;
    private seed;
    open(): Promise<void>;
    private load;
    close(): Promise<void>;
    addBlock(block: Block): Promise<{
        isAdded: boolean;
        isFork: boolean | null;
        reason: VerificationResultReason | null;
        score: number | null;
    }>;
    /**
     * This function will find the forking point of two blocks if it exists, or return null
     * If the same hash is specified, the same block will be returned. If one block is a linear
     * fast forward to the other with no forks, then the earlier block will be returned.
     *
     * @param fromHash the hash of the first block to find the fork for
     * @param toHash the hash of the second block to find the fork for
     * @param tx
     * @returns a BlockHeader if the fork point was found, or null if it was not
     */
    findFork(headerA: BlockHeader | Block, headerB: BlockHeader | Block, tx?: IDatabaseTransaction): Promise<BlockHeader>;
    /**
     * Iterate the main chain from left to right inclusive.
     * Start and end being included in the yielded blocks.
     * */
    iterateTo(start: BlockHeader, end?: BlockHeader, tx?: IDatabaseTransaction, reachable?: boolean): AsyncGenerator<BlockHeader, void, void>;
    /**
     * This iterates the main chain from start (or genesis) to end (or the head).
     *
     * NOTE: Be warned that it's possible these hashes could change during a re-org and
     * "jump" chains. If you need safety, or are not sure what this means then you
     * should instead use Blockchain.iterateTo() instead.
     */
    iterateToHashes(start: BlockHeader, end?: BlockHeader, tx?: IDatabaseTransaction, reachable?: boolean): AsyncGenerator<BlockHash, void, void>;
    /**
     * Iterate the main chain from right to left inclusive.
     * Start and end being included in the yielded blocks.
     * */
    iterateFrom(start: BlockHeader, end?: BlockHeader, tx?: IDatabaseTransaction, reachable?: boolean): AsyncGenerator<BlockHeader, void, void>;
    isInvalid(headerOrHash: BlockHeader | BlockHash): VerificationResultReason | null;
    addInvalid(hash: BlockHash, reason: VerificationResultReason): void;
    private connect;
    disconnect(block: Block, tx: IDatabaseTransaction): Promise<void>;
    private reconnect;
    private addForkToChain;
    private addHeadToChain;
    /**
     * Disconnects all blocks on another fork, and reconnects blocks
     * on the new head chain before `head`
     */
    private reorganizeChain;
    addOrphan(header: BlockHeader): void;
    private resolveOrphans;
    /**
     * Get the block with the given hash, if it exists.
     */
    getBlock(hashOrHeader: BlockHash | BlockHeader, tx?: IDatabaseTransaction): Promise<Block | null>;
    /**
     * Returns true if the blockchain has a block at the given hash
     */
    hasBlock(hash: BlockHash, tx?: IDatabaseTransaction): Promise<boolean>;
    /**
     * Returns true if the blockchain has any blocks at the given sequence
     */
    hasHashesAtSequence(sequence: number, tx?: IDatabaseTransaction): Promise<boolean>;
    /**
     * Returns an array of hashes for any blocks at the given sequence
     */
    getHashesAtSequence(sequence: number, tx?: IDatabaseTransaction): Promise<BlockHash[]>;
    putTransaction(hash: Buffer, value: TransactionsValue, tx?: IDatabaseTransaction): Promise<void>;
    clearSequenceToHash(tx?: IDatabaseTransaction): Promise<void>;
    putSequenceToHash(sequence: number, hash: Buffer, tx?: IDatabaseTransaction): Promise<void>;
    /**
     * Create a new block on the chain.
     *
     * When 'verifyBlock' is set, excluding the randomness, the new block is guaranteed
     * to be valid with the current state of the chain. If the chain's head does
     * not change, then the new block can be added to the chain, once its
     * randomness is set to something that meets the target of the chain.
     *
     * After calling this function, the chain itself remains unchanged. No notes
     * or nullifiers have been added to the tree, and no blocks have been added
     * to the chain, including the newly minted one.
     */
    newBlock(userTransactions: Transaction[], minersFee: Transaction, graffiti?: Buffer, previous?: BlockHeader, verifyBlock?: boolean): Promise<Block>;
    getHeader(hash: BlockHash, tx?: IDatabaseTransaction): Promise<BlockHeader | null>;
    getPrevious(header: BlockHeader, tx?: IDatabaseTransaction): Promise<BlockHeader | null>;
    getNextHash(hash: BlockHash, tx?: IDatabaseTransaction): Promise<BlockHash | null>;
    /**
     * Gets the hash of the block at the sequence on the head chain
     */
    getHashAtSequence(sequence: number, tx?: IDatabaseTransaction): Promise<BlockHash | null>;
    getBlockHashByTransactionHash(transactionHash: TransactionHash, tx?: IDatabaseTransaction): Promise<BlockHash | null>;
    transactionHashHasBlock(transactionHash: TransactionHash, tx?: IDatabaseTransaction): Promise<boolean>;
    /**
     * Gets the header of the block at the sequence on the head chain
     */
    getHeaderAtSequence(sequence: number): Promise<BlockHeader | null>;
    getHeadersAtSequence(sequence: number, tx?: IDatabaseTransaction): Promise<BlockHeader[]>;
    isHeadChain(header: BlockHeader, tx?: IDatabaseTransaction): Promise<boolean>;
    getNext(header: BlockHeader, tx?: IDatabaseTransaction): Promise<BlockHeader | null>;
    putNextHash(hash: Buffer, nextHash: Buffer, tx?: IDatabaseTransaction): Promise<void>;
    clearHashToNextHash(tx?: IDatabaseTransaction): Promise<void>;
    removeBlock(hash: Buffer): Promise<void>;
    /**
     * Iterates through block headers, starting from fromHash or the genesis block,
     * to toHash or the heaviest head.
     */
    iterateBlockHeaders(fromHash?: Buffer | null, toHash?: Buffer | null, tx?: IDatabaseTransaction, reachable?: boolean): AsyncGenerator<BlockHeader, void, void>;
    getBlockTransactions(header: BlockHeader, tx?: IDatabaseTransaction): Promise<{
        transaction: Transaction;
        initialNoteIndex: number;
        sequence: number;
        blockHash: Buffer;
        previousBlockHash: Buffer;
        timestamp: Date;
    }[]>;
    saveConnect(block: Block, prev: BlockHeader | null, tx: IDatabaseTransaction): Promise<void>;
    private saveDisconnect;
    private saveBlock;
    private saveConnectedMintsToAssetsStore;
    private saveConnectedBurnsToAssetsStore;
    private deleteDisconnectedBurnsFromAssetsStore;
    private deleteDisconnectedMintsFromAssetsStore;
    private updateSynced;
    getAssetById(assetId: Buffer, tx?: IDatabaseTransaction): Promise<AssetValue | null>;
}
export declare class VerifyError extends Error {
    name: string;
    reason: VerificationResultReason;
    score: number;
    constructor(reason: VerificationResultReason, score?: number);
}
export declare class HeadChangedError extends Error {
    name: string;
}
//# sourceMappingURL=blockchain.d.ts.map