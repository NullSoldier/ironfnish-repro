"use strict";
/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/. */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.HeaderEncoding = void 0;
const bufio_1 = __importDefault(require("bufio"));
const assert_1 = require("../../assert");
const blockheader_1 = require("../../primitives/blockheader");
const target_1 = require("../../primitives/target");
const bigint_1 = require("../../utils/bigint");
class HeaderEncoding {
    serialize(value) {
        assert_1.Assert.isNotNull(value.header.noteSize, 'The note tree size should be set on the block header before saving it to the database.');
        const bw = bufio_1.default.write(this.getSize(value));
        bw.writeU32(value.header.sequence);
        bw.writeHash(value.header.previousBlockHash);
        bw.writeHash(value.header.noteCommitment);
        bw.writeU32(value.header.noteSize);
        bw.writeHash(value.header.transactionCommitment);
        bw.writeBigU256BE(value.header.target.asBigInt());
        bw.writeBigU64(value.header.randomness);
        bw.writeU64(value.header.timestamp.getTime());
        bw.writeBytes(value.header.graffiti);
        bw.writeVarBytes(bigint_1.BigIntUtils.toBytesLE(value.header.work));
        bw.writeHash(value.header.hash);
        return bw.render();
    }
    deserialize(data) {
        const reader = bufio_1.default.read(data, true);
        const sequence = reader.readU32();
        const previousBlockHash = reader.readHash();
        const noteCommitment = reader.readHash();
        const noteSize = reader.readU32();
        const transactionCommitment = reader.readHash();
        const target = new target_1.Target(reader.readBigU256BE());
        const randomness = reader.readBigU64();
        const timestamp = reader.readU64();
        const graffiti = reader.readBytes(32);
        const work = bigint_1.BigIntUtils.fromBytesLE(reader.readVarBytes());
        const hash = reader.readHash();
        const header = new blockheader_1.BlockHeader(sequence, previousBlockHash, noteCommitment, transactionCommitment, target, randomness, new Date(timestamp), graffiti, noteSize, work, hash);
        return { header };
    }
    getSize(value) {
        let size = 0;
        size += 4; // sequence
        size += 32; // previousBlockHash
        size += 32; // noteCommitment
        size += 4; // noteSize
        size += 32; // transactionCommitment
        size += 32; // target
        size += 8; // randomness
        size += 8; // timestamp
        size += 32; // graffiti
        size += bufio_1.default.sizeVarBytes(bigint_1.BigIntUtils.toBytesLE(value.header.work));
        size += 32; // hash
        return size;
    }
}
exports.HeaderEncoding = HeaderEncoding;
//# sourceMappingURL=headers.js.map