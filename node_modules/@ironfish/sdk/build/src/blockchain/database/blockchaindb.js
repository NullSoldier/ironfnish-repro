"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.BlockchainDB = exports.VERSION_DATABASE_CHAIN = void 0;
/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/. */
const assert_1 = require("../../assert");
const storage_1 = require("../../storage");
const utils_1 = require("../../storage/utils");
const assetValue_1 = require("./assetValue");
const headers_1 = require("./headers");
const sequenceToHashes_1 = require("./sequenceToHashes");
const transactions_1 = require("./transactions");
exports.VERSION_DATABASE_CHAIN = 28;
class BlockchainDB {
    constructor(options) {
        this.location = options.location;
        this.files = options.files;
        this.db = utils_1.createDB({ location: options.location });
        // BlockHash -> BlockHeader
        this.headers = this.db.addStore({
            name: 'bh',
            keyEncoding: storage_1.BUFFER_ENCODING,
            valueEncoding: new headers_1.HeaderEncoding(),
        });
        // Flat Fields
        this.meta = this.db.addStore({
            name: 'bm',
            keyEncoding: new storage_1.StringEncoding(),
            valueEncoding: storage_1.BUFFER_ENCODING,
        });
        // BlockHash -> Transaction[]
        this.transactions = this.db.addStore({
            name: 'bt',
            keyEncoding: storage_1.BUFFER_ENCODING,
            valueEncoding: new transactions_1.TransactionsValueEncoding(),
        });
        // number -> BlockHash[]
        this.sequenceToHashes = this.db.addStore({
            name: 'bs',
            keyEncoding: storage_1.U32_ENCODING,
            valueEncoding: new sequenceToHashes_1.SequenceToHashesValueEncoding(),
        });
        // number -> BlockHash
        this.sequenceToHash = this.db.addStore({
            name: 'bS',
            keyEncoding: storage_1.U32_ENCODING,
            valueEncoding: storage_1.BUFFER_ENCODING,
        });
        this.hashToNextHash = this.db.addStore({
            name: 'bH',
            keyEncoding: storage_1.BUFFER_ENCODING,
            valueEncoding: storage_1.BUFFER_ENCODING,
        });
        this.assets = this.db.addStore({
            name: 'bA',
            keyEncoding: storage_1.BUFFER_ENCODING,
            valueEncoding: new assetValue_1.AssetValueEncoding(),
        });
        this.transactionHashToBlockHash = this.db.addStore({
            name: 'tb',
            keyEncoding: storage_1.BUFFER_ENCODING,
            valueEncoding: storage_1.BUFFER_ENCODING,
        });
    }
    async open() {
        await this.files.mkdir(this.location, { recursive: true });
        await this.db.open();
        await this.db.upgrade(exports.VERSION_DATABASE_CHAIN);
    }
    async close() {
        await this.db.close();
    }
    async getBlockHeader(blockHash, tx) {
        return (await this.headers.get(blockHash, tx))?.header;
    }
    async deleteHeader(hash, tx) {
        return this.headers.del(hash, tx);
    }
    async putBlockHeader(hash, header, tx) {
        return this.headers.put(hash, header, tx);
    }
    async getMetaHash(key, tx) {
        return this.meta.get(key, tx);
    }
    async putMetaHash(key, value, tx) {
        return this.meta.put(key, value, tx);
    }
    async getTransactions(blockHash, tx) {
        return this.transactions.get(blockHash, tx);
    }
    async addTransaction(hash, value, tx) {
        return this.transactions.add(hash, value, tx);
    }
    async putTransaction(hash, value, tx) {
        return this.transactions.put(hash, value, tx);
    }
    async deleteTransaction(hash, tx) {
        return this.transactions.del(hash, tx);
    }
    async getBlockHashesAtSequence(sequence, tx) {
        const hashes = await this.sequenceToHashes.get(sequence, tx);
        if (!hashes) {
            return [];
        }
        return hashes.hashes;
    }
    async getBlockHeadersAtSequence(sequence, tx) {
        const hashes = await this.sequenceToHashes.get(sequence, tx);
        if (!hashes) {
            return [];
        }
        const headers = await Promise.all(hashes.hashes.map(async (h) => {
            const header = await this.getBlockHeader(h, tx);
            assert_1.Assert.isNotUndefined(header);
            return header;
        }));
        return headers;
    }
    async deleteSequenceToHashes(sequence, tx) {
        return this.sequenceToHashes.del(sequence, tx);
    }
    async putSequenceToHashes(sequence, hashes, tx) {
        return this.sequenceToHashes.put(sequence, { hashes }, tx);
    }
    async getBlockHashAtSequence(sequence, tx) {
        return this.sequenceToHash.get(sequence, tx);
    }
    async getBlockHeaderAtSequence(sequence) {
        const hash = await this.sequenceToHash.get(sequence);
        if (!hash) {
            return undefined;
        }
        return this.getBlockHeader(hash);
    }
    async putSequenceToHash(sequence, hash, tx) {
        return this.sequenceToHash.put(sequence, hash, tx);
    }
    async deleteSequenceToHash(sequence, tx) {
        return this.sequenceToHash.del(sequence, tx);
    }
    async clearSequenceToHash(tx) {
        return this.sequenceToHash.clear(tx);
    }
    async getNextHash(hash, tx) {
        return this.hashToNextHash.get(hash, tx);
    }
    async putNextHash(hash, nextHash, tx) {
        return this.hashToNextHash.put(hash, nextHash, tx);
    }
    async deleteNextHash(hash, tx) {
        return this.hashToNextHash.del(hash, tx);
    }
    async clearHashToNextHash(tx) {
        return this.hashToNextHash.clear(tx);
    }
    async getAsset(assetId, tx) {
        return this.assets.get(assetId, tx);
    }
    async putAsset(assetId, assetValue, tx) {
        return this.assets.put(assetId, assetValue, tx);
    }
    async deleteAsset(assetId, tx) {
        return this.assets.del(assetId, tx);
    }
    async getBlockHashByTransactionHash(transactionHash, tx) {
        return this.transactionHashToBlockHash.get(transactionHash, tx);
    }
    async transactionHashHasBlock(transactionHash, tx) {
        return this.transactionHashToBlockHash.has(transactionHash, tx);
    }
    async putTransactionHashToBlockHash(transactionHash, blockHash, tx) {
        return this.transactionHashToBlockHash.put(transactionHash, blockHash, tx);
    }
    async deleteTransactionHashToBlockHash(transactionHash, tx) {
        return this.transactionHashToBlockHash.del(transactionHash, tx);
    }
    async compact() {
        return this.db.compact();
    }
    async getVersion() {
        return this.db.getVersion();
    }
    transaction() {
        return this.db.transaction();
    }
    async size() {
        return this.db.size();
    }
}
exports.BlockchainDB = BlockchainDB;
//# sourceMappingURL=blockchaindb.js.map