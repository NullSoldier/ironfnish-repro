"use strict";
/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/. */
Object.defineProperty(exports, "__esModule", { value: true });
exports.NullifierSet = void 0;
const assert_1 = require("../../assert");
const storage_1 = require("../../storage");
class NullifierSet {
    constructor(options) {
        this.db = options.db;
        this.counter = this.db.addStore({
            name: `${options.name}c`,
            keyEncoding: new storage_1.StringEncoding(),
            valueEncoding: storage_1.U32_ENCODING,
        });
        this.nullifiers = this.db.addStore({
            name: options.name,
            keyEncoding: storage_1.BUFFER_ENCODING,
            valueEncoding: storage_1.BUFFER_ENCODING,
        });
    }
    async size(tx) {
        const size = await this.counter.get('Size', tx);
        return size === undefined ? 0 : size;
    }
    async contains(nullifier, tx) {
        return await this.nullifiers.has(nullifier, tx);
    }
    get(nullifier, tx) {
        return this.nullifiers.get(nullifier, tx);
    }
    async connectBlock(block, tx) {
        await this.db.withTransaction(tx, async (tx) => {
            let currentSize = await this.size(tx);
            for (const transaction of block.transactions) {
                for (const spend of transaction.spends) {
                    // Throws an error if a nullifier already exists
                    // We should never allow overwriting a nullifier
                    await this.nullifiers.add(spend.nullifier, transaction.hash(), tx);
                    currentSize++;
                }
            }
            await this.counter.put('Size', currentSize, tx);
        });
    }
    async disconnectBlock(block, tx) {
        await this.db.withTransaction(tx, async (tx) => {
            let currentSize = await this.size(tx);
            for (const transaction of block.transactions) {
                for (const spend of transaction.spends.slice().reverse()) {
                    // Sanity check that we are removing the correct block
                    // Not necessarily needed but will keep it here for confidence in the new nullifier set
                    const current = await this.nullifiers.get(spend.nullifier, tx);
                    assert_1.Assert.isNotUndefined(current);
                    assert_1.Assert.isTrue(current.equals(transaction.hash()));
                    await this.nullifiers.del(spend.nullifier, tx);
                    currentSize--;
                }
            }
            await this.counter.put('Size', currentSize, tx);
        });
    }
    async clear(tx) {
        await this.db.withTransaction(tx, async (tx) => {
            await this.nullifiers.clear(tx);
            await this.counter.clear(tx);
        });
    }
}
exports.NullifierSet = NullifierSet;
//# sourceMappingURL=nullifierSet.js.map