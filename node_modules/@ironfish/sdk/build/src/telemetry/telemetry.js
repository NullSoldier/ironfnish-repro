"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Telemetry = void 0;
/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/. */
const assert_1 = require("../assert");
const logger_1 = require("../logger");
const messageRegistry_1 = require("../network/messageRegistry");
const types_1 = require("../network/types");
const utils_1 = require("../utils");
class Telemetry {
    constructor(options) {
        this.FLUSH_INTERVAL = 60 * 60 * 1000; // 60 minutes
        this.MAX_POINTS_TO_SUBMIT = 1000;
        this.MAX_RETRIES = 5;
        this.METRICS_INTERVAL = 5 * 60 * 1000; // 5 minutes
        this.chain = options.chain;
        this.workerPool = options.workerPool;
        this.config = options.config;
        this.logger = options.logger ?? logger_1.createRootLogger();
        this.metrics = options.metrics ?? null;
        this.defaultTags = options.defaultTags ?? [];
        this.defaultTags.push({ name: 'networkId', value: options.networkId.toString() });
        this.defaultFields = options.defaultFields ?? [];
        this.localPeerIdentity = options.localPeerIdentity;
        this.flushInterval = null;
        this.metricsInterval = null;
        this.points = [];
        this.retries = 0;
        this._submitted = 0;
        this.started = false;
        this.apiUrl = this.config.get('telemetryApi');
        if (!this.apiUrl && options.networkId === 0) {
            this.apiUrl = 'https://testnet.api.ironfish.network';
        }
        else if (!this.apiUrl) {
            this.apiUrl = 'https://api.ironfish.network';
        }
    }
    get pending() {
        return this.points.length;
    }
    get submitted() {
        return this._submitted;
    }
    start() {
        if (this.started) {
            return;
        }
        this.started = true;
        void this.flushLoop();
        if (this.metrics) {
            this.metricsInterval = setTimeout(() => {
                void this.metricsLoop();
            }, this.METRICS_INTERVAL);
        }
    }
    async stop() {
        if (!this.started) {
            return;
        }
        this.started = false;
        if (this.flushInterval) {
            clearTimeout(this.flushInterval);
        }
        if (this.metricsInterval) {
            clearTimeout(this.metricsInterval);
        }
        this.submitNodeStopped();
        await this.flush();
    }
    isStarted() {
        return this.started;
    }
    async flushLoop() {
        await this.flush();
        this.flushInterval = setTimeout(() => {
            void this.flushLoop();
        }, this.FLUSH_INTERVAL);
    }
    metricsLoop() {
        assert_1.Assert.isNotNull(this.metrics);
        for (const [id, meter] of this.metrics.p2p_OutboundMessagesByPeer) {
            this.submit({
                measurement: 'peer_messages',
                timestamp: new Date(),
                fields: [
                    {
                        name: 'source',
                        type: 'string',
                        value: this.localPeerIdentity,
                    },
                    {
                        name: 'target',
                        type: 'string',
                        value: id,
                    },
                    {
                        name: 'amount',
                        type: 'float',
                        value: meter.rate5m,
                    },
                ],
            });
        }
        const fields = [
            {
                name: 'heap_used',
                type: 'integer',
                value: this.metrics.heapUsed.value,
            },
            {
                name: 'heap_total',
                type: 'integer',
                value: this.metrics.heapTotal.value,
            },
            {
                name: 'rss',
                type: 'integer',
                value: this.metrics.rss.value,
            },
            {
                name: 'inbound_traffic',
                type: 'float',
                value: this.metrics.p2p_InboundTraffic.rate5m,
            },
            {
                name: 'outbound_traffic',
                type: 'float',
                value: this.metrics.p2p_OutboundTraffic.rate5m,
            },
            {
                name: 'peers_count',
                type: 'integer',
                value: this.metrics.p2p_PeersCount.value,
            },
            {
                name: 'mempool_size',
                type: 'integer',
                value: this.metrics.memPoolSize.value,
            },
            {
                name: 'mempool_size_bytes',
                type: 'integer',
                value: Math.round(this.metrics.memPoolSizeBytes.value),
            },
            {
                name: 'mempool_max_size_bytes',
                type: 'integer',
                value: Math.round(this.metrics.memPoolMaxSizeBytes.value),
            },
            {
                name: 'mempool_saturation',
                type: 'integer',
                value: Math.round(this.metrics.memPoolSaturation.value * 100),
            },
            {
                name: 'mempool_evictions',
                type: 'integer',
                value: this.metrics.memPoolEvictions.value,
            },
            {
                name: 'mempool_recently_evicted_cache_size',
                type: 'integer',
                value: this.metrics.memPool_RecentlyEvictedCache_Size.value,
            },
            {
                name: 'mempool_recently_evicted_cache_max_size',
                type: 'integer',
                value: this.metrics.memPool_RecentlyEvictedCache_MaxSize.value,
            },
            {
                name: 'mempool_recently_evicted_cache_saturation',
                type: 'integer',
                value: this.metrics.memPool_RecentlyEvictedCache_Saturation.value,
            },
            {
                name: 'head_sequence',
                type: 'integer',
                value: this.chain.head.sequence,
            },
        ];
        for (const [messageType, meter] of this.metrics.p2p_InboundTrafficByMessage) {
            fields.push({
                name: 'inbound_traffic_' + types_1.NetworkMessageType[messageType].toLowerCase(),
                type: 'float',
                value: meter.rate5m,
            });
        }
        for (const [messageType, meter] of this.metrics.p2p_OutboundTrafficByMessage) {
            fields.push({
                name: 'outbound_traffic_' + types_1.NetworkMessageType[messageType].toLowerCase(),
                type: 'float',
                value: meter.rate5m,
            });
        }
        for (const [messageType, meter] of this.metrics.p2p_RpcResponseTimeMsByMessage) {
            if (messageRegistry_1.isRpcNetworkMessageType(messageType) && meter._average.sampleCount() >= 10) {
                fields.push({
                    name: 'rpc_response_ms_' + types_1.NetworkMessageType[messageType].toLowerCase(),
                    type: 'float',
                    value: meter.avg,
                });
            }
        }
        for (const [messageType, meter] of this.metrics.p2p_RpcSuccessRateByMessage) {
            if (messageRegistry_1.isRpcNetworkMessageType(messageType) && meter._average.sampleCount() >= 10) {
                fields.push({
                    name: 'rpc_success_' + types_1.NetworkMessageType[messageType].toLowerCase(),
                    type: 'float',
                    value: meter.avg,
                });
            }
        }
        if (this.metrics.mining_newBlockTemplate._average.sampleCount() >= 10) {
            fields.push({
                name: 'create_new_block_template_duration',
                type: 'float',
                value: this.metrics.mining_newBlockTemplate.avg,
            });
        }
        this.submit({
            measurement: 'node_stats',
            timestamp: new Date(),
            tags: [
                {
                    name: 'synced',
                    value: this.chain.synced.toString(),
                },
            ],
            fields,
        });
        this.metricsInterval = setTimeout(() => {
            void this.metricsLoop();
        }, this.METRICS_INTERVAL);
    }
    submit(metric) {
        if (!this.started) {
            return;
        }
        let tags = this.defaultTags;
        if (metric.tags) {
            tags = tags.concat(metric.tags);
        }
        const fields = this.defaultFields.concat(metric.fields);
        if (fields.length === 0) {
            throw new Error('Cannot submit metrics without fields');
        }
        // TODO(jason): RollingAverage can produce a negative number which seems
        // like it should be a bug. Investigate then delete this TODO. Negative
        // floats are not allowed by telemetry and produce a 422 error.
        for (const field of fields) {
            if (field.type === 'float') {
                field.value = Math.max(0, field.value);
            }
        }
        this.points.push({
            ...metric,
            timestamp: metric.timestamp,
            tags,
            fields,
        });
    }
    async flush() {
        const points = this.points.slice(0, this.MAX_POINTS_TO_SUBMIT);
        this.points = this.points.slice(this.MAX_POINTS_TO_SUBMIT);
        if (points.length === 0) {
            return;
        }
        try {
            const graffiti = utils_1.GraffitiUtils.fromString(this.config.get('blockGraffiti'));
            await this.workerPool.submitTelemetry(points, graffiti, this.apiUrl);
            this.logger.debug(`Submitted ${points.length} telemetry points`);
            this.retries = 0;
            this._submitted += points.length;
        }
        catch (error) {
            this.logger.error(`Error submitting telemetry to API: ${utils_1.renderError(error)}`);
            if (this.retries < this.MAX_RETRIES) {
                this.logger.debug('Retrying telemetry submission');
                this.retries++;
                this.points = points.concat(this.points);
            }
            else {
                this.logger.debug('Max retries reached. Resetting telemetry points');
                this.retries = 0;
                this.points = [];
            }
        }
    }
    submitNodeStarted() {
        let fields = [{ name: 'online', type: 'boolean', value: true }];
        if (this.metrics) {
            fields = fields.concat([
                { name: 'cpu_cores', type: 'integer', value: this.metrics.cpuCores },
                { name: 'memory_total', type: 'integer', value: this.metrics.memTotal },
            ]);
        }
        this.submit({
            measurement: 'node_started',
            fields,
            timestamp: new Date(),
        });
    }
    submitNodeStopped() {
        this.submit({
            measurement: 'node_started',
            fields: [{ name: 'online', type: 'boolean', value: false }],
            timestamp: new Date(),
        });
    }
    submitBlockMined(block) {
        this.submit({
            measurement: 'block_mined',
            fields: [
                {
                    name: 'difficulty',
                    type: 'integer',
                    value: Number(block.header.target.toDifficulty()),
                },
                {
                    name: 'sequence',
                    type: 'integer',
                    value: Number(block.header.sequence),
                },
            ],
            timestamp: new Date(),
        });
    }
    submitNewBlockSeen(block, seenAt) {
        this.submit({
            measurement: 'block_propagation',
            timestamp: seenAt,
            tags: [
                {
                    name: 'hash',
                    value: block.header.hash.toString('hex'),
                },
            ],
            fields: [
                {
                    name: 'timestamp',
                    type: 'integer',
                    value: block.header.timestamp.valueOf(),
                },
                {
                    name: 'sequence',
                    type: 'integer',
                    value: block.header.sequence,
                },
            ],
        });
    }
    submitCompactBlockAssembled(header, missingTransactionCount, foundTransactionCount) {
        const totalTransactions = missingTransactionCount + foundTransactionCount;
        const foundPercent = totalTransactions !== 0 ? foundTransactionCount / totalTransactions : 1;
        this.submit({
            measurement: 'block_assembled',
            timestamp: new Date(),
            tags: [
                {
                    name: 'hash',
                    value: header.hash.toString('hex'),
                },
            ],
            fields: [
                {
                    name: 'missing_transactions',
                    type: 'integer',
                    value: missingTransactionCount,
                },
                {
                    name: 'found_transactions',
                    type: 'integer',
                    value: foundTransactionCount,
                },
                {
                    name: 'found_percent',
                    type: 'float',
                    value: foundPercent,
                },
            ],
        });
    }
    submitNewTransactionSeen(transaction, seenAt) {
        const hash = transaction.hash();
        if (!this.shouldSubmitTransaction(hash)) {
            return;
        }
        this.submit({
            measurement: 'transaction_propagation',
            timestamp: seenAt,
            tags: [
                {
                    name: 'hash',
                    value: hash.toString('hex'),
                },
            ],
            fields: [],
        });
    }
    /*
     * We don't want to log all transaction propagation because there are too many
     * In this way we can only log propagation for a percentage of transactions
     */
    shouldSubmitTransaction(hash) {
        return hash.readDoubleBE() % 10000 === 0;
    }
}
exports.Telemetry = Telemetry;
//# sourceMappingURL=telemetry.js.map