"use strict";
/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/. */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.mockImplementationShuffle = exports.typeMock = exports.splitNotes = exports.writeTestReport = exports.getUniqueTestDataDir = exports.getCurrentTestPath = exports.TEST_DATA_DIR = void 0;
/* eslint-disable no-console */
const rust_nodejs_1 = require("@ironfish/rust-nodejs");
const path_1 = __importDefault(require("path"));
const uuid_1 = require("uuid");
const assert_1 = require("../assert");
const transaction_1 = require("./helpers/transaction");
exports.TEST_DATA_DIR = path_1.default.join(process.cwd(), 'testdbs');
/**
 * This is only usable in the jasmine runner
 */
function getCurrentTestPath() {
    return expect.getState().testPath || '';
}
exports.getCurrentTestPath = getCurrentTestPath;
function getUniqueTestDataDir() {
    return path_1.default.join(exports.TEST_DATA_DIR, uuid_1.v4());
}
exports.getUniqueTestDataDir = getUniqueTestDataDir;
function writeTestReport(csvReport, consoleReport, testName) {
    if (process.env.GENERATE_TEST_REPORT) {
        let row = '';
        csvReport.forEach((v, k) => (row = row.concat(`${k}:${v},`)));
        console.log(row.substring(0, row.length - 1));
    }
    else {
        console.info(`[TEST RESULTS: ${testName}]`);
        consoleReport.forEach((v, k) => console.info(`${k}: ${v}`));
    }
}
exports.writeTestReport = writeTestReport;
async function splitNotes(account, numOutputs, wallet) {
    const outputs = [];
    for (let i = 0; i < numOutputs; i++) {
        outputs.push({
            publicAddress: account.publicAddress,
            amount: BigInt(1),
            memo: '',
            assetId: rust_nodejs_1.Asset.nativeId(),
        });
    }
    const transaction = await transaction_1.createRawTransaction({
        wallet: wallet,
        from: account,
        amount: BigInt(outputs.length),
        outputs,
    });
    assert_1.Assert.isNotNull(account.spendingKey);
    return transaction.post(account.spendingKey);
}
exports.splitNotes = splitNotes;
/**
 * Asserts the type of a given function as a Jest mock.
 */
function typeMock(func) {
    return func;
}
exports.typeMock = typeMock;
/**
 * Used to shuffle the responses from an asynchronous API call using a debounce strategy.
 * @param mock The mock to intercept calls for and shuffle
 * @param mocked The mock function to replace mock with
 * @param time The maximum amount of debounce time to allow before returning shuffled results
 */
function mockImplementationShuffle(mock, mocked, time = 10) {
    const buffer = [];
    let lastTimeout = null;
    let lastSend = null;
    mock.mockImplementation((...args) => {
        const promise = new Promise((resolve) => {
            if (lastTimeout) {
                clearTimeout(lastTimeout);
            }
            buffer.push([args, resolve]);
            function send() {
                lastSend = Date.now();
                const shuffled = buffer.slice().sort(() => Math.random() - 0.5);
                buffer.length = 0;
                for (const [args, resolve] of shuffled) {
                    resolve(mocked(...args));
                }
            }
            // Force a send if the maximum amount of time has elapsed
            if (lastSend !== null && Date.now() - lastSend > time) {
                send();
                return;
            }
            // Start the debounce timer
            lastTimeout = setTimeout(send, time);
        });
        return promise.then((r) => r);
    });
    return () => {
        if (lastTimeout) {
            clearTimeout(lastTimeout);
        }
    };
}
exports.mockImplementationShuffle = mockImplementationShuffle;
//# sourceMappingURL=utils.js.map