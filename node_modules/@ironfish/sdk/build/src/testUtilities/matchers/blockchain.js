"use strict";
/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/. */
Object.defineProperty(exports, "__esModule", { value: true });
const jest_diff_1 = require("jest-diff");
const utils_1 = require("./utils");
function toEqualHash(self, other) {
    let error = null;
    if (!self || !other) {
        error = `Expected or actual == null:\n\nDifference:\n\n${String(jest_diff_1.diff(self, other))}`;
    }
    if (!error && self && other && !self.equals(other)) {
        error = `Hashes do not match:\n\nDifference:\n\n${String(jest_diff_1.diff(self, other))}`;
    }
    return utils_1.makeError(error, `Expected two serde elements to match, but they didn't`);
}
function toEqualNullifier(self, other) {
    let error = null;
    if (!self || !other) {
        error = `Expected or actual == null:\n\nDifference:\n\n${String(jest_diff_1.diff(self, other))}`;
    }
    if (!error && self && other && !self.equals(other)) {
        error = `Nullifiers do not match:\n\nDifference:\n\n${String(jest_diff_1.diff(self, other))}`;
    }
    return utils_1.makeError(error, `Expected two serde elements to match, but they didn't`);
}
async function toAddBlock(self, other) {
    const result = await self.addBlock(other);
    if (!result.isAdded) {
        return utils_1.makeResult(false, `Could not add block: ${String(result.reason)}`);
    }
    return utils_1.makeResult(true, `Expected to not add block at ${String(other.header.sequence)}`);
}
async function toAddDoubleSpendBlock(self, other) {
    // Mock data stores to allow creation of a double spend chain
    const transactionHashMock = jest
        .spyOn(self, 'transactionHashHasBlock')
        .mockResolvedValue(false);
    const containsMock = jest.spyOn(self.nullifiers['nullifiers'], 'has').mockResolvedValue(false);
    const addNullifierMock = jest
        .spyOn(self.nullifiers['nullifiers'], 'add')
        .mockImplementation((...args) => self.nullifiers['nullifiers'].put(...args));
    const result = await self.addBlock(other);
    transactionHashMock.mockRestore();
    containsMock.mockRestore();
    addNullifierMock.mockRestore();
    if (!result.isAdded) {
        return utils_1.makeResult(false, `Could not add block: ${String(result.reason)}`);
    }
    return utils_1.makeResult(true, `Expected to not add block at ${String(other.header.sequence)}`);
}
expect.extend({
    toEqualHash: toEqualHash,
    toEqualNullifier: toEqualNullifier,
    toAddBlock: toAddBlock,
    toAddDoubleSpendBlock: toAddDoubleSpendBlock,
});
//# sourceMappingURL=blockchain.js.map