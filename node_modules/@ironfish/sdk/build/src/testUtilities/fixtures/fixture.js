"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.useFixture = exports.disableFixtures = exports.shouldUpdateFixtures = void 0;
/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/. */
const fs_1 = __importDefault(require("fs"));
const path_1 = __importDefault(require("path"));
const serde_1 = require("../../serde");
const utils_1 = require("../utils");
const FIXTURE_FOLDER = '__fixtures__';
const fixtureIds = new Map();
const fixtureCache = new Map();
function shouldUpdateFixtures() {
    // Use the same parameters as jest snapshots for usability
    return process.argv.indexOf('--updateSnapshot') !== -1 || process.argv.indexOf('-u') !== -1;
}
exports.shouldUpdateFixtures = shouldUpdateFixtures;
function disableFixtures() {
    const currentTestName = expect.getState().currentTestName || '';
    const testName = currentTestName.replace(/ /g, '_');
    const fixtureInfo = fixtureIds.get(testName) || { id: 0, disabled: false };
    fixtureIds.set(testName, fixtureInfo);
    fixtureInfo.disabled = true;
}
exports.disableFixtures = disableFixtures;
async function useFixture(generate, options = {}) {
    const testPath = utils_1.getCurrentTestPath();
    const testName = expect.getState().currentTestName || '';
    const testDir = path_1.default.dirname(testPath);
    const testFile = path_1.default.basename(testPath);
    const fixtureInfo = fixtureIds.get(testName) || { id: -1, disabled: false };
    const fixtureId = (fixtureInfo.id += 1);
    fixtureIds.set(testName, fixtureInfo);
    const fixtureDir = path_1.default.join(testDir, FIXTURE_FOLDER);
    const fixtureName = `${testFile}.fixture`;
    const fixturePath = path_1.default.join(fixtureDir, fixtureName);
    const updateFixtures = shouldUpdateFixtures();
    let fixtures = fixtureCache.get(testPath);
    // Load serialized fixtures in if they are not loaded
    if (!fixtures) {
        fixtures = new Map();
        if (fs_1.default.existsSync(fixturePath)) {
            const buffer = await fs_1.default.promises.readFile(fixturePath);
            const data = serde_1.IJSON.parse(buffer.toString('utf8'));
            for (const test in data) {
                fixtures.set(test, data[test]);
            }
        }
        fixtureCache.set(testPath, fixtures);
    }
    let fixture = null;
    const serializedAll = fixtures.get(testName) || [];
    fixtures.set(testName, serializedAll);
    if (!updateFixtures && !fixtureInfo.disabled && serializedAll[fixtureId]) {
        // deserialize existing fixture
        if (options.deserialize) {
            const serialized = serializedAll[fixtureId];
            fixture = await options.deserialize(serialized);
        }
        else {
            fixture = serializedAll[fixtureId];
        }
        if (options.restore) {
            await options.restore(fixture);
        }
    }
    else {
        // generate the fixture
        fixture = await generate();
        const serialized = options.serialize ? await options?.serialize(fixture) : fixture;
        serializedAll[fixtureId] = serialized;
        if (!fs_1.default.existsSync(fixtureDir)) {
            await fs_1.default.promises.mkdir(fixtureDir);
        }
        const result = Object.fromEntries(fixtures.entries());
        const data = serde_1.IJSON.stringify(result, '  ');
        await fs_1.default.promises.writeFile(fixturePath, data);
    }
    if (options.process) {
        await options.process(fixture);
    }
    return fixture;
}
exports.useFixture = useFixture;
//# sourceMappingURL=fixture.js.map