"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.useTxSpendsFixture = exports.useBlockWithTxs = exports.useBlockWithTx = exports.useBlockWithRawTxFixture = exports.useBurnBlockFixture = exports.useMintBlockFixture = exports.useMinerBlockFixture = exports.useBlockFixture = exports.restoreBlockFixtureToAccounts = void 0;
/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/. */
const rust_nodejs_1 = require("@ironfish/rust-nodejs");
const assert_1 = require("../../assert");
const block_1 = require("../../primitives/block");
const note_1 = require("../../primitives/note");
const rawTransaction_1 = require("../../primitives/rawTransaction");
const account_1 = require("./account");
const fixture_1 = require("./fixture");
const transactions_1 = require("./transactions");
/*
 * We need the workaround because transactions related to us
 * that get added onto a block don't get handled in the same
 * way as if we created them, which is a problem. that's why
 * the transaction fixture uses accounts.createTransaction()
 * and not accountst.send(), so if its generated, and if its
 * cached, both have the same flow where we manually sync
 * them afterwards.
 */
async function restoreBlockFixtureToAccounts(block, wallet) {
    for (const transaction of block.transactions) {
        await transactions_1.restoreTransactionFixtureToAccounts(transaction, wallet);
    }
}
exports.restoreBlockFixtureToAccounts = restoreBlockFixtureToAccounts;
/**
 * Executes a generator function which creates a block and
 * caches that in the fixtures folder next to the current test
 */
async function useBlockFixture(chain, generate, addTransactionsTo) {
    return fixture_1.useFixture(generate, {
        process: async (block) => {
            if (addTransactionsTo) {
                await restoreBlockFixtureToAccounts(block, addTransactionsTo);
            }
        },
        serialize: (block) => {
            return block_1.BlockSerde.serialize(block);
        },
        deserialize: (serialized) => {
            return block_1.BlockSerde.deserialize(serialized);
        },
    });
}
exports.useBlockFixture = useBlockFixture;
/**
 * Generates a block with a miners fee transaction on the current chain state
 */
async function useMinerBlockFixture(chain, sequence, account, addTransactionsTo, transactions = []) {
    const spendingKey = account?.spendingKey ?? rust_nodejs_1.generateKey().spendingKey;
    const transactionFees = transactions.reduce((a, t) => a + t.fee(), BigInt(0));
    return await useBlockFixture(chain, async () => chain.newBlock(transactions, await chain.strategy.createMinersFee(transactionFees, sequence || chain.head.sequence + 1, spendingKey)), addTransactionsTo);
}
exports.useMinerBlockFixture = useMinerBlockFixture;
async function useMintBlockFixture(options) {
    if (!options.sequence) {
        options.sequence = options.node.chain.head.sequence;
    }
    const mint = await transactions_1.usePostTxFixture({
        node: options.node,
        wallet: options.node.wallet,
        from: options.account,
        mints: [
            {
                name: options.asset.name().toString('utf8'),
                metadata: options.asset.metadata().toString('utf8'),
                value: options.value,
            },
        ],
    });
    return useMinerBlockFixture(options.node.chain, options.sequence, undefined, undefined, [
        mint,
    ]);
}
exports.useMintBlockFixture = useMintBlockFixture;
async function useBurnBlockFixture(options) {
    if (!options.sequence) {
        options.sequence = options.node.chain.head.sequence;
    }
    const burn = await transactions_1.usePostTxFixture({
        node: options.node,
        wallet: options.node.wallet,
        from: options.account,
        burns: [{ assetId: options.asset.id(), value: options.value }],
    });
    return useMinerBlockFixture(options.node.chain, options.sequence, undefined, undefined, [
        burn,
    ]);
}
exports.useBurnBlockFixture = useBurnBlockFixture;
async function useBlockWithRawTxFixture(chain, pool, sender, notesToSpend, outputs, mints, burns, sequence) {
    const generate = async () => {
        const spends = await Promise.all(notesToSpend.map(async (n) => {
            const note = n.decryptNoteForOwner(sender.incomingViewKey);
            assert_1.Assert.isNotUndefined(note);
            const treeIndex = await chain.notes.leavesIndex.get(n.hash());
            assert_1.Assert.isNotUndefined(treeIndex);
            const witness = await chain.notes.witness(treeIndex);
            assert_1.Assert.isNotNull(witness);
            return {
                note,
                witness,
            };
        }));
        const raw = new rawTransaction_1.RawTransaction();
        raw.expiration = 0;
        raw.mints = mints;
        raw.burns = burns;
        raw.fee = BigInt(0);
        raw.spends = spends;
        for (const output of outputs) {
            const note = new rust_nodejs_1.Note(output.publicAddress, output.amount, output.memo, output.assetId, sender.publicAddress);
            raw.outputs.push({ note: new note_1.Note(note.serialize()) });
        }
        assert_1.Assert.isNotNull(sender.spendingKey);
        const transaction = await pool.postTransaction(raw, sender.spendingKey);
        return chain.newBlock([transaction], await chain.strategy.createMinersFee(transaction.fee(), sequence, sender.spendingKey));
    };
    return useBlockFixture(chain, generate);
}
exports.useBlockWithRawTxFixture = useBlockWithRawTxFixture;
/**
 * Produces a block with a transaction that has 1 spend, and 3 notes
 * By default first produces a block with a mining fee to fund the
 * {@link from} account and adds it to the chain.
 *
 * Returned block has 1 spend, 3 notes
 */
async function useBlockWithTx(node, from, to, useFee = true, options = { expiration: 0 }) {
    if (!from) {
        from = await account_1.useAccountFixture(node.wallet, 'test');
    }
    if (!to) {
        to = from;
    }
    let previous;
    if (useFee) {
        previous = await useMinerBlockFixture(node.chain, 2, from);
        await node.chain.addBlock(previous);
        await node.wallet.updateHead();
    }
    else {
        const head = await node.chain.getBlock(node.chain.head);
        assert_1.Assert.isNotNull(head);
        previous = head;
    }
    const block = await useBlockFixture(node.chain, async () => {
        assert_1.Assert.isNotUndefined(from);
        assert_1.Assert.isNotUndefined(to);
        const raw = await node.wallet.createTransaction({
            account: from,
            outputs: [
                {
                    publicAddress: to.publicAddress,
                    amount: BigInt(1),
                    memo: '',
                    assetId: rust_nodejs_1.Asset.nativeId(),
                },
            ],
            fee: BigInt(options.fee ?? 1n),
            expiration: options.expiration ?? 0,
            expirationDelta: 0,
        });
        assert_1.Assert.isNotNull(from.spendingKey);
        const transaction = await node.workerPool.postTransaction(raw, from.spendingKey);
        return node.chain.newBlock([transaction], await node.strategy.createMinersFee(transaction.fee(), 3, rust_nodejs_1.generateKey().spendingKey));
    });
    return { block, previous, account: from, transaction: block.transactions[1] };
}
exports.useBlockWithTx = useBlockWithTx;
/**
 * Produces a block with a multiple transaction that have 1 spend, and 3 notes
 * It first produces {@link numTransactions} blocks all with mining fees to fund
 * the transactions
 *
 * Returned block has {@link numTransactions} transactions
 */
async function useBlockWithTxs(node, numTransactions, from) {
    if (!from) {
        from = await account_1.useAccountFixture(node.wallet, 'test');
    }
    const to = from;
    let previous;
    for (let i = 0; i < numTransactions; i++) {
        previous = await useMinerBlockFixture(node.chain, node.chain.head.sequence + 1, from);
        await node.chain.addBlock(previous);
    }
    await node.wallet.updateHead();
    const block = await useBlockFixture(node.chain, async () => {
        const transactions = [];
        for (let i = 0; i < numTransactions; i++) {
            assert_1.Assert.isNotUndefined(from);
            const raw = await node.wallet.createTransaction({
                account: from,
                outputs: [
                    {
                        publicAddress: to.publicAddress,
                        amount: BigInt(1),
                        memo: '',
                        assetId: rust_nodejs_1.Asset.nativeId(),
                    },
                ],
                fee: 1n,
                expiration: 0,
                expirationDelta: 0,
            });
            assert_1.Assert.isNotNull(from.spendingKey);
            const transaction = await node.workerPool.postTransaction(raw, from.spendingKey);
            await node.wallet.addPendingTransaction(transaction);
            transactions.push(transaction);
        }
        const transactionFees = transactions.reduce((sum, t) => {
            return BigInt(sum) + t.fee();
        }, BigInt(0));
        return node.chain.newBlock(transactions, await node.strategy.createMinersFee(transactionFees, 3, rust_nodejs_1.generateKey().spendingKey));
    }, node.wallet);
    return { block, account: from, transactions: block.transactions.slice(1) };
}
exports.useBlockWithTxs = useBlockWithTxs;
async function useTxSpendsFixture(node, options) {
    const account = options?.account ?? (await account_1.useAccountFixture(node.wallet));
    const block = await useMinerBlockFixture(node.chain, 2, account, node.wallet);
    await expect(node.chain).toAddBlock(block);
    await node.wallet.updateHead();
    const transaction = await transactions_1.useTxFixture(node.wallet, account, account, undefined, options?.fee, options?.expiration, options?.restore);
    return {
        account: account,
        transaction: transaction,
    };
}
exports.useTxSpendsFixture = useTxSpendsFixture;
//# sourceMappingURL=blocks.js.map