"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.useMinersTxFixture = exports.useTxFixture = exports.usePostTxFixture = exports.restoreTransactionFixtureToAccounts = void 0;
/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/. */
const rust_nodejs_1 = require("@ironfish/rust-nodejs");
const assert_1 = require("../../assert");
const transaction_1 = require("../../primitives/transaction");
const transaction_2 = require("../helpers/transaction");
const account_1 = require("./account");
const fixture_1 = require("./fixture");
async function restoreTransactionFixtureToAccounts(transaction, wallet) {
    await wallet.addPendingTransaction(transaction);
}
exports.restoreTransactionFixtureToAccounts = restoreTransactionFixtureToAccounts;
async function usePostTxFixture(options) {
    return useTxFixture(options.wallet, options.from, options.to || options.from, async () => {
        const raw = await transaction_2.createRawTransaction(options);
        assert_1.Assert.isNotNull(options.from.spendingKey);
        return options.node.workerPool.postTransaction(raw, options.from.spendingKey);
    }, undefined, undefined, options.restore);
}
exports.usePostTxFixture = usePostTxFixture;
async function useTxFixture(wallet, from, to, generate, fee, expiration, restore = true) {
    generate =
        generate ||
            (async () => {
                const raw = await wallet.createTransaction({
                    account: from,
                    outputs: [
                        {
                            publicAddress: to.publicAddress,
                            amount: BigInt(1),
                            memo: '',
                            assetId: rust_nodejs_1.Asset.nativeId(),
                        },
                    ],
                    fee: fee ?? 0n,
                    expiration: expiration ?? 0,
                    expirationDelta: 0,
                });
                assert_1.Assert.isNotNull(from.spendingKey);
                return await wallet.workerPool.postTransaction(raw, from.spendingKey);
            });
    return fixture_1.useFixture(generate, {
        process: async (tx) => {
            if (restore) {
                await restoreTransactionFixtureToAccounts(tx, wallet);
            }
        },
        serialize: (tx) => {
            return tx.serialize();
        },
        deserialize: (tx) => {
            return new transaction_1.Transaction(tx);
        },
    });
}
exports.useTxFixture = useTxFixture;
async function useMinersTxFixture(node, to, sequence, amount = 0) {
    if (!to) {
        to = await account_1.useAccountFixture(node.wallet);
    }
    return useTxFixture(node.wallet, to, to, () => {
        assert_1.Assert.isNotUndefined(to);
        assert_1.Assert.isNotNull(to.spendingKey);
        return node.chain.strategy.createMinersFee(BigInt(amount), sequence || node.chain.head.sequence + 1, to.spendingKey);
    });
}
exports.useMinersTxFixture = useMinersTxFixture;
//# sourceMappingURL=transactions.js.map