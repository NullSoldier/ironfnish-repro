/// <reference types="node" />
import { Asset } from '@ironfish/rust-nodejs';
import { Blockchain } from '../../blockchain';
import { FullNode } from '../../node';
import { Block } from '../../primitives/block';
import { BurnDescription } from '../../primitives/burnDescription';
import { NoteEncrypted } from '../../primitives/noteEncrypted';
import { MintData } from '../../primitives/rawTransaction';
import { Transaction } from '../../primitives/transaction';
import { Account, Wallet } from '../../wallet';
import { WorkerPool } from '../../workerPool/pool';
import { FixtureGenerate } from './fixture';
export declare function restoreBlockFixtureToAccounts(block: Block, wallet: Wallet): Promise<void>;
/**
 * Executes a generator function which creates a block and
 * caches that in the fixtures folder next to the current test
 */
export declare function useBlockFixture(chain: Blockchain, generate: FixtureGenerate<Block>, addTransactionsTo?: Wallet): Promise<Block>;
/**
 * Generates a block with a miners fee transaction on the current chain state
 */
export declare function useMinerBlockFixture(chain: Blockchain, sequence?: number, account?: Account, addTransactionsTo?: Wallet, transactions?: Transaction[]): Promise<Block>;
export declare function useMintBlockFixture(options: {
    node: FullNode;
    account: Account;
    asset: Asset;
    value: bigint;
    sequence?: number;
}): Promise<Block>;
export declare function useBurnBlockFixture(options: {
    node: FullNode;
    account: Account;
    asset: Asset;
    value: bigint;
    sequence?: number;
}): Promise<Block>;
export declare function useBlockWithRawTxFixture(chain: Blockchain, pool: WorkerPool, sender: Account, notesToSpend: NoteEncrypted[], outputs: {
    publicAddress: string;
    amount: bigint;
    memo: string;
    assetId: Buffer;
}[], mints: MintData[], burns: BurnDescription[], sequence: number): Promise<Block>;
/**
 * Produces a block with a transaction that has 1 spend, and 3 notes
 * By default first produces a block with a mining fee to fund the
 * {@link from} account and adds it to the chain.
 *
 * Returned block has 1 spend, 3 notes
 */
export declare function useBlockWithTx(node: FullNode, from?: Account, to?: Account, useFee?: boolean, options?: {
    expiration?: number;
    fee?: number;
}): Promise<{
    account: Account;
    previous: Block;
    block: Block;
    transaction: Transaction;
}>;
/**
 * Produces a block with a multiple transaction that have 1 spend, and 3 notes
 * It first produces {@link numTransactions} blocks all with mining fees to fund
 * the transactions
 *
 * Returned block has {@link numTransactions} transactions
 */
export declare function useBlockWithTxs(node: FullNode, numTransactions: number, from?: Account): Promise<{
    account: Account;
    block: Block;
    transactions: Transaction[];
}>;
export declare function useTxSpendsFixture(node: FullNode, options?: {
    account?: Account;
    expiration?: number;
    restore?: boolean;
    fee?: bigint;
}): Promise<{
    account: Account;
    transaction: Transaction;
}>;
//# sourceMappingURL=blocks.d.ts.map