"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createRouteTest = exports.RouteTest = void 0;
const logger_1 = require("../logger");
const rpc_1 = require("../rpc");
const clients_1 = require("../rpc/clients");
const nodeTest_1 = require("./nodeTest");
/**
 * Used as an easy wrapper for an RPC route test. Use {@link createRouteTest}
 * to create one to make sure you call the proper test lifecycle methods on
 * the RouteTest
 */
class RouteTest extends nodeTest_1.NodeTest {
    async createSetup() {
        const setup = await super.createSetup();
        const logger = logger_1.createRootLogger().withTag('memoryclient');
        const client = new clients_1.RpcMemoryClient(logger, setup.node.rpc.getRouter(rpc_1.ALL_API_NAMESPACES));
        return { ...setup, client };
    }
    async setup() {
        const { sdk, node, strategy, chain, wallet, peerNetwork, syncer, workerPool, client } = await this.createSetup();
        this.sdk = sdk;
        this.node = node;
        this.strategy = strategy;
        this.chain = chain;
        this.wallet = wallet;
        this.syncer = syncer;
        this.peerNetwork = peerNetwork;
        this.client = client;
        this.workerPool = workerPool;
    }
}
exports.RouteTest = RouteTest;
/** Call this to create a {@link RouteTest} and ensure its test lifecycle
 * methods are called properly like beforeEach, beforeAll, etc
 */
function createRouteTest(preserveState = false) {
    const routeTest = new RouteTest();
    if (preserveState) {
        beforeAll(() => routeTest.setup(), 10000);
        afterEach(() => routeTest.teardownEach());
        afterAll(() => routeTest.teardownAll());
    }
    else {
        beforeEach(() => routeTest.setup(), 10000);
        afterEach(() => routeTest.teardownEach());
        afterEach(() => routeTest.teardownAll());
    }
    return routeTest;
}
exports.createRouteTest = createRouteTest;
//# sourceMappingURL=routeTest.js.map