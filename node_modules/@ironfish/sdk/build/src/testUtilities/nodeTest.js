"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createNodeTest = exports.NodeTest = void 0;
/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/. */
require("./matchers");
const sdk_1 = require("../sdk");
const strategy_1 = require("./strategy");
const utils_1 = require("./utils");
/**
 * Used as an easy wrapper for testing the node, and blockchain. Use
 * {@link createNodeTest} to create one to make sure you call the proper
 * test lifecycle methods on the NodeTest
 */
class NodeTest {
    constructor(options = {}) {
        this.setups = new Array();
        this.options = options;
    }
    async createSetup(options) {
        if (!options) {
            options = this.options;
        }
        const dataDir = utils_1.getUniqueTestDataDir();
        const strategyClass = strategy_1.TestStrategy;
        const sdk = await sdk_1.IronfishSdk.init({ dataDir, strategyClass });
        sdk.config.setOverride('bootstrapNodes', ['']);
        sdk.config.setOverride('networkId', 2);
        sdk.config.setOverride('enableListenP2P', false);
        sdk.config.setOverride('enableTelemetry', false);
        sdk.config.setOverride('enableAssetVerification', false);
        sdk.config.setOverride('confirmations', 0);
        // Allow tests to override default settings
        if (options?.config) {
            for (const key in options.config) {
                const configKey = key;
                const configValue = options.config[configKey];
                // eslint-disable-next-line @typescript-eslint/no-explicit-any
                sdk.config.setOverride(key, configValue);
            }
        }
        const node = await sdk.node({ autoSeed: this.options?.autoSeed });
        const strategy = node.strategy;
        const chain = node.chain;
        const wallet = node.wallet;
        const peerNetwork = node.peerNetwork;
        const syncer = node.syncer;
        const verifier = node.chain.verifier;
        const workerPool = node.workerPool;
        verifier.enableVerifyTarget = false;
        await node.openDB();
        const setup = {
            sdk,
            node,
            strategy,
            verifier,
            chain,
            wallet,
            peerNetwork,
            syncer,
            workerPool,
        };
        this.setups.push(setup);
        return setup;
    }
    async setup() {
        const { sdk, node, strategy, verifier, chain, wallet, peerNetwork, syncer, workerPool } = await this.createSetup();
        this.sdk = sdk;
        this.node = node;
        this.strategy = strategy;
        this.verifier = verifier;
        this.chain = chain;
        this.wallet = wallet;
        this.peerNetwork = peerNetwork;
        this.syncer = syncer;
        this.workerPool = workerPool;
    }
    async teardownEach() {
        for (const { node } of this.setups) {
            await node.shutdown();
        }
    }
    async teardownAll() {
        for (const { node } of this.setups) {
            await node.closeDB();
        }
    }
}
exports.NodeTest = NodeTest;
/** Call this to create a {@link NodeTest} and ensure its test lifecycle
 * methods are called properly like beforeEach, beforeAll, etc
 */
function createNodeTest(preserveState = false, options = {}) {
    const nodeTest = new NodeTest(options);
    if (preserveState) {
        beforeAll(() => nodeTest.setup(), 10000);
        afterAll(() => nodeTest.teardownAll());
    }
    else {
        beforeEach(() => nodeTest.setup(), 10000);
        afterEach(() => nodeTest.teardownEach());
        afterEach(() => nodeTest.teardownAll());
    }
    return nodeTest;
}
exports.createNodeTest = createNodeTest;
//# sourceMappingURL=nodeTest.js.map