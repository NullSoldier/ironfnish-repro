"use strict";
/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/. */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.makeTree = void 0;
const bufio_1 = __importDefault(require("bufio"));
const merkletree_1 = require("../../merkletree");
const hasher_1 = require("../../merkletree/hasher");
const merkletree_2 = require("../../merkletree/merkletree");
const storage_1 = require("../../storage");
const storage_2 = require("../helpers/storage");
class StructureLeafEncoding {
    serialize(value) {
        const bw = bufio_1.default.write();
        bw.writeVarString(value.merkleHash, 'utf8');
        bw.writeU32(value.parentIndex);
        return bw.render();
    }
    deserialize(buffer) {
        const bw = bufio_1.default.read(buffer, true);
        const merkleHash = bw.readVarString('utf8');
        const parentIndex = bw.readU32();
        return {
            merkleHash,
            parentIndex,
        };
    }
}
class StructureNodeEncoding {
    serialize(value) {
        const bw = bufio_1.default.write();
        bw.writeVarString(value.hashOfSibling, 'utf8');
        if (value.side === merkletree_2.Side.Left) {
            bw.writeU8(0);
            bw.writeU32(value.parentIndex);
        }
        else {
            bw.writeU8(1);
            bw.writeU32(value.leftIndex);
        }
        return bw.render();
    }
    deserialize(buffer) {
        const reader = bufio_1.default.read(buffer, true);
        const hashOfSibling = reader.readVarString('utf8');
        const sideNumber = reader.readU8();
        const side = sideNumber === 0 ? merkletree_2.Side.Left : merkletree_2.Side.Right;
        const otherIndex = reader.readU32();
        if (side === merkletree_2.Side.Left) {
            const leftNode = {
                side,
                hashOfSibling,
                parentIndex: otherIndex,
            };
            return leftNode;
        }
        const rightNode = {
            side,
            hashOfSibling,
            leftIndex: otherIndex,
        };
        return rightNode;
    }
}
async function makeTree({ name, db, location, depth, leaves, } = {}) {
    if (!db) {
        const { db: database } = await storage_2.createTestDB(undefined, location);
        db = database;
    }
    const tree = new merkletree_1.MerkleTree({
        hasher: new hasher_1.StructureHasher(),
        leafIndexKeyEncoding: new storage_1.StringEncoding(),
        leafEncoding: new StructureLeafEncoding(),
        nodeEncoding: new StructureNodeEncoding(),
        db: db,
        name: name,
        depth: depth,
        defaultValue: '~',
    });
    await db.open();
    if (leaves) {
        await tree.addBatch(leaves);
    }
    return tree;
}
exports.makeTree = makeTree;
//# sourceMappingURL=merkletree.js.map