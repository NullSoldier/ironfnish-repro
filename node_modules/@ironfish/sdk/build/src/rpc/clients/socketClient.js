"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.RpcSocketClient = void 0;
/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/. */
const net_1 = __importDefault(require("net"));
const assert_1 = require("../../assert");
const event_1 = require("../../event");
const logger_1 = require("../../logger");
const utils_1 = require("../../utils");
const adapters_1 = require("../adapters");
const messageBuffer_1 = require("../messageBuffer");
const response_1 = require("../response");
const stream_1 = require("../stream");
const client_1 = require("./client");
const errors_1 = require("./errors");
class RpcSocketClient extends client_1.RpcClient {
    constructor(connectTo, logger, authToken) {
        super(logger ?? logger_1.createRootLogger());
        this.onClose = new event_1.Event();
        this.authToken = null;
        this.client = null;
        this.isConnected = false;
        this.timeoutMs = null;
        this.messageIds = 0;
        this.pending = new Map();
        this.handleStream = async (data) => {
            const { result, error } = await utils_1.YupUtils.tryValidate(adapters_1.SocketRpcStreamSchema, data);
            if (!result) {
                throw error;
            }
            const pending = this.pending.get(result.id);
            if (!pending) {
                return;
            }
            pending.stream.write(result.data);
        };
        /*
         * Should be called by all implementers when the connection is closed by the other side (server).
         * This cleans up all the pending requests by rejecting them with a RpcConnectionLostError
         *
         * TODO: we should probably also have a cleanup function for when the client closes itself
         */
        this.handleClose = () => {
            for (const request of this.pending.values()) {
                request.reject(new errors_1.RpcConnectionLostError(request.type));
            }
            this.pending.clear();
            this.onClose.emit();
        };
        this.handleEnd = async (data) => {
            const { result, error } = await utils_1.YupUtils.tryValidate(adapters_1.SocketRpcResponseSchema, data);
            if (!result) {
                throw error;
            }
            const pending = this.pending.get(result.id);
            if (!pending) {
                return;
            }
            pending.response.status = result.status;
            if (response_1.isRpcResponseError(pending.response)) {
                const { result: errorBody, error: errorError } = await utils_1.YupUtils.tryValidate(adapters_1.SocketRpcErrorSchema, result.data);
                if (errorBody) {
                    pending.reject(new errors_1.RpcRequestError(pending.response, errorBody.code, errorBody.message, errorBody.stack));
                }
                else if (errorError) {
                    pending.reject(errorError);
                }
                else {
                    pending.reject(data);
                }
                return;
            }
            pending.resolve(result.data);
        };
        this.onClientData = (data) => void this.onData(data).catch((e) => this.onError(e));
        this.onData = async (data) => {
            this.messageBuffer.write(data);
            for (const message of this.messageBuffer.readMessages()) {
                const { result, error } = await utils_1.YupUtils.tryValidate(adapters_1.ServerSocketRpcSchema, JSON.parse(message));
                if (!result) {
                    throw error;
                }
                const { type, data } = result;
                switch (type) {
                    case 'message': {
                        this.onMessage(data);
                        break;
                    }
                    case 'stream': {
                        this.onStream(data);
                        break;
                    }
                    case 'error':
                    case 'malformedRequest': {
                        this.onError(data);
                        break;
                    }
                }
            }
        };
        this.onClientClose = () => {
            this.isConnected = false;
            this.messageBuffer.clear();
            if (this.client) {
                this.client.off('data', this.onClientData);
                this.client.off('close', this.onClientClose);
                this.client = null;
            }
            for (const request of this.pending.values()) {
                request.reject(new errors_1.RpcConnectionLostError(request.type));
            }
            this.pending.clear();
            this.onClose.emit();
        };
        this.onMessage = (data) => {
            this.handleEnd(data).catch((e) => this.onError(e));
        };
        this.onStream = (data) => {
            this.handleStream(data).catch((e) => this.onError(e));
        };
        this.connectTo = connectTo;
        this.authToken = authToken ?? null;
        this.messageBuffer = new messageBuffer_1.MessageBuffer();
    }
    async connect() {
        return new Promise((resolve, reject) => {
            const onConnect = () => {
                client.off('connect', onConnect);
                client.off('error', onError);
                this.onConnect();
                resolve();
            };
            const onError = (error) => {
                client.off('connect', onConnect);
                client.off('error', onError);
                if (utils_1.ErrorUtils.isConnectRefusedError(error) || utils_1.ErrorUtils.isNoEntityError(error)) {
                    reject(new errors_1.RpcConnectionRefusedError());
                }
                else if (utils_1.ErrorUtils.isConnectTimeOutError(error) ||
                    utils_1.ErrorUtils.isConnectResetError(error)) {
                    reject(new errors_1.RpcConnectionLostError());
                }
                else {
                    reject(error);
                }
            };
            const options = this.connectTo.path !== undefined
                ? { path: this.connectTo.path }
                : this.connectTo.port !== undefined
                    ? { port: this.connectTo.port, host: this.connectTo.host }
                    : null;
            assert_1.Assert.isNotNull(options);
            if (process.platform === 'win32') {
                // Windows requires special socket paths. See this for more info:
                // https://nodejs.org/api/net.html#identifying-paths-for-ipc-connections
                if (options.path && !options.path.startsWith('\\\\.\\pipe\\')) {
                    options.path = options.path.replace(/^\//, '');
                    options.path = options.path.replace(/\//g, '-');
                    options.path = `\\\\.\\pipe\\${options.path}`;
                }
            }
            this.logger.debug(`Connecting to ${this.describe()}`);
            const client = net_1.default.connect(options);
            client.on('error', onError);
            client.on('connect', onConnect);
            this.client = client;
        });
    }
    close() {
        this.client?.destroy();
        this.messageBuffer.clear();
    }
    async tryConnect() {
        return this.connect()
            .then(() => true)
            .catch((e) => {
            if (e instanceof errors_1.RpcConnectionError) {
                return false;
            }
            throw e;
        });
    }
    request(route, data, options = {}) {
        assert_1.Assert.isNotNull(this.client, 'Connect first using connect()');
        const [promise, resolve, reject] = utils_1.PromiseUtils.split();
        const messageId = ++this.messageIds;
        const stream = new stream_1.Stream();
        const timeoutMs = options.timeoutMs === undefined ? this.timeoutMs : options.timeoutMs;
        let timeout = null;
        let response = null;
        if (timeoutMs !== null) {
            timeout = setTimeout(() => {
                const message = this.pending.get(messageId);
                if (message && response) {
                    message.reject(new errors_1.RequestTimeoutError(response, timeoutMs, route));
                }
            }, timeoutMs);
        }
        const resolveRequest = (...args) => {
            this.pending.delete(messageId);
            if (timeout) {
                clearTimeout(timeout);
            }
            stream.close();
            resolve(...args);
        };
        const rejectRequest = (...args) => {
            this.pending.delete(messageId);
            if (timeout) {
                clearTimeout(timeout);
            }
            stream.close(...args);
            reject(...args);
        };
        response = new response_1.RpcResponse(promise, stream, timeout);
        const pending = {
            resolve: resolveRequest,
            reject: rejectRequest,
            timeout: timeout,
            response: response,
            stream: stream,
            type: route,
        };
        this.pending.set(messageId, pending);
        this.send(messageId, route, data, this.authToken);
        return response;
    }
    send(messageId, route, data, authToken) {
        assert_1.Assert.isNotNull(this.client);
        const message = {
            type: 'message',
            data: {
                mid: messageId,
                type: route,
                auth: authToken,
                data: data,
            },
        };
        this.client.write(JSON.stringify(message) + adapters_1.MESSAGE_DELIMITER);
    }
    onConnect() {
        assert_1.Assert.isNotNull(this.client);
        this.isConnected = true;
        this.client.on('data', this.onClientData);
        this.client.on('close', this.onClientClose);
    }
    onError(error) {
        this.logger.error(utils_1.ErrorUtils.renderError(error));
    }
    describe() {
        if (this.connectTo.path !== undefined) {
            return `path: '${this.connectTo.path}'`;
        }
        if (this.connectTo.host !== undefined && this.connectTo.port !== undefined) {
            return `${this.connectTo.host}:${this.connectTo.port}`;
        }
        return 'invalid';
    }
}
exports.RpcSocketClient = RpcSocketClient;
//# sourceMappingURL=socketClient.js.map