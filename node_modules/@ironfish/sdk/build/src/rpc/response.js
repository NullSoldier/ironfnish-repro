"use strict";
/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/. */
Object.defineProperty(exports, "__esModule", { value: true });
exports.RpcResponse = exports.isRpcResponseUserError = exports.isRpcResponseServerError = exports.isRpcResponseError = void 0;
const clients_1 = require("./clients");
function isRpcResponseError(response) {
    return isRpcResponseUserError(response) || isRpcResponseServerError(response);
}
exports.isRpcResponseError = isRpcResponseError;
function isRpcResponseServerError(response) {
    return response.status >= 500 && response.status <= 599;
}
exports.isRpcResponseServerError = isRpcResponseServerError;
function isRpcResponseUserError(response) {
    return response.status >= 400 && response.status <= 499;
}
exports.isRpcResponseUserError = isRpcResponseUserError;
class RpcResponse {
    constructor(promise, stream, timeout) {
        this.status = 0;
        this.content = null;
        this.promise = promise;
        this.stream = stream;
        this.timeout = timeout;
    }
    async waitForEnd() {
        this.content = await this.promise;
        return this;
    }
    bufferSize() {
        return this.stream.buffer.length;
    }
    /*
     * Returns a generator of stream results. If a disconnect error occurs during
     * the streaming request it just causes the generator to end, the error is
     * not propagated
     */
    async *contentStream(ignoreClose = true) {
        this.promise.catch(() => {
            // In the streaming case the error is piped through the stream instead
            // and we handle it there (below). The same error is piped through this promise
            // but since we are already handling it in the stream we can ignore this one
        });
        if (this.timeout) {
            clearTimeout(this.timeout);
        }
        try {
            for await (const value of this.stream) {
                yield value;
            }
        }
        catch (e) {
            if (e instanceof clients_1.RpcConnectionLostError && ignoreClose) {
                return;
            }
            throw e;
        }
    }
}
exports.RpcResponse = RpcResponse;
//# sourceMappingURL=response.js.map