"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.serializeRpcWalletNote = exports.getAccountDecryptedNotes = exports.getTransactionNotes = exports.getAssetBalanceDeltas = exports.deserializeRpcAccountImport = exports.serializeRpcAccountTransaction = exports.getAccount = void 0;
/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/. */
const primitives_1 = require("../../../primitives");
const utils_1 = require("../../../utils");
const adapters_1 = require("../../adapters");
function getAccount(wallet, name) {
    if (name) {
        const account = wallet.getAccountByName(name);
        if (account) {
            return account;
        }
        throw new adapters_1.ValidationError(`No account with name ${name}`);
    }
    const defaultAccount = wallet.getDefaultAccount();
    if (defaultAccount) {
        return defaultAccount;
    }
    throw new adapters_1.ValidationError(`No account is currently active.\n\n` +
        `Use ironfish wallet:create <name> to first create an account`);
}
exports.getAccount = getAccount;
function serializeRpcAccountTransaction(transaction) {
    return {
        hash: transaction.transaction.hash().toString('hex'),
        fee: transaction.transaction.fee().toString(),
        blockHash: transaction.blockHash?.toString('hex'),
        blockSequence: transaction.sequence ?? undefined,
        notesCount: transaction.transaction.notes.length,
        spendsCount: transaction.transaction.spends.length,
        mintsCount: transaction.transaction.mints.length,
        burnsCount: transaction.transaction.burns.length,
        expiration: transaction.transaction.expiration(),
        timestamp: transaction.timestamp.getTime(),
        submittedSequence: transaction.submittedSequence,
    };
}
exports.serializeRpcAccountTransaction = serializeRpcAccountTransaction;
function deserializeRpcAccountImport(accountImport) {
    return {
        ...accountImport,
        createdAt: accountImport.createdAt
            ? {
                hash: Buffer.from(accountImport.createdAt.hash, 'hex'),
                sequence: accountImport.createdAt.sequence,
            }
            : null,
    };
}
exports.deserializeRpcAccountImport = deserializeRpcAccountImport;
async function getAssetBalanceDeltas(account, transaction) {
    const assetBalanceDeltas = new Array();
    for (const [assetId, delta] of transaction.assetBalanceDeltas.entries()) {
        const asset = await account.getAsset(assetId);
        const assetName = asset?.name.toString('hex') ?? '';
        assetBalanceDeltas.push({
            assetId: assetId.toString('hex'),
            assetName,
            delta: delta.toString(),
        });
    }
    return assetBalanceDeltas;
}
exports.getAssetBalanceDeltas = getAssetBalanceDeltas;
async function getTransactionNotes(workerPool, account, transaction) {
    const notes = [];
    const decryptNotesPayloads = [];
    let accountHasSpend = false;
    for (const spend of transaction.transaction.spends) {
        const noteHash = await account.getNoteHash(spend.nullifier);
        if (noteHash !== undefined) {
            accountHasSpend = true;
            break;
        }
    }
    for (const note of transaction.transaction.notes) {
        const decryptedNote = await account.getDecryptedNote(note.hash());
        if (decryptedNote) {
            notes.push(decryptedNote);
            continue;
        }
        decryptNotesPayloads.push({
            serializedNote: note.serialize(),
            incomingViewKey: account.incomingViewKey,
            outgoingViewKey: account.outgoingViewKey,
            viewKey: account.viewKey,
            currentNoteIndex: null,
            decryptForSpender: true,
        });
    }
    if (accountHasSpend && decryptNotesPayloads.length > 0) {
        const decryptedSends = await workerPool.decryptNotes(decryptNotesPayloads);
        for (const note of decryptedSends) {
            if (note === null) {
                continue;
            }
            notes.push({
                accountId: '',
                note: new primitives_1.Note(note.serializedNote),
                index: null,
                nullifier: null,
                transactionHash: transaction.transaction.hash(),
                spent: false,
                blockHash: transaction.blockHash,
                sequence: transaction.sequence,
            });
        }
    }
    return notes;
}
exports.getTransactionNotes = getTransactionNotes;
async function getAccountDecryptedNotes(workerPool, account, transaction) {
    const notes = await getTransactionNotes(workerPool, account, transaction);
    const serializedNotes = [];
    for await (const decryptedNote of notes) {
        const asset = await account.getAsset(decryptedNote.note.assetId());
        serializedNotes.push(serializeRpcWalletNote(decryptedNote, account.publicAddress, asset));
    }
    return serializedNotes;
}
exports.getAccountDecryptedNotes = getAccountDecryptedNotes;
function serializeRpcWalletNote(note, publicAddress, asset) {
    return {
        value: utils_1.CurrencyUtils.encode(note.note.value()),
        assetId: note.note.assetId().toString('hex'),
        assetName: asset?.name.toString('hex') || '',
        memo: note.note.memo(),
        owner: note.note.owner(),
        sender: note.note.sender(),
        noteHash: note.note.hash().toString('hex'),
        transactionHash: note.transactionHash.toString('hex'),
        index: note.index,
        nullifier: note.nullifier?.toString('hex') ?? null,
        spent: note.spent,
        isOwner: note.note.owner() === publicAddress,
        hash: note.note.hash().toString('hex'),
    };
}
exports.serializeRpcWalletNote = serializeRpcWalletNote;
//# sourceMappingURL=utils.js.map