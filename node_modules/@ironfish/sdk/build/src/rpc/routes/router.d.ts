import { IronfishNode, YupSchema, YupSchemaResult } from '../../utils';
import { ResponseError } from '../adapters/errors';
import { RpcRequest } from '../request';
import { RpcServer } from '../server';
export declare enum ApiNamespace {
    chain = "chain",
    config = "config",
    event = "event",
    faucet = "faucet",
    miner = "miner",
    node = "node",
    peer = "peer",
    wallet = "wallet",
    worker = "worker",
    rpc = "rpc",
    mempool = "mempool"
}
export declare const ALL_API_NAMESPACES: import("../../utils").StrEnumValue<typeof ApiNamespace>[];
export declare type RequestContext = IronfishNode;
export declare type RouteHandler<TRequest = unknown, TResponse = unknown> = (request: RpcRequest<TRequest, TResponse>, context: RequestContext) => Promise<void> | void;
export declare class RouteNotFoundError extends ResponseError {
    constructor(route: string, namespace: string, method: string);
}
export declare function parseRoute(route: string): [namespace: string | undefined, method: string | undefined];
export declare class Router {
    routes: Routes;
    server: RpcServer;
    constructor(routes: Routes, server: RpcServer);
    route(route: string, request: RpcRequest): Promise<void>;
}
declare class Routes {
    routes: Map<string, Map<string, {
        handler: RouteHandler;
        schema: YupSchema<unknown, unknown>;
    }>>;
    get(namespace: string, method: string): {
        handler: RouteHandler;
        schema: YupSchema;
    } | undefined;
    register<TRequestSchema extends YupSchema, TResponse>(route: string, requestSchema: TRequestSchema, handler: RouteHandler<YupSchemaResult<TRequestSchema>, TResponse>): void;
    filter(namespaces: string[]): Routes;
}
export declare const routes: Routes;
export {};
//# sourceMappingURL=router.d.ts.map