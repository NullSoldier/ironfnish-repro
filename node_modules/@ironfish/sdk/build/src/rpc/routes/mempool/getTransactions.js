"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.MempoolTransactionResponseSchema = exports.MempoolTransactionsRequestSchema = void 0;
/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/. */
const yup = __importStar(require("yup"));
const assert_1 = require("../../../assert");
const memPool_1 = require("../../../memPool");
const node_1 = require("../../../node");
const router_1 = require("../router");
const minMaxSchema = yup.object({
    min: yup.number().optional().min(0),
    max: yup.number().optional(),
});
exports.MempoolTransactionsRequestSchema = yup
    .object({
    limit: yup.number().min(0),
    feeRate: minMaxSchema.optional(),
    fee: minMaxSchema.optional(),
    expiration: minMaxSchema.optional(),
    position: minMaxSchema.optional(),
    expiresIn: minMaxSchema.optional(),
    stream: yup.boolean().optional(),
})
    .required()
    .defined();
exports.MempoolTransactionResponseSchema = yup
    .object({
    serializedTransaction: yup.string().defined(),
    position: yup.number().defined(),
    expiresIn: yup.number().defined(),
})
    .defined();
router_1.routes.register(`${router_1.ApiNamespace.mempool}/getTransactions`, exports.MempoolTransactionsRequestSchema, (request, node) => {
    assert_1.Assert.isInstanceOf(node, node_1.FullNode);
    let position = 0;
    let streamed = 0;
    const headSequence = node.chain.head.sequence;
    for (const transaction of node.memPool.orderedTransactions()) {
        const overPosition = request.data?.position?.max !== undefined && position > request.data.position.max;
        const underFeeRate = request.data?.feeRate?.min !== undefined &&
            memPool_1.getFeeRate(transaction) < request.data.feeRate.min;
        const overLimit = request.data?.limit !== undefined && streamed >= request.data.limit;
        // If there are no more viable transactions to send we can just return early
        // This makes the assumption that memPool.orderedTransactions is ordered by feeRate
        if (overPosition || underFeeRate || overLimit) {
            break;
        }
        const expiresIn = transaction.expiration() === 0 ? 0 : transaction.expiration() - headSequence;
        if (includeTransaction(transaction, position, expiresIn, request.data)) {
            request.stream({
                serializedTransaction: transaction.serialize().toString('hex'),
                position,
                expiresIn,
            });
            streamed++;
        }
        position++;
    }
    request.end();
});
function includeTransaction(transaction, position, expiresIn, request) {
    return ((request.position?.max === undefined || position <= request.position.max) &&
        (request.position?.min === undefined || position >= request.position.min) &&
        (request.fee?.max === undefined || transaction.fee() <= BigInt(request.fee.max)) &&
        (request.fee?.min === undefined || transaction.fee() >= BigInt(request.fee.min)) &&
        (request.feeRate?.max === undefined ||
            memPool_1.getFeeRate(transaction) <= BigInt(request.feeRate.max)) &&
        (request.feeRate?.min === undefined ||
            memPool_1.getFeeRate(transaction) >= BigInt(request.feeRate.min)) &&
        (request.expiration?.max === undefined ||
            transaction.expiration() <= request.expiration.max) &&
        (request.expiration?.min === undefined ||
            transaction.expiration() >= request.expiration.min) &&
        (request.expiresIn?.max === undefined || expiresIn <= request.expiresIn.max) &&
        (request.expiresIn?.min === undefined || expiresIn >= request.expiresIn.min));
}
//# sourceMappingURL=getTransactions.js.map