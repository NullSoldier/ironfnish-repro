"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.routes = exports.Router = exports.parseRoute = exports.RouteNotFoundError = exports.ALL_API_NAMESPACES = exports.ApiNamespace = void 0;
/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/. */
const assert_1 = require("../../assert");
const utils_1 = require("../../utils");
const enums_1 = require("../../utils/enums");
const adapters_1 = require("../adapters");
const errors_1 = require("../adapters/errors");
var ApiNamespace;
(function (ApiNamespace) {
    ApiNamespace["chain"] = "chain";
    ApiNamespace["config"] = "config";
    ApiNamespace["event"] = "event";
    ApiNamespace["faucet"] = "faucet";
    ApiNamespace["miner"] = "miner";
    ApiNamespace["node"] = "node";
    ApiNamespace["peer"] = "peer";
    ApiNamespace["wallet"] = "wallet";
    ApiNamespace["worker"] = "worker";
    ApiNamespace["rpc"] = "rpc";
    ApiNamespace["mempool"] = "mempool";
})(ApiNamespace = exports.ApiNamespace || (exports.ApiNamespace = {}));
exports.ALL_API_NAMESPACES = enums_1.StrEnumUtils.getValues(ApiNamespace);
class RouteNotFoundError extends errors_1.ResponseError {
    constructor(route, namespace, method) {
        super(`No route found ${route} in namespace ${namespace} for method ${method}`, adapters_1.ERROR_CODES.ROUTE_NOT_FOUND, 404);
    }
}
exports.RouteNotFoundError = RouteNotFoundError;
function parseRoute(route) {
    const [n, m] = route.split('/');
    return [n, m];
}
exports.parseRoute = parseRoute;
class Router {
    constructor(routes, server) {
        this.routes = new Routes();
        this.routes = routes;
        this.server = server;
    }
    async route(route, request) {
        const [namespace, method] = route.split('/');
        const methodRoute = this.routes.get(namespace, method);
        if (!methodRoute) {
            throw new RouteNotFoundError(route, namespace, method);
        }
        const { handler, schema } = methodRoute;
        const { result, error } = await utils_1.YupUtils.tryValidate(schema, request.data);
        if (error) {
            throw new errors_1.ValidationError(error.message, 400);
        }
        request.data = result;
        try {
            await handler(request, this.server.context);
        }
        catch (e) {
            if (e instanceof errors_1.ResponseError) {
                throw e;
            }
            if (e instanceof Error) {
                throw new errors_1.ResponseError(e);
            }
            throw e;
        }
    }
}
exports.Router = Router;
class Routes {
    constructor() {
        this.routes = new Map();
    }
    get(namespace, method) {
        const namespaceRoutes = this.routes.get(namespace);
        if (!namespaceRoutes) {
            return undefined;
        }
        return namespaceRoutes.get(method);
    }
    register(route, requestSchema, handler) {
        const [namespace, method] = parseRoute(route);
        assert_1.Assert.isNotUndefined(namespace, `Invalid namespace: ${String(namespace)}: ${route}`);
        assert_1.Assert.isNotUndefined(method, `Invalid method: ${String(namespace)}: ${route}`);
        let namespaceRoutes = this.routes.get(namespace);
        if (!namespaceRoutes) {
            namespaceRoutes = new Map();
            this.routes.set(namespace, namespaceRoutes);
        }
        namespaceRoutes.set(method, {
            handler: handler,
            schema: requestSchema,
        });
    }
    filter(namespaces) {
        const set = new Set(namespaces);
        const copy = new Routes();
        for (const [key, value] of this.routes) {
            if (set.has(key)) {
                copy.routes.set(key, value);
            }
        }
        return copy;
    }
}
exports.routes = new Routes();
//# sourceMappingURL=router.js.map