"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.renderGraph = exports.renderChain = exports.logChain = void 0;
/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/. */
const buffer_map_1 = require("buffer-map");
const assert_1 = require("../../../assert");
const logger_1 = require("../../../logger");
const utils_1 = require("../../../utils");
const DEFAULT_OPTIONS = {
    seq: true,
    work: true,
    indent: '|',
};
async function logChain(chain, start, end, options = DEFAULT_OPTIONS, logger) {
    const content = await renderChain(chain, start, end, options, logger);
    if (logger) {
        logger.info(content.join('\n'));
    }
    else {
        // eslint-disable-next-line no-console
        console.log(content.join('\n'));
    }
}
exports.logChain = logChain;
async function renderChain(chain, start, stop, options = DEFAULT_OPTIONS, logger = logger_1.createRootLogger()) {
    const content = [];
    let trees = { valid: true };
    if (chain.head) {
        const headBlock = await chain.getBlock(chain.head);
        assert_1.Assert.isNotNull(headBlock);
        trees = await chain.verifier.verifyConnectedBlock(headBlock);
    }
    content.push('======', `GENESIS: ${chain.genesis.hash.toString('hex') || '-'}`, `HEAD:    ${chain.head.hash.toString('hex') || '-'}`, `LATEST:  ${chain.latest.hash.toString('hex') || '-'}`, `TREES:   ${trees.valid ? 'OK' : `ERROR: ${String(trees.reason)}`}`, '======');
    const { start: startHeight, stop: stopHeight } = utils_1.BlockchainUtils.getBlockRange(chain, {
        start,
        stop,
    });
    const roots = await chain.getHeadersAtSequence(startHeight);
    for (const root of roots) {
        await renderGraph(chain, root, stopHeight, content, options, logger);
    }
    return content;
}
exports.renderChain = renderChain;
async function renderGraph(chain, header, end, content, options = DEFAULT_OPTIONS, logger = logger_1.createRootLogger(), last = true, _only = true, indent = '', seen = new buffer_map_1.BufferSet()) {
    assert_1.Assert.isNotNull(chain.latest);
    assert_1.Assert.isNotNull(chain.head);
    assert_1.Assert.isNotNull(chain.genesis);
    seen.add(header.hash);
    let rendered = `+- Block ${utils_1.HashUtils.renderHash(header.hash)}`;
    if (options.seq) {
        rendered += ` (${header.sequence})`;
    }
    if (options.prev) {
        rendered += ` prev: ${utils_1.HashUtils.renderHash(header.previousBlockHash)}`;
    }
    if (options.work) {
        rendered += ` work: ${header.work.toString()}`;
    }
    if (header.hash.equals(chain.latest.hash)) {
        rendered += ' LATEST';
    }
    if (header.hash.equals(chain.head.hash)) {
        rendered += ' HEAD';
    }
    if (header.hash.equals(chain.genesis.hash)) {
        rendered += ' GENESIS';
    }
    content.push(indent + rendered);
    if (header.sequence === end) {
        return;
    }
    const next = await chain.getHeadersAtSequence(header.sequence + 1);
    const children = next.filter((h) => h.previousBlockHash.equals(header.hash));
    const nesting = children.length >= 2;
    const indentation = nesting ? options.indent || '' : '';
    indent += last ? indentation : `| ${indentation}`;
    for (let i = 0; i < children.length; i++) {
        const child = children[i];
        if (seen.has(child.hash)) {
            logger.error(`ERROR FOUND LOOPING CHAIN ${header.hash.toString('hex')} -> ${child.hash.toString('hex')}`);
            return;
        }
        const last = i === children.length - 1;
        const only = children.length === 1;
        await renderGraph(chain, child, end, content, options, logger, last, only, indent, seen);
        if (!last) {
            content.push(indent + '');
        }
    }
}
exports.renderGraph = renderGraph;
//# sourceMappingURL=utils.js.map