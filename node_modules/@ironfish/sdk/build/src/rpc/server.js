"use strict";
/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/. */
Object.defineProperty(exports, "__esModule", { value: true });
exports.RpcServer = void 0;
const logger_1 = require("../logger");
const routes_1 = require("./routes");
class RpcServer {
    constructor(context, internal, logger = logger_1.createRootLogger()) {
        this.adapters = [];
        this._isRunning = false;
        this._startPromise = null;
        this.context = context;
        this.internal = internal;
        this.logger = logger.withTag('rpcserver');
    }
    get isRunning() {
        return this._isRunning;
    }
    /** Creates a new router from this RpcServer with the attached routes filtered by namespaces */
    getRouter(namespaces) {
        return new routes_1.Router(routes_1.routes.filter(namespaces), this);
    }
    /** Starts the RPC server and tells any attached adapters to starts serving requests to the routing layer */
    async start() {
        if (this._isRunning) {
            return;
        }
        const promises = this.adapters.map((a) => a.start());
        this._startPromise = Promise.all(promises);
        this._isRunning = true;
        await this._startPromise;
    }
    /** Stops the RPC server and tells any attached adapters to stop serving requests to the routing layer */
    async stop() {
        if (!this._isRunning) {
            return;
        }
        if (this._startPromise) {
            await this._startPromise;
        }
        const promises = this.adapters.map((a) => a.stop());
        await Promise.all(promises);
        this._isRunning = false;
    }
    /** Adds an adapter to the RPC server and starts it if the server has already been started */
    async mount(adapter) {
        this.adapters.push(adapter);
        await adapter.attach(this);
        if (this._isRunning) {
            let promise = adapter.start();
            if (this._startPromise) {
                // Attach this promise to the start promise chain
                // in case we call stop while were still starting up
                promise = Promise.all([this._startPromise, promise]);
            }
            this._startPromise = promise;
        }
    }
    /** Authenticate the RPC request */
    authenticate(requestAuthToken) {
        if (!requestAuthToken) {
            this.logger.debug(`Missing Auth token in RPC request.`);
            return false;
        }
        const rpcAuthToken = this.internal.get('rpcAuthToken');
        if (!rpcAuthToken) {
            this.logger.debug(`Missing RPC Auth token in internal.json config.`);
            return false;
        }
        return requestAuthToken === rpcAuthToken;
    }
}
exports.RpcServer = RpcServer;
//# sourceMappingURL=server.js.map