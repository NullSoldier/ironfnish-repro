"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.RpcSocketAdapter = void 0;
/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/. */
const promises_1 = __importDefault(require("fs/promises"));
const net_1 = __importDefault(require("net"));
const uuid_1 = require("uuid");
const logger_1 = require("../../../logger");
const meter_1 = require("../../../metrics/meter");
const utils_1 = require("../../../utils");
const error_1 = require("../../../utils/error");
const yup_1 = require("../../../utils/yup");
const messageBuffer_1 = require("../../messageBuffer");
const request_1 = require("../../request");
const errors_1 = require("../errors");
const protocol_1 = require("./protocol");
class RpcSocketAdapter {
    constructor(listen, logger = logger_1.createRootLogger(), namespaces) {
        this.server = null;
        this.router = null;
        this.enableAuthentication = true;
        this.started = false;
        this.clients = new Map();
        this.inboundTraffic = new meter_1.Meter();
        this.outboundTraffic = new meter_1.Meter();
        this.listen = listen;
        this.logger = logger.withTag('tcpadapter');
        this.namespaces = namespaces;
    }
    get addressPort() {
        const address = this.server?.address();
        if (!address) {
            return null;
        }
        if (typeof address === 'string') {
            throw new Error('No unix sockets');
        }
        return address.port;
    }
    createServer() {
        return net_1.default.createServer((socket) => this.onClientConnection(socket));
    }
    async start() {
        if (this.started) {
            return;
        }
        this.started = true;
        const server = await this.createServer();
        this.server = server;
        this.inboundTraffic.start();
        this.outboundTraffic.start();
        if (this.listen.path) {
            await promises_1.default.unlink(this.listen.path).catch(() => {
                // Unlink the IPC socket if it exists, but we don't care if it doesn't
            });
            if (process.platform === 'win32') {
                // Windows requires special socket paths. See this for more info:
                // https://nodejs.org/api/net.html#identifying-paths-for-ipc-connections
                if (this.listen.path && !this.listen.path.startsWith('\\\\.\\pipe\\')) {
                    this.listen.path = this.listen.path.replace(/^\//, '');
                    this.listen.path = this.listen.path.replace(/\//g, '-');
                    this.listen.path = `\\\\.\\pipe\\${this.listen.path}`;
                }
            }
            this.listen.readableAll = false;
            this.listen.writableAll = false;
        }
        return new Promise((resolve, reject) => {
            const onError = (err) => {
                server.off('error', onError);
                server.off('listening', onListening);
                reject(err);
            };
            const onListening = () => {
                server.off('error', onError);
                server.off('listening', onListening);
                resolve();
            };
            server.on('error', onError);
            server.on('listening', onListening);
            server.listen({
                ...this.listen,
                exclusive: true,
            });
        });
    }
    async stop() {
        if (!this.started) {
            return;
        }
        this.started = false;
        this.inboundTraffic.stop();
        this.outboundTraffic.stop();
        this.clients.forEach((client) => {
            client.requests.forEach((r) => r.close());
            client.socket.destroy();
            client.messageBuffer.clear();
        });
        await new Promise((resolve) => {
            this.server?.close(() => resolve());
        });
        await this.waitForAllToDisconnect();
        this.logger.debug(`SocketAdapter stopped: ${this.describe()}`);
    }
    attach(server) {
        this.router = server.getRouter(this.namespaces);
    }
    async waitForAllToDisconnect() {
        const clients = Array.from(this.clients.values());
        await Promise.all(clients.map((c) => this.waitForClientToDisconnect(c)));
    }
    waitForClientToDisconnect(client) {
        return new Promise((resolve) => {
            client.socket.once('close', () => {
                resolve();
            });
        });
    }
    onClientConnection(socket) {
        const requests = new Map();
        const client = { socket, requests, id: uuid_1.v4(), messageBuffer: new messageBuffer_1.MessageBuffer() };
        this.clients.set(client.id, client);
        socket.on('data', (data) => {
            this.onClientData(client, data).catch((e) => {
                this.onClientError(client, e);
            });
        });
        socket.on('close', () => {
            this.onClientDisconnection(client);
        });
        socket.on('error', (error) => {
            this.onClientError(client, error);
        });
    }
    onClientDisconnection(client) {
        client.requests.forEach((req) => req.close());
        this.clients.delete(client.id);
        this.logger.debug(`client connection closed: ${this.describe()}`);
    }
    onClientError(client, error) {
        this.logger.debug(`${this.describe()} has error: ${error_1.ErrorUtils.renderError(error)}`);
    }
    async onClientData(client, data) {
        this.inboundTraffic.add(data.byteLength);
        client.messageBuffer.write(data);
        for (const rpcMessage of client.messageBuffer.readMessages()) {
            const [parsed, error] = utils_1.JSONUtils.tryParse(rpcMessage);
            if (error) {
                this.emitResponse(client, this.constructMalformedRequest(data));
                return;
            }
            const result = await yup_1.YupUtils.tryValidate(protocol_1.ClientSocketRpcSchema, parsed);
            if (result.error) {
                this.emitResponse(client, this.constructMalformedRequest(parsed));
                return;
            }
            const message = result.result.data;
            const requestId = uuid_1.v4();
            const request = new request_1.RpcRequest(message.data, message.type, (status, data) => {
                this.emitResponse(client, this.constructMessage(message.mid, status, data), requestId);
            }, (data) => {
                this.emitStream(client, this.constructStream(message.mid, data));
            });
            client.requests.set(requestId, request);
            try {
                if (this.router == null || this.router.server == null) {
                    throw new errors_1.ResponseError('Tried to connect to unmounted adapter');
                }
                // Authentication
                if (this.enableAuthentication) {
                    const isAuthenticated = this.router.server.authenticate(message.auth);
                    if (!isAuthenticated) {
                        const error = message.auth
                            ? 'Failed authentication'
                            : 'Missing authentication token';
                        throw new errors_1.ResponseError(error, errors_1.ERROR_CODES.UNAUTHENTICATED, 401);
                    }
                }
                await this.router.route(message.type, request);
            }
            catch (error) {
                if (error instanceof errors_1.ResponseError) {
                    const response = this.constructMessage(message.mid, error.status, {
                        code: error.code,
                        message: error.message,
                        stack: error.stack,
                    });
                    this.emitResponse(client, response, requestId);
                    return;
                }
                throw error;
            }
        }
    }
    emitResponse(client, data, requestId) {
        const message = this.encodeMessage(data);
        client.socket.write(message);
        this.outboundTraffic.add(message.byteLength);
        if (requestId) {
            client.requests.get(requestId)?.close();
            client.requests.delete(requestId);
        }
    }
    emitStream(client, data) {
        const message = this.encodeMessage(data);
        client.socket.write(message);
        this.outboundTraffic.add(message.byteLength);
    }
    encodeMessage(data) {
        return Buffer.from(JSON.stringify(data) + protocol_1.MESSAGE_DELIMITER);
    }
    constructMessage(messageId, status, data) {
        return {
            type: 'message',
            data: {
                id: messageId,
                status: status,
                data: data,
            },
        };
    }
    constructStream(messageId, data) {
        return {
            type: 'stream',
            data: {
                id: messageId,
                data: data,
            },
        };
    }
    constructMalformedRequest(request) {
        const error = new Error(`Malformed request rejected`);
        const data = {
            code: errors_1.ERROR_CODES.ERROR,
            message: error.message,
            stack: error.stack,
        };
        if (typeof request === 'object' &&
            request !== null &&
            'id' in request &&
            typeof request['id'] === 'number') {
            const id = request['id'];
            return this.constructMessage(id, 500, data);
        }
        return {
            type: 'malformedRequest',
            data: data,
        };
    }
    describe() {
        if (this.listen.path) {
            return this.listen.path;
        }
        if (this.listen.host && this.listen.port) {
            return `${this.listen.host}:${this.listen.port}`;
        }
        return 'invalid';
    }
}
exports.RpcSocketAdapter = RpcSocketAdapter;
//# sourceMappingURL=socketAdapter.js.map