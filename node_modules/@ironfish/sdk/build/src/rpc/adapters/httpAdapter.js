"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.RpcHttpAdapter = void 0;
/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/. */
const http_1 = __importDefault(require("http"));
const uuid_1 = require("uuid");
const assert_1 = require("../../assert");
const logger_1 = require("../../logger");
const metrics_1 = require("../../metrics");
const utils_1 = require("../../utils");
const request_1 = require("../request");
const errors_1 = require("./errors");
const socketAdapter_1 = require("./socketAdapter");
const MEGABYTES = 1000 * 1000;
const MAX_REQUEST_SIZE = 5 * MEGABYTES;
class RpcHttpAdapter {
    constructor(host, port, logger = logger_1.createRootLogger(), namespaces) {
        this.server = null;
        this.router = null;
        this.inboundTraffic = new metrics_1.Meter();
        this.outboundTraffic = new metrics_1.Meter();
        this.inboundBytes = new metrics_1.Gauge();
        this.outboundBytes = new metrics_1.Gauge();
        this.host = host;
        this.port = port;
        this.logger = logger;
        this.namespaces = namespaces;
        this.requests = new Map();
    }
    attach(server) {
        this.router = server.getRouter(this.namespaces);
    }
    start() {
        this.logger.debug(`Serving RPC on HTTP ${this.host}:${this.port}`);
        const server = http_1.default.createServer();
        this.server = server;
        this.inboundTraffic.start();
        this.outboundTraffic.start();
        return new Promise((resolve, reject) => {
            const onError = (err) => {
                server.off('error', onError);
                server.off('listening', onListening);
                reject(err);
            };
            const onListening = () => {
                server.off('error', onError);
                server.off('listening', onListening);
                server.on('request', (req, res) => {
                    const requestId = uuid_1.v4();
                    const waitForClose = new Promise((resolve) => {
                        res.on('close', () => {
                            this.cleanUpRequest(requestId);
                            resolve();
                        });
                    });
                    this.requests.set(requestId, { req, waitForClose });
                    // All response bodies should be application/json
                    res.setHeader('Content-Type', 'application/json');
                    void this.handleRequest(req, res, requestId).catch((e) => {
                        const error = utils_1.ErrorUtils.renderError(e);
                        this.logger.debug(`Error in HTTP adapter: ${error}`);
                        let errorResponse = {
                            code: errors_1.ERROR_CODES.ERROR,
                            status: 500,
                            message: error,
                        };
                        if (e instanceof errors_1.ResponseError) {
                            errorResponse = {
                                code: e.code,
                                status: e.status,
                                message: e.message,
                                stack: e.stack,
                            };
                        }
                        res.writeHead(errorResponse.status);
                        res.end(JSON.stringify(errorResponse));
                        this.cleanUpRequest(requestId);
                    });
                });
                resolve();
            };
            server.on('error', onError);
            server.on('listening', onListening);
            server.listen(this.port, this.host);
        });
    }
    async stop() {
        for (const { req, rpcRequest } of this.requests.values()) {
            req.destroy();
            rpcRequest?.close();
        }
        this.inboundTraffic.stop();
        this.outboundTraffic.stop();
        await new Promise((resolve) => {
            this.server?.close(() => resolve()) || resolve();
        });
        await Promise.all(Array.from(this.requests.values()).map(({ waitForClose }) => waitForClose));
    }
    cleanUpRequest(requestId) {
        const request = this.requests.get(requestId);
        // TODO: request.req was is already closed at this point
        // but do we need to clean that up here at all
        request?.rpcRequest?.close();
        this.requests.delete(requestId);
    }
    async handleRequest(request, response, requestId) {
        if (this.router === null || this.router.server === null) {
            throw new errors_1.ResponseError('Tried to connect to unmounted adapter');
        }
        const router = this.router;
        if (request.url === undefined) {
            throw new errors_1.ResponseError('No request url provided');
        }
        this.logger.debug(`Call HTTP RPC: ${request.method || 'undefined'} ${request.url || 'undefined'}`);
        const route = this.formatRoute(request);
        if (route === undefined) {
            throw new errors_1.ResponseError('No route found');
        }
        // TODO(daniel): clean up reading body code here a bit of possible
        let size = 0;
        const data = [];
        for await (const chunk of request) {
            assert_1.Assert.isInstanceOf(chunk, Buffer);
            size += chunk.byteLength;
            data.push(chunk);
            if (size >= MAX_REQUEST_SIZE) {
                throw new errors_1.ResponseError('Max request size exceeded');
            }
        }
        const combined = Buffer.concat(data);
        this.inboundTraffic.add(size);
        this.inboundBytes.value += size;
        // TODO(daniel): some routes assume that no data will be passed as undefined
        // so keeping that convention here. Could think of a better way to handle?
        const body = combined.length ? combined.toString('utf8') : undefined;
        let chunkStreamed = false;
        const rpcRequest = new request_1.RpcRequest(body === undefined ? undefined : JSON.parse(body), route, (status, data) => {
            response.statusCode = status;
            const delimeter = chunkStreamed ? socketAdapter_1.MESSAGE_DELIMITER : '';
            const responseData = JSON.stringify({ status, data });
            const responseSize = Buffer.byteLength(responseData, 'utf-8');
            this.outboundTraffic.add(responseSize);
            this.outboundBytes.value += responseSize;
            response.end(delimeter + responseData);
            this.cleanUpRequest(requestId);
        }, (data) => {
            // TODO: Most HTTP clients don't parse `Transfer-Encoding: chunked` by chunk
            // they wait until all chunks have been received and combine them. This will
            // stream a delimitated list of JSON objects but is still probably not
            // ideal as a response. We could find some better way to stream
            const delimeter = chunkStreamed ? socketAdapter_1.MESSAGE_DELIMITER : '';
            const responseData = JSON.stringify({ data });
            const responseSize = Buffer.byteLength(responseData, 'utf-8');
            this.outboundTraffic.add(responseSize);
            this.outboundBytes.value += responseSize;
            response.write(delimeter + responseData);
            chunkStreamed = true;
        });
        const currRequest = this.requests.get(requestId);
        currRequest && this.requests.set(requestId, { ...currRequest, rpcRequest });
        await router.route(route, rpcRequest);
    }
    // TODO(daniel): better way to parse method from request here
    formatRoute(request) {
        if (!request.url) {
            return;
        }
        const url = new URL(request.url, `http://${request.headers.host || 'localhost'}`);
        return url.pathname.substring(1);
    }
}
exports.RpcHttpAdapter = RpcHttpAdapter;
//# sourceMappingURL=httpAdapter.js.map