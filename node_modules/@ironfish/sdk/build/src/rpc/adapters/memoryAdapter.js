"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MemoryResponse = exports.RpcMemoryAdapter = void 0;
/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/. */
const assert_1 = require("../../assert");
const utils_1 = require("../../utils");
const errors_1 = require("../clients/errors");
const request_1 = require("../request");
const response_1 = require("../response");
const stream_1 = require("../stream");
const errors_2 = require("./errors");
/**
 * This class provides a way to route requests directly against the routing layer
 * return a response from the route
 *
 * This is useful any time you want to make requests without hitting an IO layer.
 */
class RpcMemoryAdapter {
    /**
     * Makes a request against the routing layer with a given route, and data and returns
     * a response for you to accumulate the streaming results, or wait for a response
     */
    static requestStream(router, route, data) {
        const [promise, resolve, reject] = utils_1.PromiseUtils.split();
        const stream = new stream_1.Stream();
        const response = new MemoryResponse(promise, stream, null);
        const request = new request_1.RpcRequest(data, route, (status, data) => {
            response.status = status;
            stream.close();
            resolve(data);
        }, (data) => {
            stream.write(data);
        });
        response.request = request;
        response.routePromise = router.route(route, request).catch((e) => {
            stream.close();
            if (e instanceof errors_2.ResponseError) {
                // Set the response status to the errors status because RequsetError takes it from the response
                response.status = e.status;
                const error = new errors_1.RpcRequestError(response, e.code, e.message, e.stack);
                // Do this so in memory requests retain the original stack and are easier to debug
                error.stack = error.codeStack ?? error.stack;
                reject(error);
            }
            else {
                reject(e);
            }
        });
        return response;
    }
}
exports.RpcMemoryAdapter = RpcMemoryAdapter;
class MemoryResponse extends response_1.RpcResponse {
    constructor(promise, stream, timeout) {
        super(promise, stream, timeout);
        this.request = null;
        this.routePromise = null;
    }
    close() {
        assert_1.Assert.isNotNull(this.request);
        this.request.close();
    }
    end(...args) {
        assert_1.Assert.isNotNull(this.request);
        return this.request.end(args);
    }
    async waitForRoute() {
        if (this.routePromise) {
            await this.routePromise;
        }
        return this;
    }
}
exports.MemoryResponse = MemoryResponse;
//# sourceMappingURL=memoryAdapter.js.map