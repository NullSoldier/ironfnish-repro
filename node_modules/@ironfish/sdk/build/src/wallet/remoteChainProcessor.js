"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.RemoteChainProcessor = void 0;
/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/. */
const assert_1 = require("../assert");
const event_1 = require("../event");
const primitives_1 = require("../primitives");
const utils_1 = require("../utils");
class RemoteChainProcessor {
    constructor(options) {
        this.hash = null;
        this.sequence = null;
        this.onAdd = new event_1.Event();
        this.onRemove = new event_1.Event();
        this.logger = options.logger;
        this.nodeClient = options.nodeClient;
        this.hash = options.head;
        this.maxQueueSize = options.maxQueueSize;
    }
    async update({ signal } = {}) {
        assert_1.Assert.isNotNull(this.nodeClient);
        const chainStream = this.nodeClient.chain.followChainStream({
            head: this.hash?.toString('hex') ?? null,
            serialized: true,
            wait: false,
            limit: this.maxQueueSize,
        });
        const oldHash = this.hash;
        for await (const content of chainStream.contentStream()) {
            if (signal?.aborted) {
                return { hashChanged: !utils_1.BufferUtils.equalsNullable(this.hash, oldHash) };
            }
            const { type, block } = content;
            if (type === 'fork') {
                continue;
            }
            const blockHeader = {
                hash: Buffer.from(block.hash, 'hex'),
                previousBlockHash: Buffer.from(block.previous, 'hex'),
                sequence: block.sequence,
                timestamp: new Date(block.timestamp),
            };
            const blockTransactions = this.getBlockTransactions(content);
            if (type === 'connected') {
                this.hash = blockHeader.hash;
                this.sequence = blockHeader.sequence;
                await this.onAdd.emitAsync({ header: blockHeader, transactions: blockTransactions });
            }
            else if (type === 'disconnected') {
                this.hash = blockHeader.previousBlockHash;
                this.sequence = blockHeader.sequence - 1;
                await this.onRemove.emitAsync({
                    header: blockHeader,
                    transactions: blockTransactions,
                });
            }
        }
        return { hashChanged: !utils_1.BufferUtils.equalsNullable(this.hash, oldHash) };
    }
    getBlockTransactions(response) {
        const transactions = [];
        assert_1.Assert.isNotNull(response.block.noteSize);
        let initialNoteIndex = response.block.noteSize;
        for (const rpcTransaction of response.block.transactions.slice().reverse()) {
            assert_1.Assert.isNotUndefined(rpcTransaction.serialized);
            const transaction = new primitives_1.Transaction(Buffer.from(rpcTransaction.serialized, 'hex'));
            initialNoteIndex -= transaction.notes.length;
            transactions.push({
                transaction,
                initialNoteIndex,
            });
        }
        return transactions.slice().reverse();
    }
}
exports.RemoteChainProcessor = RemoteChainProcessor;
//# sourceMappingURL=remoteChainProcessor.js.map