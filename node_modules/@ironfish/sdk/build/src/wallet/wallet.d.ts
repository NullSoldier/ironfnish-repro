/// <reference types="node" />
import { BufferSet } from 'buffer-map';
import { Consensus } from '../consensus';
import { Event } from '../event';
import { Config } from '../fileStores';
import { Logger } from '../logger';
import { Witness } from '../merkletree/witness';
import { BurnDescription } from '../primitives/burnDescription';
import { NoteEncrypted } from '../primitives/noteEncrypted';
import { MintData, RawTransaction } from '../primitives/rawTransaction';
import { Transaction } from '../primitives/transaction';
import { GetBlockRequest, GetBlockResponse, RpcClient } from '../rpc';
import { IDatabaseTransaction } from '../storage/database/transaction';
import { SetTimeoutToken } from '../utils';
import { WorkerPool } from '../workerPool';
import { DecryptedNote, DecryptNoteOptions } from '../workerPool/tasks/decryptNotes';
import { Account } from './account/account';
import { MintAssetOptions } from './interfaces/mintAssetOptions';
import { WalletBlockHeader, WalletBlockTransaction } from './remoteChainProcessor';
import { RemoteChainProcessor } from './remoteChainProcessor';
import { AccountValue } from './walletdb/accountValue';
import { AssetValue } from './walletdb/assetValue';
import { DecryptedNoteValue } from './walletdb/decryptedNoteValue';
import { HeadValue } from './walletdb/headValue';
import { TransactionValue } from './walletdb/transactionValue';
import { WalletDB } from './walletdb/walletdb';
export declare enum AssetStatus {
    CONFIRMED = "confirmed",
    PENDING = "pending",
    UNCONFIRMED = "unconfirmed",
    UNKNOWN = "unknown"
}
export declare enum TransactionStatus {
    CONFIRMED = "confirmed",
    EXPIRED = "expired",
    PENDING = "pending",
    UNCONFIRMED = "unconfirmed",
    UNKNOWN = "unknown"
}
export declare enum TransactionType {
    SEND = "send",
    RECEIVE = "receive",
    MINER = "miner"
}
export declare class Wallet {
    readonly onAccountImported: Event<[account: Account]>;
    readonly onAccountRemoved: Event<[account: Account]>;
    scan: ScanState | null;
    updateHeadState: ScanState | null;
    protected readonly accounts: Map<string, Account>;
    readonly walletDb: WalletDB;
    private readonly logger;
    readonly workerPool: WorkerPool;
    readonly chainProcessor: RemoteChainProcessor;
    readonly nodeClient: RpcClient | null;
    private readonly config;
    private readonly consensus;
    protected rebroadcastAfter: number;
    protected defaultAccount: string | null;
    protected isStarted: boolean;
    protected isOpen: boolean;
    protected isSyncingTransactionGossip: boolean;
    protected eventLoopTimeout: SetTimeoutToken | null;
    private readonly createTransactionMutex;
    private readonly eventLoopAbortController;
    private eventLoopPromise;
    private eventLoopResolve;
    constructor({ config, database, logger, rebroadcastAfter, workerPool, consensus, nodeClient, }: {
        config: Config;
        database: WalletDB;
        logger?: Logger;
        rebroadcastAfter?: number;
        workerPool: WorkerPool;
        consensus: Consensus;
        nodeClient: RpcClient | null;
    });
    updateHead(): Promise<void>;
    shouldRescan(): Promise<boolean>;
    open(): Promise<void>;
    private load;
    private unload;
    close(): Promise<void>;
    start(): Promise<void>;
    stop(): Promise<void>;
    eventLoop(): Promise<void>;
    syncTransactionGossip(): Promise<void>;
    reset(): Promise<void>;
    private resetAccounts;
    decryptNotes(transaction: Transaction, initialNoteIndex: number | null, decryptForSpender: boolean, accounts?: Array<Account>): Promise<Map<string, Array<DecryptedNote>>>;
    decryptNotesFromTransaction(decryptNotesPayloads: Array<DecryptNoteOptions>): Promise<Array<DecryptedNote>>;
    connectBlock(blockHeader: WalletBlockHeader, transactions: WalletBlockTransaction[], scan?: ScanState): Promise<void>;
    shouldDecryptForAccount(blockHeader: WalletBlockHeader, account: Account): Promise<boolean>;
    private connectBlockTransactions;
    private upsertAssetsFromDecryptedNotes;
    disconnectBlock(header: WalletBlockHeader, transactions: WalletBlockTransaction[]): Promise<void>;
    addPendingTransaction(transaction: Transaction): Promise<void>;
    scanTransactions(fromHash?: Buffer, force?: boolean): Promise<void>;
    getBalances(account: Account, confirmations?: number): AsyncGenerator<{
        assetId: Buffer;
        unconfirmed: bigint;
        unconfirmedCount: number;
        pending: bigint;
        pendingCount: number;
        confirmed: bigint;
        available: bigint;
        blockHash: Buffer | null;
        sequence: number | null;
    }>;
    getBalance(account: Account, assetId: Buffer, options?: {
        confirmations?: number;
    }): Promise<{
        unconfirmedCount: number;
        unconfirmed: bigint;
        confirmed: bigint;
        pendingCount: number;
        pending: bigint;
        available: bigint;
        blockHash: Buffer | null;
        sequence: number | null;
    }>;
    private getUnspentNotes;
    send(options: {
        account: Account;
        outputs: {
            publicAddress: string;
            amount: bigint;
            memo: string;
            assetId: Buffer;
        }[];
        fee?: bigint;
        feeRate?: bigint;
        expirationDelta?: number;
        expiration?: number;
        confirmations?: number;
    }): Promise<Transaction>;
    mint(account: Account, options: MintAssetOptions): Promise<Transaction>;
    burn(account: Account, assetId: Buffer, value: bigint, fee: bigint, expirationDelta: number, expiration?: number, confirmations?: number): Promise<Transaction>;
    createTransaction(options: {
        account: Account;
        notes?: Buffer[];
        outputs?: {
            publicAddress: string;
            amount: bigint;
            memo: string;
            assetId: Buffer;
        }[];
        mints?: MintData[];
        burns?: BurnDescription[];
        fee?: bigint;
        feeRate?: bigint;
        expiration?: number;
        expirationDelta?: number;
        confirmations?: number;
    }): Promise<RawTransaction>;
    post(options: {
        transaction: RawTransaction;
        spendingKey?: string;
        account?: Account;
        broadcast?: boolean;
    }): Promise<{
        transaction: Transaction;
        accepted?: boolean;
        broadcasted?: boolean;
    }>;
    fund(raw: RawTransaction, options: {
        account: Account;
        notes?: Buffer[];
        confirmations: number;
    }): Promise<void>;
    getNoteWitness(note: DecryptedNoteValue, confirmations?: number): Promise<Witness<NoteEncrypted, Buffer, Buffer, Buffer>>;
    private buildAmountsNeeded;
    addSpendsForAsset(raw: RawTransaction, sender: Account, assetId: Buffer, amountNeeded: bigint, amountSpent: bigint, notesSpent: BufferSet, confirmations: number): Promise<bigint>;
    broadcastTransaction(transaction: Transaction): Promise<{
        accepted: boolean;
        broadcasted: boolean;
    }>;
    rebroadcastTransactions(sequence: number): Promise<void>;
    expireTransactions(sequence: number): Promise<void>;
    getTransactionStatus(account: Account, transaction: TransactionValue, options?: {
        headSequence?: number | null;
        confirmations?: number;
    }, tx?: IDatabaseTransaction): Promise<TransactionStatus>;
    getAssetStatus(account: Account, assetValue: AssetValue, options?: {
        headSequence?: number | null;
        confirmations?: number;
    }): Promise<AssetStatus>;
    getTransactionType(account: Account, transaction: TransactionValue, tx?: IDatabaseTransaction): Promise<TransactionType>;
    createAccount(name: string, options?: {
        setCreatedAt?: boolean;
        setDefault?: boolean;
    }): Promise<Account>;
    skipRescan(account: Account, tx?: IDatabaseTransaction): Promise<void>;
    importAccount(accountValue: AccountValue): Promise<Account>;
    listAccounts(): Account[];
    accountExists(name: string): boolean;
    resetAccount(account: Account, options?: {
        resetCreatedAt?: boolean;
        tx?: IDatabaseTransaction;
    }): Promise<void>;
    removeAccountByName(name: string): Promise<void>;
    removeAccount(account: Account, tx?: IDatabaseTransaction): Promise<void>;
    forceCleanupDeletedAccounts(): Promise<void>;
    cleanupDeletedAccounts(): Promise<void>;
    get hasDefaultAccount(): boolean;
    /** Set or clear the default account */
    setDefaultAccount(name: string | null, tx?: IDatabaseTransaction): Promise<void>;
    getAccountByName(name: string): Account | null;
    getAccount(id: string): Account | null;
    getDefaultAccount(): Account | null;
    getEarliestHeadHash(): Promise<Buffer | null>;
    getLatestHead(): Promise<HeadValue | null>;
    getLatestHeadHash(): Promise<Buffer | null>;
    isAccountUpToDate(account: Account): Promise<boolean>;
    protected assertHasAccount(account: Account): void;
    protected assertNotHasAccount(account: Account): void;
    chainHasBlock(hash: Buffer): Promise<boolean>;
    chainGetBlock(request: GetBlockRequest): Promise<GetBlockResponse | null>;
    private getChainAsset;
    private getChainHead;
}
export declare class ScanState {
    onTransaction: Event<[sequence: number, endSequence: number]>;
    sequence: number;
    endSequence: number;
    readonly startedAt: number;
    readonly abortController: AbortController;
    private runningPromise;
    private runningResolve;
    constructor();
    get isAborted(): boolean;
    signal(sequence: number): void;
    signalComplete(): void;
    abort(): Promise<void>;
    wait(): Promise<void>;
}
//# sourceMappingURL=wallet.d.ts.map