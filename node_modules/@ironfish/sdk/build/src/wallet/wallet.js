"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ScanState = exports.Wallet = exports.TransactionType = exports.TransactionStatus = exports.AssetStatus = void 0;
/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/. */
const rust_nodejs_1 = require("@ironfish/rust-nodejs");
const buffer_map_1 = require("buffer-map");
const uuid_1 = require("uuid");
const assert_1 = require("../assert");
const consensus_1 = require("../consensus");
const event_1 = require("../event");
const logger_1 = require("../logger");
const feeEstimator_1 = require("../memPool/feeEstimator");
const merkletree_1 = require("../merkletree");
const merkletree_2 = require("../merkletree/merkletree");
const witness_1 = require("../merkletree/witness");
const mutex_1 = require("../mutex");
const primitives_1 = require("../primitives");
const note_1 = require("../primitives/note");
const rawTransaction_1 = require("../primitives/rawTransaction");
const transaction_1 = require("../primitives/transaction");
const utils_1 = require("../utils");
const account_1 = require("./account/account");
const assetBalances_1 = require("./assetBalances");
const errors_1 = require("./errors");
const remoteChainProcessor_1 = require("./remoteChainProcessor");
const validator_1 = require("./validator");
var AssetStatus;
(function (AssetStatus) {
    AssetStatus["CONFIRMED"] = "confirmed";
    AssetStatus["PENDING"] = "pending";
    AssetStatus["UNCONFIRMED"] = "unconfirmed";
    AssetStatus["UNKNOWN"] = "unknown";
})(AssetStatus = exports.AssetStatus || (exports.AssetStatus = {}));
var TransactionStatus;
(function (TransactionStatus) {
    TransactionStatus["CONFIRMED"] = "confirmed";
    TransactionStatus["EXPIRED"] = "expired";
    TransactionStatus["PENDING"] = "pending";
    TransactionStatus["UNCONFIRMED"] = "unconfirmed";
    TransactionStatus["UNKNOWN"] = "unknown";
})(TransactionStatus = exports.TransactionStatus || (exports.TransactionStatus = {}));
var TransactionType;
(function (TransactionType) {
    TransactionType["SEND"] = "send";
    TransactionType["RECEIVE"] = "receive";
    TransactionType["MINER"] = "miner";
})(TransactionType = exports.TransactionType || (exports.TransactionType = {}));
class Wallet {
    constructor({ config, database, logger = logger_1.createRootLogger(), rebroadcastAfter, workerPool, consensus, nodeClient, }) {
        this.onAccountImported = new event_1.Event();
        this.onAccountRemoved = new event_1.Event();
        this.scan = null;
        this.updateHeadState = null;
        this.accounts = new Map();
        this.defaultAccount = null;
        this.isStarted = false;
        this.isOpen = false;
        this.isSyncingTransactionGossip = false;
        this.eventLoopTimeout = null;
        this.eventLoopPromise = null;
        this.eventLoopResolve = null;
        this.config = config;
        this.logger = logger.withTag('accounts');
        this.walletDb = database;
        this.workerPool = workerPool;
        this.consensus = consensus;
        this.nodeClient = nodeClient || null;
        this.rebroadcastAfter = rebroadcastAfter ?? 10;
        this.createTransactionMutex = new mutex_1.Mutex();
        this.eventLoopAbortController = new AbortController();
        this.chainProcessor = new remoteChainProcessor_1.RemoteChainProcessor({
            logger: this.logger,
            nodeClient: this.nodeClient,
            head: null,
            maxQueueSize: this.config.get('walletSyncingMaxQueueSize'),
        });
        this.chainProcessor.onAdd.on(async ({ header, transactions }) => {
            if (Number(header.sequence) % this.config.get('walletSyncingMaxQueueSize') === 0) {
                this.logger.info('Added block' +
                    ` seq: ${Number(header.sequence)},` +
                    ` hash: ${utils_1.HashUtils.renderHash(header.hash)}`);
            }
            await this.connectBlock(header, transactions);
            await this.expireTransactions(header.sequence);
            await this.rebroadcastTransactions(header.sequence);
        });
        this.chainProcessor.onRemove.on(async ({ header, transactions }) => {
            this.logger.debug(`AccountHead DEL: ${header.sequence} => ${Number(header.sequence) - 1}`);
            await this.disconnectBlock(header, transactions);
        });
    }
    async updateHead() {
        if (this.scan || this.updateHeadState || this.accounts.size === 0) {
            return;
        }
        // TODO: this isn't right, as the scan state doesn't get its sequence or
        // endSequence set properly
        const scan = new ScanState();
        this.updateHeadState = scan;
        try {
            let hashChanged = false;
            do {
                hashChanged = (await this.chainProcessor.update({ signal: scan.abortController.signal })).hashChanged;
                if (hashChanged) {
                    this.logger.debug(`Updated Accounts Head: ${String(this.chainProcessor.hash?.toString('hex'))}`);
                }
            } while (hashChanged);
        }
        finally {
            scan.signalComplete();
            this.updateHeadState = null;
        }
    }
    async shouldRescan() {
        if (this.scan) {
            return false;
        }
        for (const account of this.accounts.values()) {
            if (!(await this.isAccountUpToDate(account))) {
                return true;
            }
        }
        return false;
    }
    async open() {
        if (this.isOpen) {
            return;
        }
        this.isOpen = true;
        await this.walletDb.open();
        await this.load();
    }
    async load() {
        for await (const accountValue of this.walletDb.loadAccounts()) {
            const account = new account_1.Account({
                ...accountValue,
                walletDb: this.walletDb,
            });
            this.accounts.set(account.id, account);
        }
        const latestHead = await this.getLatestHead();
        if (latestHead) {
            this.chainProcessor.hash = latestHead.hash;
            this.chainProcessor.sequence = latestHead.sequence;
        }
        const meta = await this.walletDb.loadAccountsMeta();
        this.defaultAccount = meta.defaultAccountId;
    }
    unload() {
        this.accounts.clear();
        this.defaultAccount = null;
        this.chainProcessor.hash = null;
        this.chainProcessor.sequence = null;
    }
    async close() {
        if (!this.isOpen) {
            return;
        }
        this.isOpen = false;
        await this.walletDb.close();
        this.unload();
    }
    async start() {
        if (this.isStarted) {
            return;
        }
        this.isStarted = true;
        if (this.chainProcessor.hash) {
            const hasHeadBlock = await this.chainHasBlock(this.chainProcessor.hash);
            if (!hasHeadBlock) {
                throw new Error(`Wallet has scanned to block ${this.chainProcessor.hash.toString('hex')}, but node's chain does not contain that block. Unable to sync from node without rescan.`);
            }
        }
        const chainHead = await this.getChainHead();
        for (const account of this.listAccounts()) {
            if (account.createdAt === null) {
                continue;
            }
            if (account.createdAt.sequence > chainHead.sequence) {
                continue;
            }
            if (!(await this.chainHasBlock(account.createdAt.hash))) {
                this.logger.warn(`Account ${account.name} createdAt refers to a block that is not on the node's chain. Resetting to null.`);
                await account.updateCreatedAt(null);
            }
        }
        if (!this.scan && (await this.shouldRescan())) {
            void this.scanTransactions();
        }
        void this.eventLoop();
    }
    async stop() {
        if (!this.isStarted) {
            return;
        }
        this.isStarted = false;
        if (this.eventLoopTimeout) {
            clearTimeout(this.eventLoopTimeout);
        }
        await Promise.all([this.scan?.abort(), this.updateHeadState?.abort()]);
        this.eventLoopAbortController.abort();
        await this.eventLoopPromise;
    }
    async eventLoop() {
        if (!this.isStarted) {
            return;
        }
        const [promise, resolve] = utils_1.PromiseUtils.split();
        this.eventLoopPromise = promise;
        this.eventLoopResolve = resolve;
        await this.updateHead();
        void this.syncTransactionGossip();
        await this.cleanupDeletedAccounts();
        if (this.isStarted) {
            this.eventLoopTimeout = setTimeout(() => void this.eventLoop(), 1000);
        }
        resolve();
        this.eventLoopPromise = null;
        this.eventLoopResolve = null;
    }
    async syncTransactionGossip() {
        if (this.isSyncingTransactionGossip) {
            return;
        }
        try {
            assert_1.Assert.isNotNull(this.nodeClient);
            const response = this.nodeClient.event.onTransactionGossipStream();
            this.isSyncingTransactionGossip = true;
            for await (const content of response.contentStream()) {
                if (!content.valid) {
                    continue;
                }
                const transaction = new transaction_1.Transaction(Buffer.from(content.serializedTransaction, 'hex'));
                // Start dropping trasactions if we have too many to process
                if (response.bufferSize() > this.config.get('walletGossipTransactionsMaxQueueSize')) {
                    const hash = transaction.hash().toString('hex');
                    this.logger.info(`Too many gossiped transactions to process. Dropping transaction ${hash}`);
                    continue;
                }
                await this.addPendingTransaction(transaction);
            }
        }
        catch (e) {
            this.logger.error(`Error syncing transaction gossip: ${utils_1.ErrorUtils.renderError(e)}`);
        }
        finally {
            this.isSyncingTransactionGossip = false;
        }
    }
    async reset() {
        await this.resetAccounts();
        this.chainProcessor.hash = null;
    }
    async resetAccounts(tx) {
        for (const account of this.listAccounts()) {
            await this.resetAccount(account, { tx });
        }
    }
    async decryptNotes(transaction, initialNoteIndex, decryptForSpender, accounts) {
        const accountsToCheck = accounts ||
            (await utils_1.AsyncUtils.filter(this.listAccounts(), async (a) => await this.isAccountUpToDate(a)));
        const decryptedNotesByAccountId = new Map();
        const batchSize = 20;
        for (const account of accountsToCheck) {
            const decryptedNotes = [];
            let decryptNotesPayloads = [];
            let currentNoteIndex = initialNoteIndex;
            for (const note of transaction.notes) {
                decryptNotesPayloads.push({
                    serializedNote: note.serialize(),
                    incomingViewKey: account.incomingViewKey,
                    outgoingViewKey: account.outgoingViewKey,
                    viewKey: account.viewKey,
                    currentNoteIndex,
                    decryptForSpender,
                });
                if (currentNoteIndex) {
                    currentNoteIndex++;
                }
                if (decryptNotesPayloads.length >= batchSize) {
                    const decryptedNotesBatch = await this.decryptNotesFromTransaction(decryptNotesPayloads);
                    decryptedNotes.push(...decryptedNotesBatch);
                    decryptNotesPayloads = [];
                }
            }
            if (decryptNotesPayloads.length) {
                const decryptedNotesBatch = await this.decryptNotesFromTransaction(decryptNotesPayloads);
                decryptedNotes.push(...decryptedNotesBatch);
            }
            if (decryptedNotes.length) {
                decryptedNotesByAccountId.set(account.id, decryptedNotes);
            }
        }
        return decryptedNotesByAccountId;
    }
    async decryptNotesFromTransaction(decryptNotesPayloads) {
        const decryptedNotes = [];
        const response = await this.workerPool.decryptNotes(decryptNotesPayloads);
        for (const decryptedNote of response) {
            if (decryptedNote) {
                decryptedNotes.push(decryptedNote);
            }
        }
        return decryptedNotes;
    }
    async connectBlock(blockHeader, transactions, scan) {
        const accounts = await utils_1.AsyncUtils.filter(this.listAccounts(), async (account) => {
            const accountHead = await account.getHead();
            if (!accountHead) {
                return blockHeader.sequence === 1;
            }
            else {
                return utils_1.BufferUtils.equalsNullable(accountHead.hash, blockHeader.previousBlockHash);
            }
        });
        for (const account of accounts) {
            const shouldDecrypt = await this.shouldDecryptForAccount(blockHeader, account);
            if (scan && scan.isAborted) {
                scan.signalComplete();
                this.scan = null;
                return;
            }
            await this.walletDb.db.transaction(async (tx) => {
                let assetBalanceDeltas = new assetBalances_1.AssetBalances();
                if (shouldDecrypt) {
                    assetBalanceDeltas = await this.connectBlockTransactions(blockHeader, transactions, account, scan, tx);
                }
                await account.updateUnconfirmedBalances(assetBalanceDeltas, blockHeader.hash, blockHeader.sequence, tx);
                await account.updateHead({ hash: blockHeader.hash, sequence: blockHeader.sequence }, tx);
                const accountHasTransaction = assetBalanceDeltas.size > 0;
                if (account.createdAt === null && accountHasTransaction) {
                    await account.updateCreatedAt({ hash: blockHeader.hash, sequence: blockHeader.sequence }, tx);
                }
            });
        }
    }
    async shouldDecryptForAccount(blockHeader, account) {
        if (account.createdAt === null) {
            return true;
        }
        if (account.createdAt.sequence > blockHeader.sequence) {
            return false;
        }
        if (account.createdAt.sequence === blockHeader.sequence &&
            !account.createdAt.hash.equals(blockHeader.hash)) {
            this.logger.warn(`Account ${account.name} createdAt refers to a block that is not on the node's chain. Stopping scan for this account.`);
            await account.updateCreatedAt(null);
            // Sets head to null to avoid connecting blocks for this account
            await account.updateHead(null);
            return false;
        }
        return true;
    }
    async connectBlockTransactions(blockHeader, transactions, account, scan, tx) {
        const assetBalanceDeltas = new assetBalances_1.AssetBalances();
        for (const { transaction, initialNoteIndex } of transactions) {
            if (scan && scan.isAborted) {
                return assetBalanceDeltas;
            }
            const decryptedNotesByAccountId = await this.decryptNotes(transaction, initialNoteIndex, false, [account]);
            const decryptedNotes = decryptedNotesByAccountId.get(account.id) ?? [];
            const transactionDeltas = await account.connectTransaction(blockHeader, transaction, decryptedNotes, tx);
            assetBalanceDeltas.update(transactionDeltas);
            await this.upsertAssetsFromDecryptedNotes(account, decryptedNotes, blockHeader, tx);
        }
        return assetBalanceDeltas;
    }
    async upsertAssetsFromDecryptedNotes(account, decryptedNotes, blockHeader, tx) {
        for (const { serializedNote } of decryptedNotes) {
            const note = new note_1.Note(serializedNote);
            const asset = await this.walletDb.getAsset(account, note.assetId(), tx);
            if (!asset) {
                const chainAsset = await this.getChainAsset(note.assetId());
                assert_1.Assert.isNotNull(chainAsset, 'Asset must be non-null in the chain');
                await account.saveAssetFromChain(chainAsset.createdTransactionHash, chainAsset.id, chainAsset.metadata, chainAsset.name, chainAsset.nonce, chainAsset.creator, chainAsset.owner, blockHeader, tx);
            }
            else if (blockHeader) {
                await account.updateAssetWithBlockHeader(asset, { hash: blockHeader.hash, sequence: blockHeader.sequence }, tx);
            }
        }
    }
    async disconnectBlock(header, transactions) {
        const accounts = await utils_1.AsyncUtils.filter(this.listAccounts(), async (account) => {
            const accountHead = await account.getHead();
            return utils_1.BufferUtils.equalsNullable(accountHead?.hash ?? null, header.hash);
        });
        for (const account of accounts) {
            const assetBalanceDeltas = new assetBalances_1.AssetBalances();
            await this.walletDb.db.transaction(async (tx) => {
                for (const { transaction } of transactions.slice().reverse()) {
                    const transactionDeltas = await account.disconnectTransaction(header, transaction, tx);
                    assetBalanceDeltas.update(transactionDeltas);
                    if (transaction.isMinersFee()) {
                        await account.deleteTransaction(transaction, tx);
                    }
                }
                await account.updateUnconfirmedBalances(assetBalanceDeltas, header.previousBlockHash, header.sequence - 1, tx);
                await account.updateHead({ hash: header.previousBlockHash, sequence: header.sequence - 1 }, tx);
                if (account.createdAt?.hash.equals(header.hash)) {
                    await account.updateCreatedAt({ hash: header.previousBlockHash, sequence: header.sequence - 1 }, tx);
                }
            });
        }
    }
    async addPendingTransaction(transaction) {
        const accounts = await utils_1.AsyncUtils.filter(this.listAccounts(), async (account) => !(await account.hasTransaction(transaction.hash())));
        if (accounts.length === 0) {
            return;
        }
        const decryptedNotesByAccountId = await this.decryptNotes(transaction, null, false, accounts);
        const head = await this.getChainHead();
        for (const account of accounts) {
            const decryptedNotes = decryptedNotesByAccountId.get(account.id) ?? [];
            await account.addPendingTransaction(transaction, decryptedNotes, head.sequence);
            await this.upsertAssetsFromDecryptedNotes(account, decryptedNotes);
        }
    }
    async scanTransactions(fromHash, force) {
        if (!this.isOpen) {
            throw new Error('Cannot start a scan if accounts are not loaded');
        }
        if (!this.config.get('enableWallet')) {
            this.logger.info('Skipping Scan, wallet is not started.');
            return;
        }
        if (this.scan) {
            if (force) {
                this.logger.info('Aborting scan in progress and starting new scan.');
                await this.scan.abort();
            }
            else {
                this.logger.info('Skipping Scan, already scanning.');
                return;
            }
        }
        const scan = new ScanState();
        this.scan = scan;
        // If we are updating the account head, we need to wait until its finished
        // but setting this.scan is our lock so updating the head doesn't run again
        await this.updateHeadState?.wait();
        const startHash = fromHash ?? (await this.getEarliestHeadHash());
        // Fetch current chain head sequence
        const chainHead = await this.getChainHead();
        scan.endSequence = chainHead.sequence;
        this.logger.info(`Scan starting from block ${startHash?.toString('hex') ?? 'null'}`);
        const scanProcessor = new remoteChainProcessor_1.RemoteChainProcessor({
            logger: this.logger,
            nodeClient: this.nodeClient,
            head: startHash,
            maxQueueSize: this.config.get('walletSyncingMaxQueueSize'),
        });
        scanProcessor.onAdd.on(async ({ header, transactions }) => {
            await this.connectBlock(header, transactions, scan);
            scan.signal(header.sequence);
        });
        scanProcessor.onRemove.on(async ({ header, transactions }) => {
            await this.disconnectBlock(header, transactions);
        });
        let hashChanged = false;
        do {
            hashChanged = (await scanProcessor.update({ signal: scan.abortController.signal }))
                .hashChanged;
        } while (hashChanged);
        // Update chainProcessor following scan
        this.chainProcessor.hash = scanProcessor.hash;
        this.chainProcessor.sequence = scanProcessor.sequence;
        this.logger.info(`Finished scanning for transactions after ${Math.floor((Date.now() - scan.startedAt) / 1000)} seconds`);
        scan.signalComplete();
        this.scan = null;
    }
    async *getBalances(account, confirmations) {
        confirmations = confirmations ?? this.config.get('confirmations');
        this.assertHasAccount(account);
        for await (const balance of account.getBalances(confirmations)) {
            yield balance;
        }
    }
    async getBalance(account, assetId, options) {
        const confirmations = options?.confirmations ?? this.config.get('confirmations');
        this.assertHasAccount(account);
        return account.getBalance(assetId, confirmations);
    }
    async *getUnspentNotes(account, assetId, options) {
        const confirmations = options?.confirmations ?? this.config.get('confirmations');
        for await (const decryptedNote of account.getUnspentNotes(assetId, {
            confirmations,
        })) {
            yield decryptedNote;
        }
    }
    async send(options) {
        const raw = await this.createTransaction({
            account: options.account,
            outputs: options.outputs,
            fee: options.fee,
            feeRate: options.feeRate,
            expirationDelta: options.expirationDelta,
            expiration: options.expiration ?? undefined,
            confirmations: options.confirmations ?? undefined,
        });
        const { transaction } = await this.post({
            transaction: raw,
            account: options.account,
        });
        return transaction;
    }
    async mint(account, options) {
        let mintData;
        if ('assetId' in options) {
            const asset = await this.getChainAsset(options.assetId);
            if (!asset) {
                throw new Error(`Asset not found. Cannot mint for identifier '${options.assetId.toString('hex')}'`);
            }
            mintData = {
                name: asset.name.toString('utf8'),
                metadata: asset.metadata.toString('utf8'),
                value: options.value,
            };
        }
        else {
            mintData = {
                name: options.name,
                metadata: options.metadata,
                value: options.value,
            };
        }
        const raw = await this.createTransaction({
            account,
            mints: [mintData],
            fee: options.fee,
            expirationDelta: options.expirationDelta,
            expiration: options.expiration,
            confirmations: options.confirmations,
        });
        const { transaction } = await this.post({
            transaction: raw,
            account,
        });
        return transaction;
    }
    async burn(account, assetId, value, fee, expirationDelta, expiration, confirmations) {
        const raw = await this.createTransaction({
            account,
            burns: [{ assetId, value }],
            fee,
            expirationDelta,
            expiration,
            confirmations,
        });
        const { transaction } = await this.post({
            transaction: raw,
            account,
        });
        return transaction;
    }
    async createTransaction(options) {
        const heaviestHead = await this.getChainHead();
        if (heaviestHead === null) {
            throw new Error('You must have a genesis block to create a transaction');
        }
        if (options.fee === undefined && options.feeRate === undefined) {
            throw new Error('Fee or FeeRate is required to create a transaction');
        }
        const confirmations = options.confirmations ?? this.config.get('confirmations');
        const expirationDelta = options.expirationDelta ?? this.config.get('transactionExpirationDelta');
        const expiration = options.expiration ?? heaviestHead.sequence + expirationDelta;
        if (consensus_1.isExpiredSequence(expiration, heaviestHead.sequence)) {
            throw new Error(`Invalid expiration sequence for transaction ${expiration} vs ${heaviestHead.sequence}`);
        }
        const unlock = await this.createTransactionMutex.lock();
        try {
            this.assertHasAccount(options.account);
            if (!(await this.isAccountUpToDate(options.account))) {
                throw new Error('Your account must finish scanning before sending a transaction.');
            }
            const raw = new rawTransaction_1.RawTransaction();
            raw.expiration = expiration;
            if (options.mints) {
                raw.mints = options.mints;
            }
            if (options.burns) {
                raw.burns = options.burns;
            }
            if (options.outputs) {
                for (const output of options.outputs) {
                    const note = new rust_nodejs_1.Note(output.publicAddress, output.amount, output.memo, output.assetId, options.account.publicAddress);
                    raw.outputs.push({ note: new note_1.Note(note.serialize()) });
                }
            }
            if (options.fee != null) {
                raw.fee = options.fee;
            }
            if (options.feeRate) {
                raw.fee = feeEstimator_1.getFee(options.feeRate, raw.postedSize(options.account.publicAddress));
            }
            await this.fund(raw, {
                account: options.account,
                notes: options.notes,
                confirmations: confirmations,
            });
            if (options.feeRate) {
                raw.fee = feeEstimator_1.getFee(options.feeRate, raw.postedSize(options.account.publicAddress));
                raw.spends = [];
                await this.fund(raw, {
                    account: options.account,
                    notes: options.notes,
                    confirmations: confirmations,
                });
            }
            return raw;
        }
        finally {
            unlock();
        }
    }
    async post(options) {
        const broadcast = options.broadcast ?? true;
        const spendingKey = options.account?.spendingKey ?? options.spendingKey;
        assert_1.Assert.isTruthy(spendingKey, `Spending key is required to post transaction`);
        const transaction = await this.workerPool.postTransaction(options.transaction, spendingKey);
        const verify = consensus_1.Verifier.verifyCreatedTransaction(transaction, this.consensus);
        if (!verify.valid) {
            throw new Error(`Invalid transaction, reason: ${String(verify.reason)}`);
        }
        let accepted;
        let broadcasted;
        if (broadcast) {
            await this.addPendingTransaction(transaction);
            ({ accepted, broadcasted } = await this.broadcastTransaction(transaction));
        }
        return { accepted, broadcasted, transaction };
    }
    async fund(raw, options) {
        const needed = this.buildAmountsNeeded(raw, { fee: raw.fee });
        const spent = new buffer_map_1.BufferMap();
        const notesSpent = new buffer_map_1.BufferMap();
        for (const noteHash of options.notes ?? []) {
            const decryptedNote = await options.account.getDecryptedNote(noteHash);
            assert_1.Assert.isNotUndefined(decryptedNote, `No note found with hash ${noteHash.toString('hex')} for account ${options.account.name}`);
            const witness = await this.getNoteWitness(decryptedNote, options.confirmations);
            const assetId = decryptedNote.note.assetId();
            const assetAmountSpent = spent.get(assetId) ?? 0n;
            spent.set(assetId, assetAmountSpent + decryptedNote.note.value());
            const assetNotesSpent = notesSpent.get(assetId) ?? new buffer_map_1.BufferSet();
            assetNotesSpent.add(noteHash);
            notesSpent.set(assetId, assetNotesSpent);
            raw.spends.push({ note: decryptedNote.note, witness });
        }
        for (const [assetId, assetAmountNeeded] of needed.entries()) {
            const assetAmountSpent = spent.get(assetId) ?? 0n;
            const assetNotesSpent = notesSpent.get(assetId) ?? new buffer_map_1.BufferSet();
            if (assetAmountSpent >= assetAmountNeeded) {
                continue;
            }
            const amountSpent = await this.addSpendsForAsset(raw, options.account, assetId, assetAmountNeeded, assetAmountSpent, assetNotesSpent, options.confirmations);
            if (amountSpent < assetAmountNeeded) {
                throw new errors_1.NotEnoughFundsError(assetId, amountSpent, assetAmountNeeded);
            }
        }
    }
    async getNoteWitness(note, confirmations) {
        assert_1.Assert.isNotNull(note.index, `Note with hash ${note.note
            .hash()
            .toString('hex')} is missing an index and cannot be spent.`);
        assert_1.Assert.isNotNull(this.nodeClient);
        const response = await this.nodeClient.chain.getNoteWitness({
            index: note.index,
            confirmations: confirmations ?? this.config.get('confirmations'),
        });
        const witness = new witness_1.Witness(response.content.treeSize, Buffer.from(response.content.rootHash, 'hex'), response.content.authPath.map((node) => ({
            hashOfSibling: Buffer.from(node.hashOfSibling, 'hex'),
            side: node.side === 'Left' ? merkletree_2.Side.Left : merkletree_2.Side.Right,
        })), new merkletree_1.NoteHasher());
        assert_1.Assert.isNotNull(witness, `Could not create a witness for note with hash ${note.note.hash().toString('hex')}`);
        return witness;
    }
    buildAmountsNeeded(raw, options) {
        const amountsNeeded = new buffer_map_1.BufferMap();
        amountsNeeded.set(rust_nodejs_1.Asset.nativeId(), options.fee);
        for (const output of raw.outputs) {
            const currentAmount = amountsNeeded.get(output.note.assetId()) ?? 0n;
            amountsNeeded.set(output.note.assetId(), currentAmount + output.note.value());
        }
        for (const burn of raw.burns) {
            const currentAmount = amountsNeeded.get(burn.assetId) ?? 0n;
            amountsNeeded.set(burn.assetId, currentAmount + burn.value);
        }
        return amountsNeeded;
    }
    async addSpendsForAsset(raw, sender, assetId, amountNeeded, amountSpent, notesSpent, confirmations) {
        for await (const unspentNote of sender.getUnspentNotes(assetId, {
            confirmations,
        })) {
            if (notesSpent.has(unspentNote.note.hash())) {
                continue;
            }
            const witness = await this.getNoteWitness(unspentNote, confirmations);
            amountSpent += unspentNote.note.value();
            raw.spends.push({ note: unspentNote.note, witness });
            if (amountSpent >= amountNeeded) {
                break;
            }
        }
        return amountSpent;
    }
    async broadcastTransaction(transaction) {
        try {
            assert_1.Assert.isNotNull(this.nodeClient);
            const response = await this.nodeClient.chain.broadcastTransaction({
                transaction: transaction.serialize().toString('hex'),
            });
            assert_1.Assert.isNotNull(response.content);
            return { accepted: response.content.accepted, broadcasted: response.content.broadcasted };
        }
        catch (e) {
            this.logger.warn(`Failed to broadcast transaction ${transaction
                .hash()
                .toString('hex')}: ${utils_1.ErrorUtils.renderError(e)}`);
            return { accepted: false, broadcasted: false };
        }
    }
    async rebroadcastTransactions(sequence) {
        for (const account of this.accounts.values()) {
            if (this.eventLoopAbortController.signal.aborted) {
                return;
            }
            for await (const transactionInfo of account.getPendingTransactions(sequence)) {
                if (this.eventLoopAbortController.signal.aborted) {
                    return;
                }
                const { transaction, blockHash, submittedSequence } = transactionInfo;
                const transactionHash = transaction.hash();
                // Skip transactions that are already added to a block
                if (blockHash) {
                    continue;
                }
                // TODO: This algorithm suffers a deanonymization attack where you can
                // watch to see what transactions node continuously send out, then you can
                // know those transactions are theres. This should be randomized and made
                // less, predictable later to help prevent that attack.
                if (sequence - submittedSequence < this.rebroadcastAfter) {
                    continue;
                }
                await this.walletDb.db.transaction(async (tx) => {
                    await this.walletDb.saveTransaction(account, transactionHash, {
                        ...transactionInfo,
                        submittedSequence: sequence,
                    }, tx);
                });
                await this.broadcastTransaction(transaction);
            }
        }
    }
    async expireTransactions(sequence) {
        for (const account of this.accounts.values()) {
            if (this.eventLoopAbortController.signal.aborted) {
                return;
            }
            for await (const { transaction } of account.getExpiredTransactions(sequence)) {
                if (this.eventLoopAbortController.signal.aborted) {
                    return;
                }
                await account.expireTransaction(transaction);
            }
        }
    }
    async getTransactionStatus(account, transaction, options, tx) {
        const confirmations = options?.confirmations ?? this.config.get('confirmations');
        const headSequence = options?.headSequence ?? (await account.getHead(tx))?.sequence;
        if (!headSequence) {
            return TransactionStatus.UNKNOWN;
        }
        if (transaction.sequence) {
            const isConfirmed = transaction.sequence === primitives_1.GENESIS_BLOCK_SEQUENCE ||
                headSequence - transaction.sequence >= confirmations;
            return isConfirmed ? TransactionStatus.CONFIRMED : TransactionStatus.UNCONFIRMED;
        }
        else {
            const isExpired = consensus_1.isExpiredSequence(transaction.transaction.expiration(), headSequence);
            return isExpired ? TransactionStatus.EXPIRED : TransactionStatus.PENDING;
        }
    }
    async getAssetStatus(account, assetValue, options) {
        const confirmations = options?.confirmations ?? this.config.get('confirmations');
        const headSequence = options?.headSequence ?? (await account.getHead())?.sequence;
        if (!headSequence) {
            return AssetStatus.UNKNOWN;
        }
        if (assetValue.sequence) {
            const confirmed = headSequence - assetValue.sequence >= confirmations;
            return confirmed ? AssetStatus.CONFIRMED : AssetStatus.UNCONFIRMED;
        }
        return AssetStatus.PENDING;
    }
    async getTransactionType(account, transaction, tx) {
        if (transaction.transaction.isMinersFee()) {
            return TransactionType.MINER;
        }
        for (const spend of transaction.transaction.spends) {
            if ((await account.getNoteHash(spend.nullifier, tx)) !== undefined) {
                return TransactionType.SEND;
            }
        }
        for (const note of transaction.transaction.notes) {
            const decryptedNote = await account.getDecryptedNote(note.hash(), tx);
            if (!decryptedNote) {
                continue;
            }
            if (decryptedNote.note.sender() === account.publicAddress) {
                return TransactionType.SEND;
            }
        }
        return TransactionType.RECEIVE;
    }
    async createAccount(name, options = {
        setCreatedAt: true,
        setDefault: false,
    }) {
        if (this.getAccountByName(name)) {
            throw new Error(`Account already exists with the name ${name}`);
        }
        const key = rust_nodejs_1.generateKey();
        let createdAt = null;
        if (options.setCreatedAt && this.nodeClient) {
            try {
                createdAt = await this.getChainHead();
            }
            catch {
                this.logger.warn('Failed to fetch chain head from node client');
            }
        }
        const account = new account_1.Account({
            version: account_1.ACCOUNT_SCHEMA_VERSION,
            id: uuid_1.v4(),
            name,
            incomingViewKey: key.incomingViewKey,
            outgoingViewKey: key.outgoingViewKey,
            publicAddress: key.publicAddress,
            spendingKey: key.spendingKey,
            viewKey: key.viewKey,
            createdAt,
            walletDb: this.walletDb,
        });
        await this.walletDb.db.transaction(async (tx) => {
            await this.walletDb.setAccount(account, tx);
            await account.updateHead(createdAt, tx);
        });
        // If this is the first account, set the chainProcessor state
        if (this.accounts.size === 0 && createdAt) {
            this.chainProcessor.hash = createdAt.hash;
            this.chainProcessor.sequence = createdAt.sequence;
        }
        this.accounts.set(account.id, account);
        if (options.setDefault) {
            await this.setDefaultAccount(account.name);
        }
        return account;
    }
    async skipRescan(account, tx) {
        const hash = this.chainProcessor.hash;
        const sequence = this.chainProcessor.sequence;
        if (hash === null || sequence === null) {
            await account.updateHead(null, tx);
        }
        else {
            await account.updateHead({ hash, sequence }, tx);
        }
    }
    async importAccount(accountValue) {
        if (accountValue.name && this.getAccountByName(accountValue.name)) {
            throw new Error(`Account already exists with the name ${accountValue.name}`);
        }
        const accounts = this.listAccounts();
        if (accountValue.spendingKey &&
            accounts.find((a) => accountValue.spendingKey === a.spendingKey)) {
            throw new Error(`Account already exists with provided spending key`);
        }
        if (accounts.find((a) => accountValue.viewKey === a.viewKey)) {
            throw new Error(`Account already exists with provided view key(s)`);
        }
        validator_1.validateAccount(accountValue);
        let createdAt = accountValue.createdAt;
        if (createdAt && !this.nodeClient) {
            this.logger.debug(`Wallet not connected to node to verify that account createdAt block ${createdAt.hash.toString('hex')} (${createdAt.sequence}) in chain. Setting createdAt to null`);
            createdAt = null;
        }
        if (createdAt !== null && !(await this.chainHasBlock(createdAt.hash))) {
            this.logger.debug(`Account ${accountValue.name} createdAt block ${createdAt.hash.toString('hex')} (${createdAt.sequence}) not found in the chain. Setting createdAt to null.`);
            createdAt = null;
        }
        const account = new account_1.Account({
            ...accountValue,
            createdAt,
            walletDb: this.walletDb,
        });
        await this.walletDb.db.transaction(async (tx) => {
            await this.walletDb.setAccount(account, tx);
            await account.updateHead(null, tx);
        });
        this.accounts.set(account.id, account);
        this.onAccountImported.emit(account);
        return account;
    }
    listAccounts() {
        return Array.from(this.accounts.values());
    }
    accountExists(name) {
        return this.getAccountByName(name) !== null;
    }
    async resetAccount(account, options) {
        const newAccount = new account_1.Account({
            ...account,
            createdAt: options?.resetCreatedAt ? null : account.createdAt,
            id: uuid_1.v4(),
            walletDb: this.walletDb,
        });
        await this.walletDb.db.withTransaction(options?.tx, async (tx) => {
            await this.walletDb.setAccount(newAccount, tx);
            await newAccount.updateHead(null, tx);
            if (account.id === this.defaultAccount) {
                await this.walletDb.setDefaultAccount(newAccount.id, tx);
                this.defaultAccount = newAccount.id;
            }
            this.accounts.set(newAccount.id, newAccount);
            await this.removeAccount(account, tx);
        });
    }
    async removeAccountByName(name) {
        const account = this.getAccountByName(name);
        if (!account) {
            return;
        }
        await this.removeAccount(account);
    }
    async removeAccount(account, tx) {
        await this.walletDb.db.withTransaction(tx, async (tx) => {
            if (account.id === this.defaultAccount) {
                await this.walletDb.setDefaultAccount(null, tx);
                this.defaultAccount = null;
            }
            await this.walletDb.removeAccount(account, tx);
            await this.walletDb.removeHead(account, tx);
        });
        this.accounts.delete(account.id);
        this.onAccountRemoved.emit(account);
    }
    async forceCleanupDeletedAccounts() {
        await this.walletDb.forceCleanupDeletedAccounts(this.eventLoopAbortController.signal);
    }
    async cleanupDeletedAccounts() {
        if (!this.isStarted) {
            return;
        }
        if (this.scan || this.updateHeadState) {
            return;
        }
        const recordsToCleanup = 1000;
        await this.walletDb.cleanupDeletedAccounts(recordsToCleanup, this.eventLoopAbortController.signal);
    }
    get hasDefaultAccount() {
        return !!this.defaultAccount;
    }
    /** Set or clear the default account */
    async setDefaultAccount(name, tx) {
        let next = null;
        if (name) {
            next = this.getAccountByName(name);
            if (!next) {
                throw new Error(`No account found with name ${name}`);
            }
            if (this.defaultAccount === next.id) {
                return;
            }
        }
        const nextId = next ? next.id : null;
        await this.walletDb.setDefaultAccount(nextId, tx);
        this.defaultAccount = nextId;
    }
    getAccountByName(name) {
        for (const account of this.accounts.values()) {
            if (name === account.name) {
                return account;
            }
        }
        return null;
    }
    getAccount(id) {
        const account = this.accounts.get(id);
        if (account) {
            return account;
        }
        return null;
    }
    getDefaultAccount() {
        if (!this.defaultAccount) {
            return null;
        }
        return this.getAccount(this.defaultAccount);
    }
    async getEarliestHeadHash() {
        let earliestHead = null;
        for (const account of this.accounts.values()) {
            const head = await account.getHead();
            if (!head) {
                return null;
            }
            if (!earliestHead || earliestHead.sequence > head.sequence) {
                earliestHead = head;
            }
        }
        return earliestHead ? earliestHead.hash : null;
    }
    async getLatestHead() {
        let latestHead = null;
        for (const account of this.accounts.values()) {
            const head = await account.getHead();
            if (!head) {
                continue;
            }
            if (!latestHead || latestHead.sequence < head.sequence) {
                latestHead = head;
            }
        }
        return latestHead;
    }
    async getLatestHeadHash() {
        const latestHead = await this.getLatestHead();
        return latestHead ? latestHead.hash : null;
    }
    async isAccountUpToDate(account) {
        const head = await account.getHead();
        assert_1.Assert.isNotUndefined(head, `isAccountUpToDate: No head hash found for account ${account.displayName}`);
        return utils_1.BufferUtils.equalsNullable(head?.hash ?? null, this.chainProcessor.hash);
    }
    assertHasAccount(account) {
        if (!this.accountExists(account.name)) {
            throw new Error(`No account found with name ${account.name}`);
        }
    }
    assertNotHasAccount(account) {
        if (this.accountExists(account.name)) {
            throw new Error(`No account found with name ${account.name}`);
        }
    }
    async chainHasBlock(hash) {
        return (await this.chainGetBlock({ hash: hash.toString('hex') })) !== null;
    }
    async chainGetBlock(request) {
        try {
            assert_1.Assert.isNotNull(this.nodeClient);
            return (await this.nodeClient.chain.getBlock(request)).content;
        }
        catch (error) {
            if (utils_1.ErrorUtils.isNotFoundError(error)) {
                return null;
            }
            this.logger.error(utils_1.ErrorUtils.renderError(error, true));
            throw error;
        }
    }
    async getChainAsset(id) {
        try {
            assert_1.Assert.isNotNull(this.nodeClient);
            const response = await this.nodeClient.chain.getAsset({ id: id.toString('hex') });
            return {
                createdTransactionHash: Buffer.from(response.content.createdTransactionHash, 'hex'),
                creator: Buffer.from(response.content.creator, 'hex'),
                owner: Buffer.from(response.content.owner, 'hex'),
                id: Buffer.from(response.content.id, 'hex'),
                metadata: Buffer.from(response.content.metadata, 'hex'),
                name: Buffer.from(response.content.name, 'hex'),
                nonce: response.content.nonce,
            };
        }
        catch (error) {
            if (utils_1.ErrorUtils.isNotFoundError(error)) {
                return null;
            }
            this.logger.error(utils_1.ErrorUtils.renderError(error, true));
            throw error;
        }
    }
    async getChainHead() {
        try {
            assert_1.Assert.isNotNull(this.nodeClient);
            const response = await this.nodeClient.chain.getChainInfo();
            return {
                hash: Buffer.from(response.content.oldestBlockIdentifier.hash, 'hex'),
                sequence: Number(response.content.oldestBlockIdentifier.index),
            };
        }
        catch (error) {
            this.logger.error(utils_1.ErrorUtils.renderError(error, true));
            throw error;
        }
    }
}
exports.Wallet = Wallet;
class ScanState {
    constructor() {
        this.onTransaction = new event_1.Event();
        this.sequence = -1;
        this.endSequence = -1;
        const [promise, resolve] = utils_1.PromiseUtils.split();
        this.runningPromise = promise;
        this.runningResolve = resolve;
        this.abortController = new AbortController();
        this.startedAt = Date.now();
    }
    get isAborted() {
        return this.abortController.signal.aborted;
    }
    signal(sequence) {
        this.sequence = sequence;
        this.onTransaction.emit(sequence, this.endSequence);
    }
    signalComplete() {
        this.runningResolve();
    }
    async abort() {
        this.abortController.abort();
        return this.wait();
    }
    wait() {
        return this.runningPromise;
    }
}
exports.ScanState = ScanState;
//# sourceMappingURL=wallet.js.map