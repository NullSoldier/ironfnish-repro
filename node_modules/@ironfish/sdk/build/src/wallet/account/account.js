"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.calculateAccountPrefix = exports.Account = exports.AssertSpending = exports.ACCOUNT_SCHEMA_VERSION = exports.ACCOUNT_KEY_LENGTH = void 0;
/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/. */
const rust_nodejs_1 = require("@ironfish/rust-nodejs");
const buffer_map_1 = require("buffer-map");
const imurmurhash_1 = __importDefault(require("imurmurhash"));
const assert_1 = require("../../assert");
const block_1 = require("../../primitives/block");
const note_1 = require("../../primitives/note");
const utils_1 = require("../../storage/database/utils");
const assetBalances_1 = require("../assetBalances");
exports.ACCOUNT_KEY_LENGTH = 32;
exports.ACCOUNT_SCHEMA_VERSION = 2;
function AssertSpending(account) {
    assert_1.Assert.isTrue(account.isSpendingAccount());
}
exports.AssertSpending = AssertSpending;
class Account {
    constructor({ id, name, publicAddress, walletDb, spendingKey, viewKey, incomingViewKey, outgoingViewKey, version, createdAt, }) {
        this.id = id;
        this.name = name;
        this.spendingKey = spendingKey;
        this.viewKey = viewKey;
        this.incomingViewKey = incomingViewKey;
        this.outgoingViewKey = outgoingViewKey;
        this.publicAddress = publicAddress;
        this.prefix = calculateAccountPrefix(id);
        this.prefixRange = utils_1.StorageUtils.getPrefixKeyRange(this.prefix);
        this.displayName = `${name} (${id.slice(0, 7)})`;
        this.walletDb = walletDb;
        this.version = version ?? 1;
        this.createdAt = createdAt;
    }
    isSpendingAccount() {
        return this.spendingKey !== null;
    }
    serialize() {
        return {
            version: this.version,
            id: this.id,
            name: this.name,
            spendingKey: this.spendingKey,
            viewKey: this.viewKey,
            incomingViewKey: this.incomingViewKey,
            outgoingViewKey: this.outgoingViewKey,
            publicAddress: this.publicAddress,
            createdAt: this.createdAt,
        };
    }
    async setName(name, tx) {
        this.name = name;
        await this.walletDb.setAccount(this, tx);
    }
    async *getNotes(keyRange) {
        for await (const decryptedNote of this.walletDb.loadDecryptedNotes(this, keyRange)) {
            yield decryptedNote;
        }
    }
    async *getUnspentNotes(assetId, options) {
        const head = await this.getHead();
        if (!head) {
            return;
        }
        const confirmations = options?.confirmations ?? 0;
        const maxConfirmedSequence = Math.max(head.sequence - confirmations, block_1.GENESIS_BLOCK_SEQUENCE);
        for await (const decryptedNote of this.walletDb.loadUnspentNotes(this, assetId, maxConfirmedSequence)) {
            yield decryptedNote;
        }
    }
    async getDecryptedNote(hash, tx) {
        return await this.walletDb.loadDecryptedNote(this, hash, tx);
    }
    async connectTransaction(blockHeader, transaction, decryptedNotes, tx) {
        const blockHash = blockHeader.hash;
        const sequence = blockHeader.sequence;
        const assetBalanceDeltas = new assetBalances_1.AssetBalances();
        let submittedSequence = sequence;
        let timestamp = blockHeader.timestamp;
        await this.walletDb.db.withTransaction(tx, async (tx) => {
            let transactionValue = await this.getTransaction(transaction.hash(), tx);
            if (transactionValue) {
                submittedSequence = transactionValue.submittedSequence;
                timestamp = transactionValue.timestamp;
            }
            for (const decryptedNote of decryptedNotes) {
                if (decryptedNote.forSpender) {
                    continue;
                }
                const pendingNote = await this.getDecryptedNote(decryptedNote.hash, tx);
                const spent = pendingNote?.spent ?? false;
                const note = {
                    accountId: this.id,
                    note: new note_1.Note(decryptedNote.serializedNote),
                    spent,
                    transactionHash: transaction.hash(),
                    nullifier: decryptedNote.nullifier,
                    index: decryptedNote.index,
                    blockHash,
                    sequence,
                };
                assetBalanceDeltas.increment(note.note.assetId(), note.note.value());
                await this.walletDb.saveDecryptedNote(this, decryptedNote.hash, note, tx);
                if (!spent) {
                    await this.walletDb.addUnspentNoteHash(this, decryptedNote.hash, note, tx);
                }
            }
            for (const spend of transaction.spends) {
                const spentNoteHash = await this.getNoteHash(spend.nullifier, tx);
                if (!spentNoteHash) {
                    continue;
                }
                const note = await this.getDecryptedNote(spentNoteHash, tx);
                assert_1.Assert.isNotUndefined(note);
                assetBalanceDeltas.increment(note.note.assetId(), -note.note.value());
                const spentNote = { ...note, spent: true };
                await this.walletDb.saveDecryptedNote(this, spentNoteHash, spentNote, tx);
                await this.walletDb.saveNullifierToTransactionHash(this, spend.nullifier, transaction, tx);
                await this.walletDb.deleteUnspentNoteHash(this, spentNoteHash, spentNote, tx);
            }
            // account did not receive or spend
            if (assetBalanceDeltas.size === 0) {
                return;
            }
            transactionValue = {
                transaction,
                blockHash,
                sequence,
                submittedSequence,
                timestamp,
                assetBalanceDeltas,
            };
            await this.saveMintsToAssetsStore(transactionValue, tx);
            await this.saveConnectedBurnsToAssetsStore(transactionValue.transaction, tx);
            await this.walletDb.saveTransaction(this, transaction.hash(), transactionValue, tx);
        });
        return assetBalanceDeltas;
    }
    async saveAssetFromChain(createdTransactionHash, id, metadata, name, nonce, creator, owner, blockHeader, tx) {
        if (id.equals(rust_nodejs_1.Asset.nativeId())) {
            return;
        }
        await this.walletDb.putAsset(this, id, {
            blockHash: blockHeader?.hash ?? null,
            createdTransactionHash,
            id,
            metadata,
            name,
            nonce,
            creator,
            owner,
            sequence: blockHeader?.sequence ?? null,
            supply: null,
        }, tx);
    }
    async updateAssetWithBlockHeader(assetValue, blockHeader, tx) {
        // Don't update for the native asset or if previously confirmed
        if (assetValue.id.equals(rust_nodejs_1.Asset.nativeId()) || assetValue.blockHash) {
            return;
        }
        await this.walletDb.putAsset(this, assetValue.id, {
            blockHash: blockHeader.hash,
            createdTransactionHash: assetValue.createdTransactionHash,
            id: assetValue.id,
            metadata: assetValue.metadata,
            name: assetValue.name,
            nonce: assetValue.nonce,
            creator: assetValue.creator,
            owner: assetValue.creator,
            sequence: blockHeader.sequence,
            supply: assetValue.supply,
        }, tx);
    }
    async saveMintsToAssetsStore({ blockHash, sequence, transaction }, tx) {
        for (const { asset, value } of transaction.mints) {
            // Only store the asset for the creator
            if (asset.creator().toString('hex') !== this.publicAddress) {
                continue;
            }
            const existingAsset = await this.walletDb.getAsset(this, asset.id(), tx);
            let createdTransactionHash = transaction.hash();
            let supply = 0n;
            // Adjust supply if this transaction is connected on a block.
            if (blockHash && sequence) {
                supply += value;
            }
            // If the asset has been previously confirmed on a block, use the existing
            // block hash, created transaction hash, and sequence for the database
            // upsert. Adjust supply from the current record.
            if (existingAsset && existingAsset.blockHash && existingAsset.sequence) {
                assert_1.Assert.isNotNull(existingAsset.supply, 'Supply should be non-null for asset');
                blockHash = existingAsset.blockHash;
                createdTransactionHash = existingAsset.createdTransactionHash;
                sequence = existingAsset.sequence;
                supply += existingAsset.supply;
            }
            await this.walletDb.putAsset(this, asset.id(), {
                blockHash,
                createdTransactionHash,
                id: asset.id(),
                metadata: asset.metadata(),
                name: asset.name(),
                nonce: asset.nonce(),
                creator: asset.creator(),
                owner: asset.creator(),
                sequence,
                supply,
            }, tx);
        }
    }
    async saveConnectedBurnsToAssetsStore(transaction, tx) {
        for (const { assetId, value } of transaction.burns) {
            const existingAsset = await this.walletDb.getAsset(this, assetId, tx);
            if (!existingAsset) {
                continue;
            }
            // Verify the creator matches before processing a burn since an account
            // can burn assets it does not own
            if (existingAsset.creator.toString('hex') !== this.publicAddress) {
                continue;
            }
            assert_1.Assert.isNotNull(existingAsset.supply, 'Supply should be non-null for asset');
            const supply = existingAsset.supply - value;
            assert_1.Assert.isTrue(supply >= 0n, 'Invalid burn value');
            await this.walletDb.putAsset(this, assetId, {
                blockHash: existingAsset.blockHash,
                createdTransactionHash: existingAsset.createdTransactionHash,
                id: existingAsset.id,
                metadata: existingAsset.metadata,
                name: existingAsset.name,
                nonce: existingAsset.nonce,
                creator: existingAsset.creator,
                owner: existingAsset.creator,
                sequence: existingAsset.sequence,
                supply,
            }, tx);
        }
    }
    async deleteDisconnectedBurnsFromAssetsStore(transaction, tx) {
        for (const { assetId, value } of transaction.burns.slice().reverse()) {
            const existingAsset = await this.walletDb.getAsset(this, assetId, tx);
            if (!existingAsset) {
                continue;
            }
            // Verify the creator matches before processing a burn since an account
            // can burn assets it does not own
            if (existingAsset.creator.toString('hex') !== this.publicAddress) {
                continue;
            }
            assert_1.Assert.isNotNull(existingAsset.supply, 'Supply should be non-null for asset');
            const existingSupply = existingAsset.supply;
            const supply = existingSupply + value;
            await this.walletDb.putAsset(this, assetId, {
                blockHash: existingAsset.blockHash,
                createdTransactionHash: existingAsset.createdTransactionHash,
                id: existingAsset.id,
                metadata: existingAsset.metadata,
                name: existingAsset.name,
                nonce: existingAsset.nonce,
                creator: existingAsset.creator,
                owner: existingAsset.owner,
                sequence: existingAsset.sequence,
                supply,
            }, tx);
        }
    }
    async deleteDisconnectedMintsFromAssetsStore(blockHeader, transaction, tx) {
        for (const { asset, value } of transaction.mints.slice().reverse()) {
            // Only update the mint for the creator
            if (asset.creator().toString('hex') !== this.publicAddress) {
                continue;
            }
            const existingAsset = await this.walletDb.getAsset(this, asset.id(), tx);
            assert_1.Assert.isNotUndefined(existingAsset);
            assert_1.Assert.isNotNull(existingAsset.supply, 'Supply should be non-null for asset');
            const existingSupply = existingAsset.supply;
            const supply = existingSupply - value;
            assert_1.Assert.isTrue(supply >= 0n);
            let blockHash = existingAsset.blockHash;
            let sequence = existingAsset.sequence;
            // Mark this asset as pending if the block hash matches the hash on the
            // disconnected header
            if (blockHash && blockHash.equals(blockHeader.hash)) {
                blockHash = null;
                sequence = null;
            }
            await this.walletDb.putAsset(this, asset.id(), {
                blockHash,
                createdTransactionHash: existingAsset.createdTransactionHash,
                id: asset.id(),
                metadata: asset.metadata(),
                name: asset.name(),
                nonce: asset.nonce(),
                creator: asset.creator(),
                owner: asset.creator(),
                sequence,
                supply,
            }, tx);
        }
    }
    async addPendingTransaction(transaction, decryptedNotes, submittedSequence, tx) {
        const assetBalanceDeltas = new assetBalances_1.AssetBalances();
        await this.walletDb.db.withTransaction(tx, async (tx) => {
            if (await this.hasTransaction(transaction.hash(), tx)) {
                return;
            }
            for (const decryptedNote of decryptedNotes) {
                if (decryptedNote.forSpender) {
                    continue;
                }
                const note = {
                    accountId: this.id,
                    note: new note_1.Note(decryptedNote.serializedNote),
                    spent: false,
                    transactionHash: transaction.hash(),
                    nullifier: null,
                    index: null,
                    blockHash: null,
                    sequence: null,
                };
                assetBalanceDeltas.increment(note.note.assetId(), note.note.value());
                await this.walletDb.saveDecryptedNote(this, decryptedNote.hash, note, tx);
            }
            for (const spend of transaction.spends) {
                const spentNoteHash = await this.getNoteHash(spend.nullifier, tx);
                if (!spentNoteHash) {
                    continue;
                }
                const note = await this.getDecryptedNote(spentNoteHash, tx);
                assert_1.Assert.isNotUndefined(note);
                assetBalanceDeltas.increment(note.note.assetId(), -note.note.value());
                const spentNote = { ...note, spent: true };
                await this.walletDb.saveDecryptedNote(this, spentNoteHash, spentNote, tx);
                const existingTransactionHash = await this.walletDb.getTransactionHashFromNullifier(this, spend.nullifier, tx);
                if (!existingTransactionHash) {
                    await this.walletDb.saveNullifierToTransactionHash(this, spend.nullifier, transaction, tx);
                }
                await this.walletDb.deleteUnspentNoteHash(this, spentNoteHash, spentNote, tx);
            }
            // account did not receive or spend
            if (assetBalanceDeltas.size === 0) {
                return;
            }
            const transactionValue = {
                transaction,
                blockHash: null,
                sequence: null,
                submittedSequence,
                timestamp: new Date(),
                assetBalanceDeltas,
            };
            await this.saveMintsToAssetsStore(transactionValue, tx);
            await this.walletDb.saveTransaction(this, transaction.hash(), transactionValue, tx);
        });
    }
    async disconnectTransaction(blockHeader, transaction, tx) {
        const assetBalanceDeltas = new assetBalances_1.AssetBalances();
        await this.walletDb.db.withTransaction(tx, async (tx) => {
            const transactionValue = await this.getTransaction(transaction.hash(), tx);
            if (transactionValue === undefined) {
                return;
            }
            for (const note of transaction.notes) {
                const noteHash = note.hash();
                const decryptedNoteValue = await this.getDecryptedNote(noteHash, tx);
                if (decryptedNoteValue === undefined) {
                    continue;
                }
                assetBalanceDeltas.increment(decryptedNoteValue.note.assetId(), -decryptedNoteValue.note.value());
                const sequence = decryptedNoteValue.sequence;
                assert_1.Assert.isNotNull(sequence);
                await this.walletDb.disconnectNoteHashSequence(this, noteHash, sequence, tx);
                assert_1.Assert.isNotNull(decryptedNoteValue.nullifier);
                await this.walletDb.deleteNullifier(this, decryptedNoteValue.nullifier, tx);
                await this.walletDb.saveDecryptedNote(this, noteHash, {
                    ...decryptedNoteValue,
                    nullifier: null,
                    index: null,
                    blockHash: null,
                    sequence: null,
                }, tx);
                await this.walletDb.deleteUnspentNoteHash(this, noteHash, decryptedNoteValue, tx);
            }
            for (const spend of transaction.spends) {
                const spentNoteHash = await this.getNoteHash(spend.nullifier, tx);
                if (!spentNoteHash) {
                    continue;
                }
                const spentNote = await this.getDecryptedNote(spentNoteHash, tx);
                assert_1.Assert.isNotUndefined(spentNote);
                assetBalanceDeltas.increment(spentNote.note.assetId(), spentNote.note.value());
            }
            await this.deleteDisconnectedBurnsFromAssetsStore(transaction, tx);
            await this.deleteDisconnectedMintsFromAssetsStore(blockHeader, transaction, tx);
            await this.walletDb.deleteSequenceToTransactionHash(this, blockHeader.sequence, transaction.hash(), tx);
            await this.walletDb.savePendingTransactionHash(this, transaction.expiration(), transaction.hash(), tx);
            await this.walletDb.saveTransaction(this, transaction.hash(), { ...transactionValue, blockHash: null, sequence: null }, tx);
        });
        return assetBalanceDeltas;
    }
    async deleteTransaction(transaction, tx) {
        await this.walletDb.db.withTransaction(tx, async (tx) => {
            if (!(await this.hasTransaction(transaction.hash(), tx))) {
                return;
            }
            // expiring transaction deletes output notes and sets spent notes to unspent
            await this.expireTransaction(transaction, tx);
            await this.walletDb.deleteTransaction(this, transaction.hash(), tx);
        });
    }
    async deleteDecryptedNote(noteHash, tx) {
        await this.walletDb.db.withTransaction(tx, async (tx) => {
            const decryptedNote = await this.getDecryptedNote(noteHash, tx);
            if (!decryptedNote) {
                return;
            }
            await this.walletDb.deleteDecryptedNote(this, noteHash, tx);
            await this.walletDb.deleteNoteHashSequence(this, noteHash, decryptedNote.sequence, tx);
            if (decryptedNote.nullifier) {
                await this.walletDb.deleteNullifier(this, decryptedNote.nullifier, tx);
            }
        });
    }
    async getNoteHash(nullifier, tx) {
        return this.walletDb.loadNoteHash(this, nullifier, tx);
    }
    async getTransaction(hash, tx) {
        return await this.walletDb.loadTransaction(this, hash, tx);
    }
    async getAsset(id, tx) {
        return this.walletDb.getAsset(this, id, tx);
    }
    async hasTransaction(hash, tx) {
        return this.walletDb.hasTransaction(this, hash, tx);
    }
    async hasPendingTransaction(hash, tx) {
        return this.walletDb.hasPendingTransaction(this, hash, tx);
    }
    getTransactions(range, tx) {
        return this.walletDb.loadTransactions(this, range, tx);
    }
    getTransactionsByTime(tx, options) {
        return this.walletDb.loadTransactionsByTime(this, tx, options);
    }
    async *getTransactionsBySequence(sequence, tx) {
        for await (const { hash: _hash, ...transaction } of this.walletDb.loadTransactionsInSequenceRange(this, sequence, sequence, tx)) {
            yield transaction;
        }
    }
    async *getTransactionsOrderedBySequence(tx) {
        for await (const { hash } of this.walletDb.getTransactionHashesBySequence(this, tx)) {
            const transaction = await this.getTransaction(hash, tx);
            assert_1.Assert.isNotUndefined(transaction);
            yield transaction;
        }
    }
    getPendingTransactions(headSequence, tx) {
        return this.walletDb.loadPendingTransactions(this, headSequence, tx);
    }
    getExpiredTransactions(headSequence, tx) {
        return this.walletDb.loadExpiredTransactions(this, headSequence, tx);
    }
    async expireTransaction(transaction, tx) {
        const transactionHash = transaction.hash();
        await this.walletDb.db.withTransaction(tx, async (tx) => {
            for (const note of transaction.notes) {
                await this.deleteDecryptedNote(note.hash(), tx);
            }
            for (const spend of transaction.spends) {
                const noteHash = await this.getNoteHash(spend.nullifier, tx);
                if (noteHash) {
                    const decryptedNote = await this.getDecryptedNote(noteHash, tx);
                    assert_1.Assert.isNotUndefined(decryptedNote, 'nullifierToNote mappings must have a corresponding decryptedNote');
                    const existingTransactionHash = await this.walletDb.getTransactionHashFromNullifier(this, spend.nullifier, tx);
                    // Remove the nullifier to transaction hash mapping and mark the note as unspent
                    if (existingTransactionHash && existingTransactionHash.equals(transaction.hash())) {
                        await this.walletDb.deleteNullifierToTransactionHash(this, spend.nullifier, tx);
                        await this.walletDb.saveDecryptedNote(this, noteHash, {
                            ...decryptedNote,
                            spent: false,
                        }, tx);
                        await this.walletDb.addUnspentNoteHash(this, noteHash, decryptedNote, tx);
                    }
                }
            }
            await this.deleteCreatedAssetsFromTransaction(transaction, tx);
            await this.walletDb.deletePendingTransactionHash(this, transaction.expiration(), transactionHash, tx);
        });
    }
    async deleteCreatedAssetsFromTransaction(transaction, tx) {
        for (const { asset } of transaction.mints.slice().reverse()) {
            // Only update the mint for the creator
            if (asset.creator().toString('hex') !== this.publicAddress) {
                continue;
            }
            const existingAsset = await this.walletDb.getAsset(this, asset.id(), tx);
            if (!existingAsset) {
                return;
            }
            // If we are reverting the transaction which matches the created at
            // hash of the asset, delete the record from the store
            if (transaction.hash().equals(existingAsset.createdTransactionHash)) {
                await this.walletDb.deleteAsset(this, asset.id(), tx);
            }
        }
    }
    getAssets(tx) {
        return this.walletDb.loadAssets(this, tx);
    }
    async *getBalances(confirmations, tx) {
        const head = await this.getHead();
        if (!head) {
            return;
        }
        const pendingByAsset = await this.getPendingDeltas(head.sequence, tx);
        const unconfirmedByAsset = await this.getUnconfirmedDeltas(head.sequence, confirmations, tx);
        for await (const { assetId, balance } of this.walletDb.getUnconfirmedBalances(this, tx)) {
            const { delta: unconfirmedDelta, count: unconfirmedCount } = unconfirmedByAsset.get(assetId) ?? {
                delta: 0n,
                count: 0,
            };
            const { delta: pendingDelta, count: pendingCount } = pendingByAsset.get(assetId) ?? {
                delta: 0n,
                count: 0,
            };
            const available = await this.calculateAvailableBalance(head.sequence, assetId, confirmations, tx);
            yield {
                assetId,
                unconfirmed: balance.unconfirmed,
                unconfirmedCount,
                confirmed: balance.unconfirmed - unconfirmedDelta,
                pending: balance.unconfirmed + pendingDelta,
                pendingCount,
                available,
                blockHash: balance.blockHash,
                sequence: balance.sequence,
            };
        }
    }
    /**
     * Gets the balance for an account
     * unconfirmed: all notes on the chain
     * confirmed: confirmed balance minus transactions in unconfirmed range
     */
    async getBalance(assetId, confirmations, tx) {
        const head = await this.getHead();
        if (!head) {
            return {
                unconfirmed: 0n,
                confirmed: 0n,
                pending: 0n,
                available: 0n,
                unconfirmedCount: 0,
                pendingCount: 0,
                blockHash: null,
                sequence: null,
            };
        }
        const balance = await this.getUnconfirmedBalance(assetId, tx);
        const { delta: unconfirmedDelta, count: unconfirmedCount } = await this.getUnconfirmedDelta(head.sequence, confirmations, assetId, tx);
        const { delta: pendingDelta, count: pendingCount } = await this.getPendingDelta(head.sequence, assetId, tx);
        const available = await this.calculateAvailableBalance(head.sequence, assetId, confirmations, tx);
        return {
            unconfirmed: balance.unconfirmed,
            unconfirmedCount,
            confirmed: balance.unconfirmed - unconfirmedDelta,
            pending: balance.unconfirmed + pendingDelta,
            available,
            pendingCount,
            blockHash: balance.blockHash,
            sequence: balance.sequence,
        };
    }
    async getPendingDelta(headSequence, assetId, tx) {
        let delta = 0n;
        let count = 0;
        for await (const transaction of this.getPendingTransactions(headSequence, tx)) {
            const balanceDelta = transaction.assetBalanceDeltas.get(assetId);
            if (balanceDelta === undefined) {
                continue;
            }
            delta += balanceDelta;
            count++;
        }
        return { delta, count };
    }
    async getPendingDeltas(headSequence, tx) {
        const pendingByAsset = new buffer_map_1.BufferMap();
        for await (const transaction of this.getPendingTransactions(headSequence, tx)) {
            for (const [assetId, assetDelta] of transaction.assetBalanceDeltas.entries()) {
                const { delta, count } = pendingByAsset.get(assetId) ?? { delta: 0n, count: 0 };
                pendingByAsset.set(assetId, { delta: delta + assetDelta, count: count + 1 });
            }
        }
        return pendingByAsset;
    }
    async getUnconfirmedDelta(headSequence, confirmations, assetId, tx) {
        let delta = 0n;
        let count = 0;
        if (confirmations > 0) {
            const unconfirmedSequenceEnd = headSequence;
            const unconfirmedSequenceStart = Math.max(unconfirmedSequenceEnd - confirmations, block_1.GENESIS_BLOCK_SEQUENCE) + 1;
            for await (const transaction of this.walletDb.loadTransactionsInSequenceRange(this, unconfirmedSequenceStart, unconfirmedSequenceEnd, tx)) {
                const balanceDelta = transaction.assetBalanceDeltas.get(assetId);
                if (balanceDelta === undefined) {
                    continue;
                }
                count++;
                delta += balanceDelta;
            }
        }
        return {
            delta,
            count,
        };
    }
    async getUnconfirmedDeltas(headSequence, confirmations, tx) {
        const unconfirmedByAsset = new buffer_map_1.BufferMap();
        if (confirmations > 0) {
            const unconfirmedSequenceEnd = headSequence;
            const unconfirmedSequenceStart = Math.max(unconfirmedSequenceEnd - confirmations + 1, block_1.GENESIS_BLOCK_SEQUENCE);
            for await (const transaction of this.walletDb.loadTransactionsInSequenceRange(this, unconfirmedSequenceStart, unconfirmedSequenceEnd, tx)) {
                for (const [assetId, assetDelta] of transaction.assetBalanceDeltas.entries()) {
                    const { delta, count } = unconfirmedByAsset.get(assetId) ?? { delta: 0n, count: 0 };
                    unconfirmedByAsset.set(assetId, { delta: delta + assetDelta, count: count + 1 });
                }
            }
        }
        return unconfirmedByAsset;
    }
    async calculateAvailableBalance(headSequence, assetId, confirmations, tx) {
        let available = 0n;
        const maxConfirmedSequence = Math.max(headSequence - confirmations, block_1.GENESIS_BLOCK_SEQUENCE);
        for await (const value of this.walletDb.loadUnspentNoteValues(this, assetId, maxConfirmedSequence, tx)) {
            available += value;
        }
        return available;
    }
    async getUnconfirmedBalances(tx) {
        const unconfirmedBalances = new buffer_map_1.BufferMap();
        for await (const { assetId, balance } of this.walletDb.getUnconfirmedBalances(this, tx)) {
            unconfirmedBalances.set(assetId, balance);
        }
        return unconfirmedBalances;
    }
    async getUnconfirmedBalance(assetId, tx) {
        return this.walletDb.getUnconfirmedBalance(this, assetId, tx);
    }
    async updateUnconfirmedBalances(balanceDeltas, blockHash, sequence, tx) {
        const unconfirmedBalances = await this.getUnconfirmedBalances(tx);
        for await (const [assetId, balance] of unconfirmedBalances.entries()) {
            const balanceDelta = balanceDeltas.get(assetId) ?? 0n;
            await this.walletDb.saveUnconfirmedBalance(this, assetId, {
                unconfirmed: balance.unconfirmed + balanceDelta,
                blockHash,
                sequence,
            }, tx);
        }
        for (const [assetId, balanceDelta] of balanceDeltas.entries()) {
            if (unconfirmedBalances.has(assetId)) {
                continue;
            }
            await this.walletDb.saveUnconfirmedBalance(this, assetId, {
                unconfirmed: balanceDelta,
                blockHash,
                sequence,
            }, tx);
        }
    }
    async saveUnconfirmedBalance(assetId, balance, tx) {
        await this.walletDb.saveUnconfirmedBalance(this, assetId, balance, tx);
    }
    async getHead(tx) {
        return this.walletDb.getHead(this, tx);
    }
    async updateHead(head, tx) {
        await this.walletDb.saveHead(this, head, tx);
    }
    async updateCreatedAt(createdAt, tx) {
        this.createdAt = createdAt;
        await this.walletDb.setAccount(this, tx);
    }
    async getTransactionNotes(transaction) {
        const notes = [];
        for (const note of transaction.notes) {
            const noteHash = note.hash();
            const decryptedNote = await this.getDecryptedNote(noteHash);
            if (decryptedNote) {
                notes.push({
                    ...decryptedNote,
                    hash: noteHash,
                });
            }
        }
        return notes;
    }
}
exports.Account = Account;
function calculateAccountPrefix(id) {
    const seed = 1;
    const hash = new imurmurhash_1.default(id, seed).result();
    const prefix = Buffer.alloc(4);
    prefix.writeUInt32BE(hash);
    return prefix;
}
exports.calculateAccountPrefix = calculateAccountPrefix;
//# sourceMappingURL=account.js.map