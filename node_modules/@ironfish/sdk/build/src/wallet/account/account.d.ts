/// <reference types="node" />
import { BufferMap } from 'buffer-map';
import { Transaction } from '../../primitives';
import { DatabaseKeyRange, IDatabaseTransaction } from '../../storage';
import { WithNonNull } from '../../utils';
import { DecryptedNote } from '../../workerPool/tasks/decryptNotes';
import { AssetBalances } from '../assetBalances';
import { WalletBlockHeader } from '../remoteChainProcessor';
import { AccountValue } from '../walletdb/accountValue';
import { AssetValue } from '../walletdb/assetValue';
import { BalanceValue } from '../walletdb/balanceValue';
import { DecryptedNoteValue } from '../walletdb/decryptedNoteValue';
import { HeadValue } from '../walletdb/headValue';
import { TransactionValue } from '../walletdb/transactionValue';
import { WalletDB } from '../walletdb/walletdb';
export declare const ACCOUNT_KEY_LENGTH = 32;
export declare const ACCOUNT_SCHEMA_VERSION = 2;
export declare type SpendingAccount = WithNonNull<Account, 'spendingKey'>;
export declare function AssertSpending(account: Account): asserts account is SpendingAccount;
export declare class Account {
    private readonly walletDb;
    readonly id: string;
    readonly displayName: string;
    name: string;
    readonly spendingKey: string | null;
    readonly viewKey: string;
    readonly incomingViewKey: string;
    readonly outgoingViewKey: string;
    readonly version: number;
    publicAddress: string;
    createdAt: HeadValue | null;
    readonly prefix: Buffer;
    readonly prefixRange: DatabaseKeyRange;
    constructor({ id, name, publicAddress, walletDb, spendingKey, viewKey, incomingViewKey, outgoingViewKey, version, createdAt, }: AccountValue & {
        walletDb: WalletDB;
    });
    isSpendingAccount(): this is SpendingAccount;
    serialize(): AccountValue;
    setName(name: string, tx?: IDatabaseTransaction): Promise<void>;
    getNotes(keyRange?: DatabaseKeyRange): AsyncGenerator<DecryptedNoteValue & {
        hash: Buffer;
    }>;
    getUnspentNotes(assetId: Buffer, options?: {
        confirmations?: number;
    }): AsyncGenerator<DecryptedNoteValue>;
    getDecryptedNote(hash: Buffer, tx?: IDatabaseTransaction): Promise<DecryptedNoteValue | undefined>;
    connectTransaction(blockHeader: WalletBlockHeader, transaction: Transaction, decryptedNotes: Array<DecryptedNote>, tx?: IDatabaseTransaction): Promise<AssetBalances>;
    saveAssetFromChain(createdTransactionHash: Buffer, id: Buffer, metadata: Buffer, name: Buffer, nonce: number, creator: Buffer, owner: Buffer, blockHeader?: {
        hash: Buffer | null;
        sequence: number | null;
    }, tx?: IDatabaseTransaction): Promise<void>;
    updateAssetWithBlockHeader(assetValue: AssetValue, blockHeader: {
        hash: Buffer;
        sequence: number;
    }, tx?: IDatabaseTransaction): Promise<void>;
    saveMintsToAssetsStore({ blockHash, sequence, transaction }: TransactionValue, tx?: IDatabaseTransaction): Promise<void>;
    saveConnectedBurnsToAssetsStore(transaction: Transaction, tx?: IDatabaseTransaction): Promise<void>;
    private deleteDisconnectedBurnsFromAssetsStore;
    private deleteDisconnectedMintsFromAssetsStore;
    addPendingTransaction(transaction: Transaction, decryptedNotes: Array<DecryptedNote>, submittedSequence: number, tx?: IDatabaseTransaction): Promise<void>;
    disconnectTransaction(blockHeader: WalletBlockHeader, transaction: Transaction, tx?: IDatabaseTransaction): Promise<AssetBalances>;
    deleteTransaction(transaction: Transaction, tx?: IDatabaseTransaction): Promise<void>;
    private deleteDecryptedNote;
    getNoteHash(nullifier: Buffer, tx?: IDatabaseTransaction): Promise<Buffer | undefined>;
    getTransaction(hash: Buffer, tx?: IDatabaseTransaction): Promise<Readonly<TransactionValue> | undefined>;
    getAsset(id: Buffer, tx?: IDatabaseTransaction): Promise<Readonly<AssetValue> | undefined>;
    hasTransaction(hash: Buffer, tx?: IDatabaseTransaction): Promise<boolean>;
    hasPendingTransaction(hash: Buffer, tx?: IDatabaseTransaction): Promise<boolean>;
    getTransactions(range?: DatabaseKeyRange, tx?: IDatabaseTransaction): AsyncGenerator<Readonly<TransactionValue>>;
    getTransactionsByTime(tx?: IDatabaseTransaction, options?: {
        reverse?: boolean;
    }): AsyncGenerator<Readonly<TransactionValue>>;
    getTransactionsBySequence(sequence: number, tx?: IDatabaseTransaction): AsyncGenerator<Readonly<TransactionValue>>;
    getTransactionsOrderedBySequence(tx?: IDatabaseTransaction): AsyncGenerator<Readonly<TransactionValue>>;
    getPendingTransactions(headSequence: number, tx?: IDatabaseTransaction): AsyncGenerator<TransactionValue>;
    getExpiredTransactions(headSequence: number, tx?: IDatabaseTransaction): AsyncGenerator<TransactionValue>;
    expireTransaction(transaction: Transaction, tx?: IDatabaseTransaction): Promise<void>;
    private deleteCreatedAssetsFromTransaction;
    getAssets(tx?: IDatabaseTransaction): AsyncGenerator<Readonly<AssetValue>>;
    getBalances(confirmations: number, tx?: IDatabaseTransaction): AsyncGenerator<{
        assetId: Buffer;
        unconfirmed: bigint;
        unconfirmedCount: number;
        confirmed: bigint;
        pending: bigint;
        pendingCount: number;
        available: bigint;
        blockHash: Buffer | null;
        sequence: number | null;
    }>;
    /**
     * Gets the balance for an account
     * unconfirmed: all notes on the chain
     * confirmed: confirmed balance minus transactions in unconfirmed range
     */
    getBalance(assetId: Buffer, confirmations: number, tx?: IDatabaseTransaction): Promise<{
        unconfirmed: bigint;
        unconfirmedCount: number;
        confirmed: bigint;
        pending: bigint;
        pendingCount: number;
        available: bigint;
        blockHash: Buffer | null;
        sequence: number | null;
    }>;
    private getPendingDelta;
    private getPendingDeltas;
    private getUnconfirmedDelta;
    private getUnconfirmedDeltas;
    calculateAvailableBalance(headSequence: number, assetId: Buffer, confirmations: number, tx?: IDatabaseTransaction): Promise<bigint>;
    getUnconfirmedBalances(tx?: IDatabaseTransaction): Promise<BufferMap<BalanceValue>>;
    getUnconfirmedBalance(assetId: Buffer, tx?: IDatabaseTransaction): Promise<BalanceValue>;
    updateUnconfirmedBalances(balanceDeltas: BufferMap<bigint>, blockHash: Buffer | null, sequence: number | null, tx?: IDatabaseTransaction): Promise<void>;
    saveUnconfirmedBalance(assetId: Buffer, balance: BalanceValue, tx?: IDatabaseTransaction): Promise<void>;
    getHead(tx?: IDatabaseTransaction): Promise<HeadValue | null>;
    updateHead(head: HeadValue | null, tx?: IDatabaseTransaction): Promise<void>;
    updateCreatedAt(createdAt: HeadValue | null, tx?: IDatabaseTransaction): Promise<void>;
    getTransactionNotes(transaction: Transaction): Promise<Array<DecryptedNoteValue & {
        hash: Buffer;
    }>>;
}
export declare function calculateAccountPrefix(id: string): Buffer;
//# sourceMappingURL=account.d.ts.map