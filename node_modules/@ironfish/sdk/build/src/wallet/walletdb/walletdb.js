"use strict";
/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/. */
Object.defineProperty(exports, "__esModule", { value: true });
exports.WalletDB = void 0;
const rust_nodejs_1 = require("@ironfish/rust-nodejs");
const assert_1 = require("../../assert");
const block_1 = require("../../primitives/block");
const storage_1 = require("../../storage");
const utils_1 = require("../../storage/database/utils");
const utils_2 = require("../../storage/utils");
const utils_3 = require("../../utils");
const account_1 = require("../account/account");
const accountValue_1 = require("./accountValue");
const assetValue_1 = require("./assetValue");
const balanceValue_1 = require("./balanceValue");
const decryptedNoteValue_1 = require("./decryptedNoteValue");
const headValue_1 = require("./headValue");
const metaValue_1 = require("./metaValue");
const transactionValue_1 = require("./transactionValue");
const VERSION_DATABASE_ACCOUNTS = 29;
const getAccountsDBMetaDefaults = () => ({
    defaultAccountId: null,
});
class WalletDB {
    constructor({ files, location, workerPool, }) {
        this.files = files;
        this.location = location;
        this.workerPool = workerPool;
        this.db = utils_2.createDB({ location });
        this.meta = this.db.addStore({
            name: 'm',
            keyEncoding: new storage_1.StringEncoding(),
            valueEncoding: new metaValue_1.MetaValueEncoding(),
        });
        this.heads = this.db.addStore({
            name: 'h',
            keyEncoding: new storage_1.StringEncoding(),
            valueEncoding: new headValue_1.NullableHeadValueEncoding(),
        });
        this.accounts = this.db.addStore({
            name: 'a',
            keyEncoding: new storage_1.StringEncoding(),
            valueEncoding: new accountValue_1.AccountValueEncoding(),
        });
        this.balances = this.db.addStore({
            name: 'b',
            keyEncoding: new storage_1.PrefixEncoding(new storage_1.BufferEncoding(), new storage_1.BufferEncoding(), 4),
            valueEncoding: new balanceValue_1.BalanceValueEncoding(),
        });
        this.decryptedNotes = this.db.addStore({
            name: 'd',
            keyEncoding: new storage_1.PrefixEncoding(new storage_1.BufferEncoding(), new storage_1.BufferEncoding(), 4),
            valueEncoding: new decryptedNoteValue_1.DecryptedNoteValueEncoding(),
        });
        this.nullifierToNoteHash = this.db.addStore({
            name: 'n',
            keyEncoding: new storage_1.PrefixEncoding(new storage_1.BufferEncoding(), new storage_1.BufferEncoding(), 4),
            valueEncoding: new storage_1.BufferEncoding(),
        });
        this.sequenceToNoteHash = this.db.addStore({
            name: 'SN',
            keyEncoding: new storage_1.PrefixEncoding(new storage_1.BufferEncoding(), new storage_1.PrefixEncoding(storage_1.U32_ENCODING_BE, new storage_1.BufferEncoding(), 4), 4),
            valueEncoding: storage_1.NULL_ENCODING,
        });
        this.nonChainNoteHashes = this.db.addStore({
            name: 'S',
            keyEncoding: new storage_1.PrefixEncoding(new storage_1.BufferEncoding(), new storage_1.BufferEncoding(), 4),
            valueEncoding: storage_1.NULL_ENCODING,
        });
        this.transactions = this.db.addStore({
            name: 't',
            keyEncoding: new storage_1.PrefixEncoding(new storage_1.BufferEncoding(), new storage_1.BufferEncoding(), 4),
            valueEncoding: new transactionValue_1.TransactionValueEncoding(),
        });
        this.sequenceToTransactionHash = this.db.addStore({
            name: 'ST',
            keyEncoding: new storage_1.PrefixEncoding(new storage_1.BufferEncoding(), new storage_1.PrefixEncoding(storage_1.U32_ENCODING_BE, new storage_1.BufferEncoding(), 4), 4),
            valueEncoding: storage_1.NULL_ENCODING,
        });
        this.pendingTransactionHashes = this.db.addStore({
            name: 'PT',
            keyEncoding: new storage_1.PrefixEncoding(new storage_1.BufferEncoding(), new storage_1.PrefixEncoding(storage_1.U32_ENCODING_BE, new storage_1.BufferEncoding(), 4), 4),
            valueEncoding: storage_1.NULL_ENCODING,
        });
        this.accountIdsToCleanup = this.db.addStore({
            name: 'A',
            keyEncoding: new storage_1.StringEncoding(),
            valueEncoding: storage_1.NULL_ENCODING,
        });
        this.timestampToTransactionHash = this.db.addStore({
            name: 'TT',
            keyEncoding: new storage_1.PrefixEncoding(new storage_1.BufferEncoding(), new storage_1.PrefixEncoding(storage_1.U64_ENCODING, new storage_1.BufferEncoding(), 8), 4),
            valueEncoding: storage_1.NULL_ENCODING,
        });
        this.assets = this.db.addStore({
            name: 'as',
            keyEncoding: new storage_1.PrefixEncoding(new storage_1.BufferEncoding(), new storage_1.BufferEncoding(), 4),
            valueEncoding: new assetValue_1.AssetValueEncoding(),
        });
        this.nullifierToTransactionHash = this.db.addStore({
            name: 'nt',
            keyEncoding: new storage_1.PrefixEncoding(new storage_1.BufferEncoding(), new storage_1.BufferEncoding(), 4),
            valueEncoding: new storage_1.BufferEncoding(),
        });
        this.unspentNoteHashes = this.db.addStore({
            name: 'un',
            keyEncoding: new storage_1.PrefixEncoding(new storage_1.BufferEncoding(), // account prefix
            new storage_1.PrefixEncoding(new storage_1.BufferEncoding(), // asset ID
            new storage_1.PrefixEncoding(storage_1.U32_ENCODING_BE, // sequence
            new storage_1.PrefixEncoding(new storage_1.BigU64BEEncoding(), // value
            new storage_1.BufferEncoding(), // note hash
            8), 4), 32), 4),
            valueEncoding: storage_1.NULL_ENCODING,
        });
        // IDatabaseStores that cache and index decrypted chain data
        this.cacheStores = [
            this.decryptedNotes,
            this.nullifierToNoteHash,
            this.sequenceToNoteHash,
            this.nonChainNoteHashes,
            this.transactions,
            this.sequenceToTransactionHash,
            this.pendingTransactionHashes,
            this.timestampToTransactionHash,
            this.assets,
            this.nullifierToTransactionHash,
            this.unspentNoteHashes,
        ];
    }
    async open() {
        await this.files.mkdir(this.location, { recursive: true });
        await this.db.open();
        await this.db.upgrade(VERSION_DATABASE_ACCOUNTS);
    }
    async close() {
        await this.db.close();
    }
    async setAccount(account, tx) {
        await this.db.withTransaction(tx, async (tx) => {
            await this.accounts.put(account.id, account.serialize(), tx);
            const nativeUnconfirmedBalance = await this.balances.get([account.prefix, rust_nodejs_1.Asset.nativeId()], tx);
            if (nativeUnconfirmedBalance === undefined) {
                await this.saveUnconfirmedBalance(account, rust_nodejs_1.Asset.nativeId(), {
                    unconfirmed: 0n,
                    blockHash: null,
                    sequence: null,
                }, tx);
            }
        });
    }
    async removeAccount(account, tx) {
        await this.db.withTransaction(tx, async (tx) => {
            await this.accounts.del(account.id, tx);
            await this.clearBalance(account, tx);
            await this.accountIdsToCleanup.put(account.id, null, tx);
        });
    }
    async setDefaultAccount(id, tx) {
        await this.db.withTransaction(tx, async (tx) => {
            await this.meta.put('defaultAccountId', id, tx);
        });
    }
    async loadAccountsMeta(tx) {
        const meta = { ...getAccountsDBMetaDefaults() };
        await this.db.withTransaction(tx, async (tx) => {
            for await (const [key, value] of this.meta.getAllIter(tx)) {
                meta[key] = value;
            }
        });
        return meta;
    }
    async *loadAccounts(tx) {
        for await (const account of this.accounts.getAllValuesIter(tx)) {
            yield account;
        }
    }
    async getHead(account, tx) {
        const head = await this.heads.get(account.id, tx);
        assert_1.Assert.isNotUndefined(head);
        return head;
    }
    async saveHead(account, head, tx) {
        await this.heads.put(account.id, head, tx);
    }
    async removeHead(account, tx) {
        await this.heads.del(account.id, tx);
    }
    async *loadHeads(tx) {
        for await (const [accountId, head] of this.heads.getAllIter(tx)) {
            yield { accountId, head };
        }
    }
    async saveTransaction(account, transactionHash, transactionValue, tx) {
        const expiration = transactionValue.transaction.expiration();
        await this.db.withTransaction(tx, async (tx) => {
            if (transactionValue.sequence !== null) {
                await this.pendingTransactionHashes.del([account.prefix, [expiration, transactionHash]], tx);
                await this.sequenceToTransactionHash.put([account.prefix, [transactionValue.sequence, transactionHash]], null, tx);
            }
            else {
                await this.pendingTransactionHashes.put([account.prefix, [expiration, transactionHash]], null, tx);
            }
            await this.transactions.put([account.prefix, transactionHash], transactionValue, tx);
            await this.timestampToTransactionHash.put([account.prefix, [transactionValue.timestamp.getTime(), transactionHash]], null, tx);
        });
    }
    async deleteTransaction(account, transactionHash, tx) {
        const transaction = await this.loadTransaction(account, transactionHash, tx);
        assert_1.Assert.isNotUndefined(transaction);
        await this.timestampToTransactionHash.del([account.prefix, [transaction.timestamp.getTime(), transactionHash]], tx);
        await this.transactions.del([account.prefix, transactionHash], tx);
    }
    async clearTransactions(account, tx) {
        await this.transactions.clear(tx, account.prefixRange);
        await this.timestampToTransactionHash.clear(tx, account.prefixRange);
    }
    async clearSequenceToNoteHash(account, tx) {
        await this.sequenceToNoteHash.clear(tx, account.prefixRange);
    }
    async clearNonChainNoteHashes(account, tx) {
        await this.nonChainNoteHashes.clear(tx, account.prefixRange);
    }
    async *getTransactionHashesBySequence(account, tx) {
        for await (const [, [sequence, hash]] of this.sequenceToTransactionHash.getAllKeysIter(tx, account.prefixRange, { ordered: true })) {
            yield { sequence, hash };
        }
    }
    async *loadTransactions(account, range, tx) {
        const gte = utils_3.BufferUtils.maxNullable(account.prefixRange.gte, range?.gte);
        const lt = utils_3.BufferUtils.minNullable(account.prefixRange.lt, range?.lt);
        for await (const transactionValue of this.transactions.getAllValuesIter(tx, { gte, lt })) {
            yield transactionValue;
        }
    }
    async loadTransaction(account, transactionHash, tx) {
        return this.transactions.get([account.prefix, transactionHash], tx);
    }
    async hasTransaction(account, transactionHash, tx) {
        return this.transactions.has([account.prefix, transactionHash], tx);
    }
    async hasPendingTransaction(account, transactionHash, tx) {
        const transactionValue = await this.transactions.get([account.prefix, transactionHash], tx);
        if (transactionValue === undefined) {
            return false;
        }
        const expiration = transactionValue.transaction.expiration();
        return this.pendingTransactionHashes.has([account.prefix, [expiration, transactionHash]], tx);
    }
    async setNoteHashSequence(account, noteHash, sequence, tx) {
        await this.db.withTransaction(tx, async (tx) => {
            if (sequence) {
                await this.sequenceToNoteHash.put([account.prefix, [sequence, noteHash]], null, tx);
                await this.nonChainNoteHashes.del([account.prefix, noteHash], tx);
            }
            else {
                await this.nonChainNoteHashes.put([account.prefix, noteHash], null, tx);
            }
        });
    }
    async disconnectNoteHashSequence(account, noteHash, sequence, tx) {
        await this.db.withTransaction(tx, async (tx) => {
            await this.sequenceToNoteHash.del([account.prefix, [sequence, noteHash]], tx);
            await this.nonChainNoteHashes.put([account.prefix, noteHash], null, tx);
        });
    }
    async deleteNoteHashSequence(account, noteHash, sequence, tx) {
        await this.db.withTransaction(tx, async (tx) => {
            await this.nonChainNoteHashes.del([account.prefix, noteHash], tx);
            if (sequence !== null) {
                await this.sequenceToNoteHash.del([account.prefix, [sequence, noteHash]], tx);
            }
        });
    }
    /*
     * clears sequenceToNoteHash entries for all accounts for a given sequence
     */
    async clearSequenceNoteHashes(sequence, tx) {
        const encoding = this.sequenceToNoteHash.keyEncoding;
        const keyRange = utils_1.StorageUtils.getPrefixesKeyRange(encoding.serialize([Buffer.alloc(4, 0), [sequence, Buffer.alloc(0)]]), encoding.serialize([Buffer.alloc(4, 255), [sequence, Buffer.alloc(0)]]));
        await this.sequenceToNoteHash.clear(tx, keyRange);
    }
    async addUnspentNoteHash(account, noteHash, decryptedNote, tx) {
        const sequence = decryptedNote.sequence;
        if (sequence === null) {
            return;
        }
        const assetId = decryptedNote.note.assetId();
        const value = decryptedNote.note.value();
        await this.unspentNoteHashes.put([account.prefix, [assetId, [sequence, [value, noteHash]]]], null, tx);
    }
    async deleteUnspentNoteHash(account, noteHash, decryptedNote, tx) {
        const assetId = decryptedNote.note.assetId();
        const sequence = decryptedNote.sequence;
        const value = decryptedNote.note.value();
        assert_1.Assert.isNotNull(sequence, 'Cannot spend a note that is not on the chain.');
        await this.unspentNoteHashes.del([account.prefix, [assetId, [sequence, [value, noteHash]]]], tx);
    }
    async *loadUnspentNoteHashes(account, assetId, sequence, tx) {
        const encoding = new storage_1.PrefixEncoding(storage_1.BUFFER_ENCODING, new storage_1.PrefixEncoding(storage_1.BUFFER_ENCODING, storage_1.U32_ENCODING_BE, 32), 4);
        const maxConfirmedSequence = sequence ?? 2 ** 32 - 1;
        const range = utils_1.getPrefixesKeyRange(encoding.serialize([account.prefix, [assetId, 1]]), encoding.serialize([account.prefix, [assetId, maxConfirmedSequence]]));
        for await (const [, [, [, [_, noteHash]]]] of this.unspentNoteHashes.getAllKeysIter(tx, range)) {
            yield noteHash;
        }
    }
    async *loadUnspentNotes(account, assetId, sequence, tx) {
        for await (const noteHash of this.loadUnspentNoteHashes(account, assetId, sequence, tx)) {
            const decryptedNote = await this.decryptedNotes.get([account.prefix, noteHash], tx);
            if (decryptedNote !== undefined) {
                yield decryptedNote;
            }
        }
    }
    async *loadUnspentNoteValues(account, assetId, sequence, tx) {
        const encoding = new storage_1.PrefixEncoding(storage_1.BUFFER_ENCODING, new storage_1.PrefixEncoding(storage_1.BUFFER_ENCODING, storage_1.U32_ENCODING_BE, 32), 4);
        const maxConfirmedSequence = sequence ?? 2 ** 32 - 1;
        const range = utils_1.getPrefixesKeyRange(encoding.serialize([account.prefix, [assetId, 1]]), encoding.serialize([account.prefix, [assetId, maxConfirmedSequence]]));
        for await (const [, [, [, [value, _]]]] of this.unspentNoteHashes.getAllKeysIter(tx, range)) {
            yield value;
        }
    }
    async loadNoteHash(account, nullifier, tx) {
        return this.nullifierToNoteHash.get([account.prefix, nullifier], tx);
    }
    async saveNullifierNoteHash(account, nullifier, noteHash, tx) {
        await this.nullifierToNoteHash.put([account.prefix, nullifier], noteHash, tx);
    }
    async *loadNullifierToNoteHash(account, tx) {
        for await (const [[_, nullifier], noteHash] of this.nullifierToNoteHash.getAllIter(tx, account.prefixRange)) {
            yield {
                nullifier,
                noteHash,
            };
        }
    }
    async deleteNullifier(account, nullifier, tx) {
        await this.nullifierToNoteHash.del([account.prefix, nullifier], tx);
    }
    async clearNullifierToNoteHash(account, tx) {
        await this.nullifierToNoteHash.clear(tx, account.prefixRange);
    }
    async replaceNullifierToNoteHash(account, map, tx) {
        await this.db.withTransaction(tx, async (tx) => {
            await this.clearNullifierToNoteHash(account, tx);
            for (const [key, value] of map) {
                await this.nullifierToNoteHash.put([account.prefix, key], value, tx);
            }
        });
    }
    async saveDecryptedNote(account, noteHash, note, tx) {
        await this.db.withTransaction(tx, async (tx) => {
            if (note.nullifier) {
                await this.nullifierToNoteHash.put([account.prefix, note.nullifier], noteHash, tx);
            }
            await this.setNoteHashSequence(account, noteHash, note.sequence, tx);
            await this.decryptedNotes.put([account.prefix, noteHash], note, tx);
        });
    }
    async loadDecryptedNote(account, noteHash, tx) {
        return await this.decryptedNotes.get([account.prefix, noteHash], tx);
    }
    async *loadNoteHashesNotOnChain(account, tx) {
        for await (const [, noteHash] of this.nonChainNoteHashes.getAllKeysIter(tx, account.prefixRange)) {
            yield noteHash;
        }
    }
    async *loadNotesNotOnChain(account, tx) {
        for await (const noteHash of this.loadNoteHashesNotOnChain(account, tx)) {
            const note = await this.loadDecryptedNote(account, noteHash, tx);
            if (note) {
                yield note;
            }
        }
    }
    async *loadNoteHashesInSequenceRange(account, start, end, tx) {
        const encoding = new storage_1.PrefixEncoding(storage_1.BUFFER_ENCODING, storage_1.U32_ENCODING_BE, account.prefix.byteLength);
        const range = utils_1.StorageUtils.getPrefixesKeyRange(encoding.serialize([account.prefix, start]), encoding.serialize([account.prefix, end]));
        for await (const [, [, noteHash]] of this.sequenceToNoteHash.getAllKeysIter(tx, range)) {
            yield noteHash;
        }
    }
    async *loadNotesInSequenceRange(account, start, end, tx) {
        for await (const noteHash of this.loadNoteHashesInSequenceRange(account, start, end, tx)) {
            const note = await this.loadDecryptedNote(account, noteHash, tx);
            if (note) {
                yield { ...note, hash: noteHash };
            }
        }
    }
    async *loadTransactionHashesInSequenceRange(account, start, end, tx) {
        const encoding = new storage_1.PrefixEncoding(storage_1.BUFFER_ENCODING, storage_1.U32_ENCODING_BE, account.prefix.byteLength);
        const range = utils_1.StorageUtils.getPrefixesKeyRange(encoding.serialize([account.prefix, start]), encoding.serialize([account.prefix, end]));
        for await (const [, [, transactionHash]] of this.sequenceToTransactionHash.getAllKeysIter(tx, range)) {
            yield transactionHash;
        }
    }
    async *loadTransactionsInSequenceRange(account, start, end, tx) {
        for await (const transactionHash of this.loadTransactionHashesInSequenceRange(account, start, end, tx)) {
            const transaction = await this.loadTransaction(account, transactionHash, tx);
            if (transaction) {
                yield { ...transaction, hash: transactionHash };
            }
        }
    }
    async deleteDecryptedNote(account, noteHash, tx) {
        await this.decryptedNotes.del([account.prefix, noteHash], tx);
    }
    async clearDecryptedNotes(account, tx) {
        await this.decryptedNotes.clear(tx, account.prefixRange);
    }
    async *loadDecryptedNotes(account, range, tx) {
        const gte = utils_3.BufferUtils.maxNullable(account.prefixRange.gte, range?.gte);
        const lt = utils_3.BufferUtils.minNullable(account.prefixRange.lt, range?.lt);
        for await (const [key, decryptedNote] of this.decryptedNotes.getAllIter(tx, {
            gte,
            lt,
        })) {
            const [, hash] = key;
            yield {
                ...decryptedNote,
                hash,
            };
        }
    }
    async getUnconfirmedBalance(account, assetId, tx) {
        const unconfirmedBalance = await this.balances.get([account.prefix, assetId], tx);
        return (unconfirmedBalance ?? {
            unconfirmed: 0n,
            blockHash: null,
            sequence: null,
        });
    }
    async *getUnconfirmedBalances(account, tx) {
        for await (const [[_, assetId], balance] of this.balances.getAllIter(tx, account.prefixRange)) {
            yield { assetId, balance };
        }
    }
    async saveUnconfirmedBalance(account, assetId, balance, tx) {
        await this.balances.put([account.prefix, assetId], balance, tx);
    }
    async clearBalance(account, tx) {
        await this.balances.clear(tx, account.prefixRange);
    }
    async *loadExpiredTransactionHashes(account, headSequence, tx) {
        const encoding = this.pendingTransactionHashes.keyEncoding;
        const expiredRange = utils_1.StorageUtils.getPrefixesKeyRange(encoding.serialize([account.prefix, [1, Buffer.alloc(0)]]), encoding.serialize([account.prefix, [headSequence, Buffer.alloc(0)]]));
        for await (const [, [, transactionHash]] of this.pendingTransactionHashes.getAllKeysIter(tx, expiredRange)) {
            yield transactionHash;
        }
    }
    async *loadExpiredTransactions(account, headSequence, tx) {
        for await (const transactionHash of this.loadExpiredTransactionHashes(account, headSequence, tx)) {
            const transaction = await this.loadTransaction(account, transactionHash, tx);
            assert_1.Assert.isNotUndefined(transaction);
            yield transaction;
        }
    }
    async *loadPendingTransactionHashes(account, headSequence, tx) {
        const encoding = this.pendingTransactionHashes.keyEncoding;
        const noExpirationRange = utils_1.StorageUtils.getPrefixKeyRange(encoding.serialize([account.prefix, [0, Buffer.alloc(0)]]));
        for await (const [, [, transactionHash]] of this.pendingTransactionHashes.getAllKeysIter(tx, noExpirationRange)) {
            yield transactionHash;
        }
        const pendingRange = utils_1.StorageUtils.getPrefixesKeyRange(encoding.serialize([account.prefix, [headSequence + 1, Buffer.alloc(0)]]), encoding.serialize([account.prefix, [2 ** 32 - 1, Buffer.alloc(0)]]));
        for await (const [, [, transactionHash]] of this.pendingTransactionHashes.getAllKeysIter(tx, pendingRange)) {
            yield transactionHash;
        }
    }
    async *loadPendingTransactions(account, headSequence, tx) {
        for await (const transactionHash of this.loadPendingTransactionHashes(account, headSequence, tx)) {
            const transaction = await this.loadTransaction(account, transactionHash, tx);
            assert_1.Assert.isNotUndefined(transaction);
            yield transaction;
        }
    }
    async saveSequenceToTransactionHash(account, sequence, transactionHash, tx) {
        await this.sequenceToTransactionHash.put([account.prefix, [sequence, transactionHash]], null, tx);
    }
    async deleteSequenceToTransactionHash(account, sequence, transactionHash, tx) {
        await this.sequenceToTransactionHash.del([account.prefix, [sequence, transactionHash]], tx);
    }
    async savePendingTransactionHash(account, expiration, transactionHash, tx) {
        await this.pendingTransactionHashes.put([account.prefix, [expiration, transactionHash]], null, tx);
    }
    async deletePendingTransactionHash(account, expiration, transactionHash, tx) {
        await this.pendingTransactionHashes.del([account.prefix, [expiration, transactionHash]], tx);
    }
    async clearPendingTransactionHashes(account, tx) {
        await this.pendingTransactionHashes.clear(tx, account.prefixRange);
    }
    async forceCleanupDeletedAccounts(signal) {
        return this.cleanupDeletedAccounts(Number.POSITIVE_INFINITY, signal);
    }
    async cleanupDeletedAccounts(recordsToCleanup, signal) {
        for (const [accountId] of await this.accountIdsToCleanup.getAll()) {
            const prefix = account_1.calculateAccountPrefix(accountId);
            const range = utils_1.StorageUtils.getPrefixKeyRange(prefix);
            for (const store of this.cacheStores) {
                for await (const key of store.getAllKeysIter(undefined, range)) {
                    if (signal?.aborted === true || recordsToCleanup === 0) {
                        return;
                    }
                    await store.del(key);
                    recordsToCleanup--;
                }
            }
            await this.accountIdsToCleanup.del(accountId);
        }
    }
    async *loadTransactionsByTime(account, tx, options) {
        for await (const [, [, transactionHash]] of this.timestampToTransactionHash.getAllKeysIter(tx, account.prefixRange, {
            ordered: true,
            reverse: options?.reverse ?? true,
        })) {
            const transaction = await this.loadTransaction(account, transactionHash, tx);
            assert_1.Assert.isNotUndefined(transaction);
            yield transaction;
        }
    }
    async putAsset(account, assetId, assetValue, tx) {
        await this.assets.put([account.prefix, assetId], assetValue, tx);
    }
    async getAsset(account, assetId, tx) {
        if (assetId.equals(rust_nodejs_1.Asset.nativeId())) {
            return {
                createdTransactionHash: block_1.GENESIS_BLOCK_PREVIOUS,
                id: rust_nodejs_1.Asset.nativeId(),
                metadata: Buffer.from('Native asset of Iron Fish blockchain', 'utf8'),
                name: Buffer.from('$IRON', 'utf8'),
                nonce: 0,
                creator: Buffer.from('Iron Fish', 'utf8'),
                owner: Buffer.from('Iron Fish', 'utf8'),
                blockHash: null,
                sequence: null,
                supply: null,
            };
        }
        return this.assets.get([account.prefix, assetId], tx);
    }
    async *loadAssets(account, tx) {
        for await (const asset of this.assets.getAllValuesIter(tx, account.prefixRange, {
            ordered: true,
        })) {
            yield asset;
        }
    }
    async deleteAsset(account, assetId, tx) {
        await this.assets.del([account.prefix, assetId], tx);
    }
    async getTransactionHashFromNullifier(account, nullifier, tx) {
        return this.nullifierToTransactionHash.get([account.prefix, nullifier], tx);
    }
    async saveNullifierToTransactionHash(account, nullifier, transaction, tx) {
        await this.nullifierToTransactionHash.put([account.prefix, nullifier], transaction.hash(), tx);
    }
    async deleteNullifierToTransactionHash(account, nullifier, tx) {
        await this.nullifierToTransactionHash.del([account.prefix, nullifier], tx);
    }
}
exports.WalletDB = WalletDB;
//# sourceMappingURL=walletdb.js.map