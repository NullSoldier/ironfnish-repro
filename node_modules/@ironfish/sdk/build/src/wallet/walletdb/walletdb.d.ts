/// <reference types="node" />
import { BufferMap } from 'buffer-map';
import { FileSystem } from '../../fileSystems';
import { NoteEncryptedHash } from '../../primitives/noteEncrypted';
import { Nullifier } from '../../primitives/nullifier';
import { Transaction, TransactionHash } from '../../primitives/transaction';
import { DatabaseKeyRange, IDatabase, IDatabaseStore, IDatabaseTransaction } from '../../storage';
import { WorkerPool } from '../../workerPool';
import { Account } from '../account/account';
import { AccountValue } from './accountValue';
import { AssetValue } from './assetValue';
import { BalanceValue } from './balanceValue';
import { DecryptedNoteValue } from './decryptedNoteValue';
import { HeadValue } from './headValue';
import { AccountsDBMeta, MetaValue } from './metaValue';
import { TransactionValue } from './transactionValue';
export declare class WalletDB {
    db: IDatabase;
    workerPool: WorkerPool;
    location: string;
    files: FileSystem;
    accounts: IDatabaseStore<{
        key: string;
        value: AccountValue;
    }>;
    meta: IDatabaseStore<{
        key: keyof AccountsDBMeta;
        value: MetaValue;
    }>;
    heads: IDatabaseStore<{
        key: Account['id'];
        value: HeadValue | null;
    }>;
    balances: IDatabaseStore<{
        key: [Account['prefix'], Buffer];
        value: BalanceValue;
    }>;
    decryptedNotes: IDatabaseStore<{
        key: [Account['prefix'], NoteEncryptedHash];
        value: DecryptedNoteValue;
    }>;
    nullifierToNoteHash: IDatabaseStore<{
        key: [Account['prefix'], Nullifier];
        value: Buffer;
    }>;
    sequenceToNoteHash: IDatabaseStore<{
        key: [Account['prefix'], [number, Buffer]];
        value: null;
    }>;
    nonChainNoteHashes: IDatabaseStore<{
        key: [Account['prefix'], Buffer];
        value: null;
    }>;
    transactions: IDatabaseStore<{
        key: [Account['prefix'], TransactionHash];
        value: TransactionValue;
    }>;
    sequenceToTransactionHash: IDatabaseStore<{
        key: [Account['prefix'], [number, Buffer]];
        value: null;
    }>;
    pendingTransactionHashes: IDatabaseStore<{
        key: [Account['prefix'], [number, TransactionHash]];
        value: null;
    }>;
    accountIdsToCleanup: IDatabaseStore<{
        key: Account['id'];
        value: null;
    }>;
    timestampToTransactionHash: IDatabaseStore<{
        key: [Account['prefix'], [number, TransactionHash]];
        value: null;
    }>;
    assets: IDatabaseStore<{
        key: [Account['prefix'], Buffer];
        value: AssetValue;
    }>;
    nullifierToTransactionHash: IDatabaseStore<{
        key: [Account['prefix'], Buffer];
        value: TransactionHash;
    }>;
    unspentNoteHashes: IDatabaseStore<{
        key: [Account['prefix'], [Buffer, [number, [bigint, Buffer]]]];
        value: null;
    }>;
    cacheStores: IDatabaseStore<{
        key: Readonly<unknown>;
        value: unknown;
    }>[];
    constructor({ files, location, workerPool, }: {
        files: FileSystem;
        location: string;
        workerPool: WorkerPool;
    });
    open(): Promise<void>;
    close(): Promise<void>;
    setAccount(account: Account, tx?: IDatabaseTransaction): Promise<void>;
    removeAccount(account: Account, tx?: IDatabaseTransaction): Promise<void>;
    setDefaultAccount(id: AccountsDBMeta['defaultAccountId'], tx?: IDatabaseTransaction): Promise<void>;
    loadAccountsMeta(tx?: IDatabaseTransaction): Promise<AccountsDBMeta>;
    loadAccounts(tx?: IDatabaseTransaction): AsyncGenerator<AccountValue, void, unknown>;
    getHead(account: Account, tx?: IDatabaseTransaction): Promise<HeadValue | null>;
    saveHead(account: Account, head: HeadValue | null, tx?: IDatabaseTransaction): Promise<void>;
    removeHead(account: Account, tx?: IDatabaseTransaction): Promise<void>;
    loadHeads(tx?: IDatabaseTransaction): AsyncGenerator<{
        accountId: string;
        head: HeadValue | null;
    }, void, unknown>;
    saveTransaction(account: Account, transactionHash: Buffer, transactionValue: TransactionValue, tx?: IDatabaseTransaction): Promise<void>;
    deleteTransaction(account: Account, transactionHash: Buffer, tx?: IDatabaseTransaction): Promise<void>;
    clearTransactions(account: Account, tx?: IDatabaseTransaction): Promise<void>;
    clearSequenceToNoteHash(account: Account, tx?: IDatabaseTransaction): Promise<void>;
    clearNonChainNoteHashes(account: Account, tx?: IDatabaseTransaction): Promise<void>;
    getTransactionHashesBySequence(account: Account, tx?: IDatabaseTransaction): AsyncGenerator<{
        sequence: number;
        hash: Buffer;
    }>;
    loadTransactions(account: Account, range?: DatabaseKeyRange, tx?: IDatabaseTransaction): AsyncGenerator<TransactionValue>;
    loadTransaction(account: Account, transactionHash: Buffer, tx?: IDatabaseTransaction): Promise<TransactionValue | undefined>;
    hasTransaction(account: Account, transactionHash: Buffer, tx?: IDatabaseTransaction): Promise<boolean>;
    hasPendingTransaction(account: Account, transactionHash: Buffer, tx?: IDatabaseTransaction): Promise<boolean>;
    setNoteHashSequence(account: Account, noteHash: Buffer, sequence: number | null, tx?: IDatabaseTransaction): Promise<void>;
    disconnectNoteHashSequence(account: Account, noteHash: Buffer, sequence: number, tx?: IDatabaseTransaction): Promise<void>;
    deleteNoteHashSequence(account: Account, noteHash: Buffer, sequence: number | null, tx?: IDatabaseTransaction): Promise<void>;
    clearSequenceNoteHashes(sequence: number, tx?: IDatabaseTransaction): Promise<void>;
    addUnspentNoteHash(account: Account, noteHash: Buffer, decryptedNote: DecryptedNoteValue, tx?: IDatabaseTransaction): Promise<void>;
    deleteUnspentNoteHash(account: Account, noteHash: Buffer, decryptedNote: DecryptedNoteValue, tx?: IDatabaseTransaction): Promise<void>;
    loadUnspentNoteHashes(account: Account, assetId: Buffer, sequence?: number, tx?: IDatabaseTransaction): AsyncGenerator<Buffer>;
    loadUnspentNotes(account: Account, assetId: Buffer, sequence?: number, tx?: IDatabaseTransaction): AsyncGenerator<DecryptedNoteValue>;
    loadUnspentNoteValues(account: Account, assetId: Buffer, sequence?: number, tx?: IDatabaseTransaction): AsyncGenerator<bigint>;
    loadNoteHash(account: Account, nullifier: Buffer, tx?: IDatabaseTransaction): Promise<Buffer | undefined>;
    saveNullifierNoteHash(account: Account, nullifier: Buffer, noteHash: Buffer, tx?: IDatabaseTransaction): Promise<void>;
    loadNullifierToNoteHash(account: Account, tx?: IDatabaseTransaction): AsyncGenerator<{
        nullifier: Buffer;
        noteHash: Buffer;
    }>;
    deleteNullifier(account: Account, nullifier: Buffer, tx?: IDatabaseTransaction): Promise<void>;
    clearNullifierToNoteHash(account: Account, tx?: IDatabaseTransaction): Promise<void>;
    replaceNullifierToNoteHash(account: Account, map: BufferMap<Buffer>, tx?: IDatabaseTransaction): Promise<void>;
    saveDecryptedNote(account: Account, noteHash: Buffer, note: Readonly<DecryptedNoteValue>, tx?: IDatabaseTransaction): Promise<void>;
    loadDecryptedNote(account: Account, noteHash: Buffer, tx?: IDatabaseTransaction): Promise<DecryptedNoteValue | undefined>;
    loadNoteHashesNotOnChain(account: Account, tx?: IDatabaseTransaction): AsyncGenerator<Buffer>;
    loadNotesNotOnChain(account: Account, tx?: IDatabaseTransaction): AsyncGenerator<DecryptedNoteValue>;
    loadNoteHashesInSequenceRange(account: Account, start: number, end: number, tx?: IDatabaseTransaction): AsyncGenerator<Buffer>;
    loadNotesInSequenceRange(account: Account, start: number, end: number, tx?: IDatabaseTransaction): AsyncGenerator<DecryptedNoteValue & {
        hash: Buffer;
    }>;
    loadTransactionHashesInSequenceRange(account: Account, start: number, end: number, tx?: IDatabaseTransaction): AsyncGenerator<Buffer>;
    loadTransactionsInSequenceRange(account: Account, start: number, end: number, tx?: IDatabaseTransaction): AsyncGenerator<TransactionValue & {
        hash: Buffer;
    }>;
    deleteDecryptedNote(account: Account, noteHash: Buffer, tx?: IDatabaseTransaction): Promise<void>;
    clearDecryptedNotes(account: Account, tx?: IDatabaseTransaction): Promise<void>;
    loadDecryptedNotes(account: Account, range?: DatabaseKeyRange, tx?: IDatabaseTransaction): AsyncGenerator<DecryptedNoteValue & {
        hash: Buffer;
    }>;
    getUnconfirmedBalance(account: Account, assetId: Buffer, tx?: IDatabaseTransaction): Promise<BalanceValue>;
    getUnconfirmedBalances(account: Account, tx?: IDatabaseTransaction): AsyncGenerator<{
        assetId: Buffer;
        balance: BalanceValue;
    }>;
    saveUnconfirmedBalance(account: Account, assetId: Buffer, balance: BalanceValue, tx?: IDatabaseTransaction): Promise<void>;
    clearBalance(account: Account, tx?: IDatabaseTransaction): Promise<void>;
    loadExpiredTransactionHashes(account: Account, headSequence: number, tx?: IDatabaseTransaction): AsyncGenerator<Buffer>;
    loadExpiredTransactions(account: Account, headSequence: number, tx?: IDatabaseTransaction): AsyncGenerator<TransactionValue>;
    loadPendingTransactionHashes(account: Account, headSequence: number, tx?: IDatabaseTransaction): AsyncGenerator<Buffer>;
    loadPendingTransactions(account: Account, headSequence: number, tx?: IDatabaseTransaction): AsyncGenerator<TransactionValue>;
    saveSequenceToTransactionHash(account: Account, sequence: number, transactionHash: Buffer, tx?: IDatabaseTransaction): Promise<void>;
    deleteSequenceToTransactionHash(account: Account, sequence: number, transactionHash: Buffer, tx?: IDatabaseTransaction): Promise<void>;
    savePendingTransactionHash(account: Account, expiration: number, transactionHash: TransactionHash, tx?: IDatabaseTransaction): Promise<void>;
    deletePendingTransactionHash(account: Account, expiration: number, transactionHash: TransactionHash, tx?: IDatabaseTransaction): Promise<void>;
    clearPendingTransactionHashes(account: Account, tx?: IDatabaseTransaction): Promise<void>;
    forceCleanupDeletedAccounts(signal?: AbortSignal): Promise<void>;
    cleanupDeletedAccounts(recordsToCleanup: number, signal?: AbortSignal): Promise<void>;
    loadTransactionsByTime(account: Account, tx?: IDatabaseTransaction, options?: {
        reverse?: boolean;
    }): AsyncGenerator<TransactionValue>;
    putAsset(account: Account, assetId: Buffer, assetValue: AssetValue, tx?: IDatabaseTransaction): Promise<void>;
    getAsset(account: Account, assetId: Buffer, tx?: IDatabaseTransaction): Promise<AssetValue | undefined>;
    loadAssets(account: Account, tx?: IDatabaseTransaction): AsyncGenerator<AssetValue>;
    deleteAsset(account: Account, assetId: Buffer, tx?: IDatabaseTransaction): Promise<void>;
    getTransactionHashFromNullifier(account: Account, nullifier: Buffer, tx?: IDatabaseTransaction): Promise<Buffer | undefined>;
    saveNullifierToTransactionHash(account: Account, nullifier: Buffer, transaction: Transaction, tx?: IDatabaseTransaction): Promise<void>;
    deleteNullifierToTransactionHash(account: Account, nullifier: Buffer, tx?: IDatabaseTransaction): Promise<void>;
}
//# sourceMappingURL=walletdb.d.ts.map