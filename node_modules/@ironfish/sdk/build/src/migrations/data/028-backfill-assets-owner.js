"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Migration028 = void 0;
const utils_1 = require("../../storage/utils");
const migration_1 = require("../migration");
const stores_1 = require("./028-backfill-assets-owner/stores");
class Migration028 extends migration_1.Migration {
    constructor() {
        super(...arguments);
        this.path = __filename;
        this.database = migration_1.Database.BLOCKCHAIN;
    }
    prepare(node) {
        return utils_1.createDB({ location: node.config.chainDatabasePath });
    }
    async forward(node, db, tx, logger) {
        const stores = stores_1.GetStores(db);
        logger.info(`Migrating asset data to store owner`);
        for await (const assetValue of stores.old.assets.getAllValuesIter(tx)) {
            const assetName = assetValue.name.toString('utf8');
            const assetIdSlice = assetValue.id.toString('hex').substring(0, 10);
            logger.info(` Migrating asset ${assetIdSlice}... (${assetName})`);
            await stores.new.assets.put(assetValue.id, { ...assetValue, owner: assetValue.creator }, tx);
        }
    }
    async backward(node, db, tx, logger) {
        const stores = stores_1.GetStores(db);
        logger.info(`Reverting migration of asset data to store owner`);
        for await (const assetValue of stores.new.assets.getAllValuesIter(tx)) {
            const assetName = assetValue.name.toString('utf8');
            const assetIdSlice = assetValue.id.toString('hex').substring(0, 10);
            logger.info(` Reverting migration for asset ${assetIdSlice} (${assetName})`);
            const { owner: _, ...oldAssetValue } = assetValue;
            await stores.old.assets.put(assetValue.id, { ...oldAssetValue }, tx);
        }
    }
}
exports.Migration028 = Migration028;
//# sourceMappingURL=028-backfill-assets-owner.js.map