"use strict";
/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/. */
Object.defineProperty(exports, "__esModule", { value: true });
exports.Migration017 = void 0;
const storage_1 = require("../../storage");
const migration_1 = require("../migration");
const schemaOld_1 = require("./021-add-version-to-accounts/schemaOld");
class Migration017 extends migration_1.Migration {
    constructor() {
        super(...arguments);
        this.path = __filename;
        this.database = migration_1.Database.WALLET;
    }
    prepare(node) {
        return node.wallet.walletDb.db;
    }
    async forward(node, db, tx, logger) {
        const accounts = await schemaOld_1.GetOldAccounts(node, db, tx);
        logger.info(`Re-indexing transactions for ${accounts.length} accounts`);
        logger.info('');
        for (const account of accounts) {
            let transactionCount = 0;
            logger.info(`Indexing on-chain transactions for account ${account.name}`);
            for await (const transactionValue of account.getTransactions()) {
                await node.wallet.walletDb.saveTransaction(account, transactionValue.transaction.hash(), transactionValue);
                transactionCount++;
            }
            logger.info(` Indexed ${transactionCount} transactions for account ${account.name}`);
            logger.info('');
        }
        logger.info('Clearing data from old datastores...');
        const { sequenceToNoteHash, sequenceToTransactionHash, pendingTransactionHashes } = this.getOldStores(db);
        await sequenceToNoteHash.clear();
        await sequenceToTransactionHash.clear();
        await pendingTransactionHashes.clear();
    }
    async backward(node, db) {
        const accounts = await schemaOld_1.GetOldAccounts(node, db);
        const { sequenceToNoteHash, sequenceToTransactionHash, pendingTransactionHashes } = this.getOldStores(db);
        for (const account of accounts) {
            for await (const transactionValue of account.getTransactions()) {
                const transactionHash = transactionValue.transaction.hash();
                for (const note of transactionValue.transaction.notes) {
                    if (transactionValue.sequence !== null) {
                        const sequence = transactionValue.sequence;
                        const decryptedNoteValue = await account.getDecryptedNote(note.hash());
                        if (decryptedNoteValue === undefined) {
                            continue;
                        }
                        await sequenceToNoteHash.put([account.prefix, [sequence, note.hash()]], null);
                        await sequenceToTransactionHash.put([account.prefix, [sequence, transactionHash]], null);
                    }
                    else {
                        const expiration = transactionValue.transaction.expiration();
                        await pendingTransactionHashes.put([account.prefix, [expiration, transactionHash]], null);
                    }
                }
            }
        }
        await node.wallet.walletDb.sequenceToNoteHash.clear();
        await node.wallet.walletDb.sequenceToTransactionHash.clear();
        await node.wallet.walletDb.pendingTransactionHashes.clear();
    }
    getOldStores(db) {
        const sequenceToNoteHash = db.addStore({
            name: 's',
            keyEncoding: new storage_1.PrefixEncoding(new storage_1.BufferEncoding(), new storage_1.PrefixEncoding(storage_1.U32_ENCODING_BE, new storage_1.BufferEncoding(), 4), 4),
            valueEncoding: storage_1.NULL_ENCODING,
        });
        const sequenceToTransactionHash = db.addStore({
            name: 'st',
            keyEncoding: new storage_1.PrefixEncoding(new storage_1.BufferEncoding(), new storage_1.PrefixEncoding(storage_1.U32_ENCODING_BE, new storage_1.BufferEncoding(), 4), 4),
            valueEncoding: storage_1.NULL_ENCODING,
        });
        const pendingTransactionHashes = db.addStore({
            name: 'p',
            keyEncoding: new storage_1.PrefixEncoding(new storage_1.BufferEncoding(), new storage_1.PrefixEncoding(storage_1.U32_ENCODING_BE, new storage_1.BufferEncoding(), 4), 4),
            valueEncoding: storage_1.NULL_ENCODING,
        });
        return { sequenceToNoteHash, sequenceToTransactionHash, pendingTransactionHashes };
    }
}
exports.Migration017 = Migration017;
//# sourceMappingURL=017-sequence-encoding.js.map