"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Migration019 = void 0;
/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/. */
const assert_1 = require("../../assert");
const assetValue_1 = require("../../blockchain/database/assetValue");
const node_1 = require("../../node");
const storage_1 = require("../../storage");
const utils_1 = require("../../storage/utils");
const utils_2 = require("../../utils");
const migration_1 = require("../migration");
const schemaOld_1 = require("./021-add-version-to-accounts/schemaOld");
class Migration019 extends migration_1.Migration {
    constructor() {
        super(...arguments);
        this.path = __filename;
        this.database = migration_1.Database.WALLET;
    }
    prepare(node) {
        return node.wallet.walletDb.db;
    }
    async forward(node, _db, tx, logger) {
        const accounts = await schemaOld_1.GetOldAccounts(node, _db, tx);
        logger.info(`Backfilling assets for ${accounts.length} accounts`);
        const assetsToBackfill = [];
        for (const account of accounts) {
            const assets = [];
            for await (const { note, sequence, blockHash: hash } of account.getNotes()) {
                const asset = await node.wallet.walletDb.getAsset(account, note.assetId(), tx);
                if (!asset) {
                    assets.push({ id: note.assetId(), sequence, hash });
                }
            }
            assetsToBackfill.push({ account, assets });
        }
        if (assetsToBackfill.length) {
            assert_1.Assert.isInstanceOf(node, node_1.FullNode);
            const chainDb = utils_1.createDB({ location: node.config.chainDatabasePath });
            await chainDb.open();
            const chainAssets = chainDb.addStore({
                name: 'bA',
                keyEncoding: storage_1.BUFFER_ENCODING,
                valueEncoding: new assetValue_1.AssetValueEncoding(),
            });
            for (const { account, assets } of assetsToBackfill) {
                logger.info('');
                logger.info(`  Backfilling assets for account ${account.name}`);
                for (const { id, hash, sequence } of assets) {
                    const chainAsset = await chainAssets.get(id);
                    assert_1.Assert.isNotUndefined(chainAsset, 'Asset must be non-null in the chain');
                    logger.info(`    Backfilling ${utils_2.BufferUtils.toHuman(chainAsset.name)} from chain`);
                    await account.saveAssetFromChain(chainAsset.createdTransactionHash, chainAsset.id, chainAsset.metadata, chainAsset.name, chainAsset.nonce, chainAsset.creator, 
                    // this migration was created before asset ownership, therefore
                    // owner and creator are the same in the context of this migration
                    chainAsset.creator, { hash, sequence }, tx);
                }
                logger.info(`  Completed backfilling assets for account ${account.name}`);
            }
            await chainDb.close();
        }
        logger.info('');
    }
    // eslint-disable-next-line @typescript-eslint/no-empty-function
    async backward() { }
}
exports.Migration019 = Migration019;
//# sourceMappingURL=019-backfill-wallet-assets-from-chain.js.map