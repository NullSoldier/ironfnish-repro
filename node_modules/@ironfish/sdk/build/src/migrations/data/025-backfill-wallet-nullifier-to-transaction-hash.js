"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Migration025 = void 0;
const utils_1 = require("../../storage/utils");
const wallet_1 = require("../../wallet");
const migration_1 = require("../migration");
const stores_1 = require("./025-backfill-wallet-nullifier-to-transaction-hash/stores");
class Migration025 extends migration_1.Migration {
    constructor() {
        super(...arguments);
        this.path = __filename;
        this.database = migration_1.Database.WALLET;
    }
    prepare(node) {
        return utils_1.createDB({ location: node.config.walletDatabasePath });
    }
    async forward(node, db, _tx, logger) {
        const accounts = [];
        const stores = stores_1.GetStores(db);
        for await (const account of stores.old.accounts.getAllValuesIter()) {
            accounts.push(new wallet_1.Account({
                ...account,
                createdAt: null,
                walletDb: node.wallet.walletDb,
            }));
        }
        const accountsString = accounts.length === 1 ? `${accounts.length} account` : `${accounts.length} accounts`;
        logger.info(`Backfilling nullifier to transaction hashes for ${accountsString}`);
        for (const account of accounts) {
            logger.info('');
            logger.info(`  Backfilling nullifier to transaction hashes for account ${account.name}`);
            const head = await stores.old.heads.get(account.id);
            // If the account has not scanned, we can skip the backfill
            if (!head) {
                continue;
            }
            let transactionCount = 0;
            for await (const { blockHash, transaction } of stores.old.transactions.getAllValuesIter(undefined, account.prefixRange)) {
                // If the transaction is expired, we can skip the backfill
                if (!blockHash &&
                    transaction.expiration() !== 0 &&
                    transaction.expiration() <= head.sequence) {
                    continue;
                }
                // Backfill the mappings from all transaction spends
                for (const spend of transaction.spends) {
                    const existingNullifierToTransactionHash = await stores.new.nullifierToTransactionHash.get([account.prefix, spend.nullifier]);
                    // Upsert a record for connected transactions or if a mapping doesn't already exist
                    if (blockHash || !existingNullifierToTransactionHash) {
                        await stores.new.nullifierToTransactionHash.put([account.prefix, spend.nullifier], transaction.hash());
                    }
                }
                transactionCount++;
            }
            const transactionsString = transactionCount === 1
                ? `${transactionCount} transaction`
                : `${transactionCount} transactions`;
            logger.info(`  Completed backfilling ${transactionsString} for account ${account.name}`);
        }
        logger.info('');
    }
    async backward(_node, db, tx, logger) {
        const stores = stores_1.GetStores(db);
        logger.info('Clearing nullifierToTransactionHash');
        await stores.new.nullifierToTransactionHash.clear(tx);
    }
}
exports.Migration025 = Migration025;
//# sourceMappingURL=025-backfill-wallet-nullifier-to-transaction-hash.js.map