"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Migration026 = void 0;
const utils_1 = require("../../storage/utils");
const wallet_1 = require("../../wallet");
const migration_1 = require("../migration");
const stores_1 = require("./026-timestamp-to-transactions/stores");
class Migration026 extends migration_1.Migration {
    constructor() {
        super(...arguments);
        this.path = __filename;
        this.database = migration_1.Database.WALLET;
    }
    prepare(node) {
        return utils_1.createDB({ location: node.config.walletDatabasePath });
    }
    async forward(node, db, _tx, logger) {
        const accounts = [];
        const stores = stores_1.GetStores(db);
        for await (const account of stores.old.accounts.getAllValuesIter()) {
            accounts.push(new wallet_1.Account({
                ...account,
                createdAt: null,
                walletDb: node.wallet.walletDb,
            }));
        }
        const accountsString = accounts.length === 1 ? `${accounts.length} account` : `${accounts.length} accounts`;
        logger.info(`Indexing transaction timestamps for ${accountsString}`);
        for (const account of accounts) {
            logger.info('');
            logger.info(`  Indexing transaction timestamps for account ${account.name}`);
            let transactionCount = 0;
            for await (const { timestamp, transaction } of stores.old.transactions.getAllValuesIter(undefined, account.prefixRange)) {
                await stores.new.timestampToTransactionHash.put([account.prefix, [timestamp.getTime(), transaction.hash()]], null);
                transactionCount++;
            }
            const transactionsString = transactionCount === 1
                ? `${transactionCount} transaction`
                : `${transactionCount} transactions`;
            logger.info(`  Completed indexing ${transactionsString} for account ${account.name}`);
        }
        await stores.old.timestampToTransactionHash.clear();
        logger.info('');
    }
    async backward(node, db) {
        const accounts = [];
        const stores = stores_1.GetStores(db);
        for await (const account of stores.old.accounts.getAllValuesIter()) {
            accounts.push(new wallet_1.Account({
                ...account,
                createdAt: null,
                walletDb: node.wallet.walletDb,
            }));
        }
        for (const account of accounts) {
            for await (const { timestamp, transaction } of stores.old.transactions.getAllValuesIter(undefined, account.prefixRange)) {
                await stores.old.timestampToTransactionHash.put([account.prefix, timestamp.getTime()], transaction.hash());
            }
            await stores.new.timestampToTransactionHash.clear();
        }
    }
}
exports.Migration026 = Migration026;
//# sourceMappingURL=026-timestamp-to-transactions.js.map