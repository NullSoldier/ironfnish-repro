import { Event } from '../../event';
import { HostsStore } from '../../fileStores/hosts';
import { Logger } from '../../logger';
import { MetricsMonitor } from '../../metrics';
import { Identity } from '../identity';
import { DisconnectingReason } from '../messages/disconnecting';
import { NetworkMessage } from '../messages/networkMessage';
import { IsomorphicWebSocket } from '../types';
import { AddressManager } from './addressManager';
import { ConnectionRetry } from './connectionRetry';
import { ConnectionDirection, ConnectionType } from './connections';
import { LocalPeer } from './localPeer';
import { Peer } from './peer';
import { PeerCandidates } from './peerCandidates';
/**
 * PeerManager keeps the state of Peers and their underlying connections up to date,
 * determines how to establish a connection to a given Peer, and provides an event
 * bus for Peers, e.g. for listening to incoming messages from all connected peers.
 */
export declare class PeerManager {
    private readonly logger;
    private readonly metrics;
    /**
     * Stores data related to the user's peer, like the identity and version
     */
    readonly localPeer: LocalPeer;
    /**
     * Map of identities to peers for every known identified peer in the network.
     */
    readonly identifiedPeers: Map<Identity, Peer>;
    readonly banned: Map<string, string>;
    /**
     * List of all peers, including both unidentified and identified.
     */
    peers: Array<Peer>;
    peerCandidates: PeerCandidates;
    addressManager: AddressManager;
    /**
     * setInterval handle for requestPeerList, which sends out peer lists and
     * requests for peer lists
     */
    private requestPeerListHandle;
    /**
     * STUN servers to use for inititating WebRTC connections.
     */
    private stunServers;
    /**
     * setInterval handle for peer disposal, which removes peers from the list that we
     * no longer care about
     */
    private disposePeersHandle;
    /**
     * setInterval handle for peer address persistence, which saves connected
     * peers to disk
     */
    private savePeerAddressesHandle;
    /**
     * Event fired when a new connection is successfully opened. Sends some identifying
     * information about the peer.
     *
     * This event is fired regardless of whether or not we initiated the connection.
     */
    readonly onConnect: Event<[Peer]>;
    /**
     * Event fired when an identified peer is disconnected for some reason.
     */
    readonly onDisconnect: Event<[Peer]>;
    /**
     * Event fired for every new incoming message that needs to be processed
     * by the application layer.
     *
     * Note that the `Peer` is the peer that sent it to us,
     * not necessarily the original source.
     */
    readonly onMessage: Event<[Peer, NetworkMessage]>;
    /**
     * Event fired when a peer enters or leaves the CONNECTED state.
     */
    readonly onConnectedPeersChanged: Event<[]>;
    /**
     * The maximum number of peers allowed to be in the CONNECTED or CONNECTING state.
     */
    readonly maxPeers: number;
    /**
     * Stops establishing connections to DISCONNECTED peers when at or above this number.
     */
    readonly targetPeers: number;
    /**
     * If true, track all sent and received network messages per-peer.
     */
    readonly logPeerMessages: boolean;
    constructor(localPeer: LocalPeer, hostsStore: HostsStore, logger?: Logger, metrics?: MetricsMonitor, maxPeers?: number, targetPeers?: number, logPeerMessages?: boolean, stunServers?: string[]);
    /**
     * Connect to a websocket by its uri. Establish a connection and solicit
     * the server's Identity.
     */
    connectToWebSocketAddress(options: {
        host: string;
        port: number;
        whitelist?: boolean;
        forceConnect?: boolean;
    }): Peer | undefined;
    /**
     * Connect to a peer using WebSockets
     * */
    connectToWebSocket(peer: Peer, forceConnect?: boolean): boolean;
    /**
     * Connect to a peer using WebRTC through another peer
     * */
    connectToWebRTC(peer: Peer): boolean;
    createPeerFromInboundWebSocketConnection(webSocket: IsomorphicWebSocket, address: string | null): Peer;
    /**
     * Perform WebSocket-specific connection setup.
     */
    private initWebSocketConnection;
    /**
     * Perform WebRTC-specific connection setup
     * @param peer The peer to establish a connection with
     * @param initiator Set to true if we are initiating a connection with `peer`
     */
    private initWebRtcConnection;
    /**
     * Set up event handlers that are common among all connection types.
     * @param connection An instance of a Connection.
     */
    private initConnectionHandlers;
    canConnectToWebSocket(peer: Peer, forceConnect?: boolean): boolean;
    canConnectToWebRTC(peer: Peer, now?: number): boolean;
    /**
     * Generate a timestamp for use in disconnect messages when the peer has more
     * connected peers than maxPeers.
     */
    getCongestedDisconnectUntilTimestamp(): number;
    /**
     * Initiate a disconnection from another peer.
     * @param peer The peer to disconnect from
     * @param reason The reason for disconnecting from the peer
     * @param until Stay disconnected from the peer until after this timestamp
     */
    disconnect(peer: Peer, reason: DisconnectingReason, until: number): void;
    getPeersWithConnection(): ReadonlyArray<Peer>;
    getConnectedPeers(): ReadonlyArray<Peer>;
    /**
     * Returns true if the total number of connected peers is less
     * than the target amount of peers
     */
    canCreateNewConnections(): boolean;
    /**
     * True if we should reject connections from disconnected Peers.
     */
    shouldRejectDisconnectedPeers(): boolean;
    /** For a given peer, try to find a peer that's connected to that peer
     * including itself to broker a WebRTC connection to it
     * */
    private getBrokeringPeer;
    /**
     * This function puts a peer in the identified peers map and should be called once
     * a peer is connected, meaning it has a connection that has received an identity
     */
    private updateIdentifiedPeerMap;
    /**
     * Given an identity, returns the Peer corresponding to that identity,
     * or null if no Peer for that identity exists.
     * @param identity A peer identity.
     */
    getPeer(identity: Identity): Peer | null;
    /**
     * Given an identity, fetch a Peer with that identity or throw an error
     * @param identity A peer identity.
     */
    getPeerOrThrow(identity: Identity): Peer;
    /**
     * If a null identity is passed, creates a new Peer. If an identity is passed, returns the Peer
     * if we already have one with that identity, else creates a new Peer with that identity.
     * @param identity The identity of the peer to create, or null if the peer does not yet have one.
     */
    getOrCreatePeer(identity: Identity | null): Peer;
    banPeer(peer: Peer, reason: string): void;
    isBanned(peer: Peer): boolean;
    start(): void;
    /**
     * Call when shutting down the PeerManager to clean up
     * outstanding connections.
     */
    stop(): Promise<void>;
    private requestPeerList;
    /**
     * Gets a random disconnected peer address and returns a peer created from
     * said address
     */
    createRandomDisconnectedPeer(): Peer | null;
    private disposePeers;
    /**
     * Returns true if we successfully cleaned up the Peer and removed it from PeerManager,
     * else returns false and does nothing.
     * @param peer The peer to evaluate
     */
    tryDisposePeer(peer: Peer): boolean;
    getConnectionRetry(identity: string, type: ConnectionType, direction: ConnectionDirection): ConnectionRetry | null;
    /**
     * Handler fired whenever we receive any message from a peer.
     */
    private handleMessage;
    private handleIdentifyMessage;
    private handleDisconnectingMessage;
    /**
     * Handle messages received when the peer is in the WAITING_FOR_IDENTITY state.
     *
     * @param message The message received.
     * @param peer The Peer the message was received from.
     * @param connection The Connection the message was received from.
     */
    private handleMessageInWaitingForIdentityState;
    /**
     * Handle a signal request message relayed by another peer.
     * @param message An incoming SignalRequest message from a peer.
     */
    private handleSignalRequestMessage;
    /**
     * Handle a signal message relayed by another peer.
     * @param message An incoming Signal message from a peer.
     */
    private handleSignalMessage;
    private handlePeerListRequestMessage;
    private handlePeerListMessage;
}
//# sourceMappingURL=peerManager.d.ts.map