"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Peer = exports.KnownBlockHashesValue = exports.BAN_SCORE = void 0;
const blru_1 = __importDefault(require("blru"));
const buffer_map_1 = require("buffer-map");
const safe_1 = __importDefault(require("colors/safe"));
const event_1 = require("../../event");
const logger_1 = require("../../logger");
const utils_1 = require("../../utils");
const networkMessage_1 = require("../messages/networkMessage");
const types_1 = require("../types");
const connections_1 = require("./connections");
const connection_1 = require("./connections/connection");
var BAN_SCORE;
(function (BAN_SCORE) {
    BAN_SCORE[BAN_SCORE["NO"] = 0] = "NO";
    BAN_SCORE[BAN_SCORE["LOW"] = 1] = "LOW";
    BAN_SCORE[BAN_SCORE["MED"] = 5] = "MED";
    BAN_SCORE[BAN_SCORE["MAX"] = 10] = "MAX";
})(BAN_SCORE = exports.BAN_SCORE || (exports.BAN_SCORE = {}));
/**
 * Message types that should be excluded from loggedMessages (unless overridden).
 */
const UNLOGGED_MESSAGE_TYPES = [
    types_1.NetworkMessageType.PeerList,
    types_1.NetworkMessageType.Signal,
];
var KnownBlockHashesValue;
(function (KnownBlockHashesValue) {
    KnownBlockHashesValue[KnownBlockHashesValue["Received"] = 1] = "Received";
    KnownBlockHashesValue[KnownBlockHashesValue["Sent"] = 2] = "Sent";
})(KnownBlockHashesValue = exports.KnownBlockHashesValue || (exports.KnownBlockHashesValue = {}));
class Peer {
    constructor(identity, { logger = logger_1.createRootLogger(), maxPending = 5, maxBanScore = BAN_SCORE.MAX, shouldLogMessages = false, metrics, } = {}) {
        this.banScore = 0;
        /**
         * name associated with this peer
         */
        this.name = null;
        /**
         * The peer's protocol version
         */
        this.version = null;
        /**
         * The peer's agent
         */
        this.agent = null;
        /**
         * The peer's heaviest head hash
         */
        this.head = null;
        /**
         * The peer's heaviest head cumulative work
         */
        this.work = null;
        /**
         * The peer's heaviest head sequence
         */
        this.sequence = null;
        /**
         * The peer's network ID
         */
        this.networkId = null;
        /**
         * The peer's genesis block hash
         */
        this.genesisBlockHash = null;
        /**
         * Features supported by the peer
         */
        this.features = null;
        /**
         * address associated with this peer
         */
        this._address = null;
        /**
         * port associated with this peer
         */
        this._port = null;
        /** how many outbound connections does the peer have */
        this.pendingRPC = 0;
        /**
         * True if the peer is a known honest peer.
         */
        this.isWhitelisted = false;
        this.shouldLogMessages = false;
        this.loggedMessages = [];
        /**
         * Blocks that have been sent or received from this peer. Value is set to true if the block was received
         * from the peer, and false if the block was sent to the peer.
         */
        this.knownBlockHashes = new blru_1.default(1024, null, buffer_map_1.BufferMap);
        /**
         * Event fired for every new incoming message that needs to be processed
         * by the application layer. Includes the connection from which the message
         * was received.
         */
        this.onMessage = new event_1.Event();
        /**
         * Fired when the peer should be banned
         */
        this.onBanned = new event_1.Event();
        /**
         * Event fired when the peer changes state. The event may fire when connections change, even if the
         * state type stays the same.
         */
        this.onStateChanged = new event_1.Event();
        this.connectionMessageHandlers = new Map();
        this.connectionStateChangedHandlers = new Map();
        this.logger = logger.withTag('Peer');
        this.pendingRPCMax = maxPending;
        this.maxBanScore = maxBanScore;
        this.metrics = metrics;
        this.shouldLogMessages = shouldLogMessages;
        this._error = null;
        this._state = {
            type: 'DISCONNECTED',
            identity: identity,
        };
    }
    get state() {
        return this._state;
    }
    get isSaturated() {
        return this.pendingRPC >= this.pendingRPCMax;
    }
    get error() {
        return this._error;
    }
    /**
     * The loggable name of the peer. For a more specific value,
     * try Peer.name or Peer.state.identity.
     */
    get displayName() {
        if (this.state.identity === null) {
            return 'unidentified';
        }
        const identitySlice = this.state.identity.slice(0, 7);
        if (this.name) {
            return `${identitySlice} (${this.name})`;
        }
        return identitySlice;
    }
    get address() {
        return this._address;
    }
    get port() {
        return this._port;
    }
    /**
     * Sets a WebRTC connection on the peer, moving it into the CONNECTING state if necessary.
     * Ignores the connection if the peer already has a WebRTC connection.
     * @param connection The WebRTC connection to set
     */
    setWebRtcConnection(connection) {
        if (this.state.type !== 'DISCONNECTED' && this.state.connections.webRtc) {
            this.logger.warn('Already have a WebRTC connection, ignoring the new one');
            return;
        }
        const webSocket = this.state.type !== 'DISCONNECTED' ? this.state.connections.webSocket : undefined;
        this.setState(this.computeStateFromConnections(webSocket, connection));
    }
    /**
     * Replaces a WebRTC connection on the peer, moving it into the CONNECTING state if necessary.
     * Closes the existing connection if the peer already has a WebRTC connection.
     * @param connection The WebRTC connection to set
     */
    replaceWebRtcConnection(connection) {
        let existingConnection = null;
        if (this.state.type !== 'DISCONNECTED' && this.state.connections.webRtc) {
            existingConnection = this.state.connections.webRtc;
        }
        const webSocket = this.state.type !== 'DISCONNECTED' ? this.state.connections.webSocket : undefined;
        this.setState(this.computeStateFromConnections(webSocket, connection));
        if (existingConnection) {
            const error = `Replacing duplicate WebRTC connection on ${this.displayName}`;
            this.logger.debug(utils_1.ErrorUtils.renderError(new connections_1.NetworkError(error)));
            existingConnection.close(new connections_1.NetworkError(error));
        }
    }
    /**
     * Sets a WebSocket connection on the peer, moving it into the CONNECTING state if necessary.
     * Ignores the connection if the peer already has a WebSocket connection.
     * @param connection The WebSocket connection to set
     */
    setWebSocketConnection(connection) {
        if (this.state.type !== 'DISCONNECTED' && this.state.connections.webSocket) {
            this.logger.warn('Already have a WebSocket connection, ignoring the new one');
            return;
        }
        const webRtc = this.state.type !== 'DISCONNECTED' ? this.state.connections.webRtc : undefined;
        this.setState(this.computeStateFromConnections(connection, webRtc));
    }
    /**
     * Replaces a WebSocket connection on the peer, moving it into the CONNECTING state if necessary.
     * Closes the existing connection if the peer already has a WebSocket connection.
     * @param connection The WebSocket connection to set
     */
    replaceWebSocketConnection(connection) {
        let existingConnection = null;
        if (this.state.type !== 'DISCONNECTED' && this.state.connections.webSocket) {
            existingConnection = this.state.connections.webSocket;
        }
        const webRtc = this.state.type !== 'DISCONNECTED' ? this.state.connections.webRtc : undefined;
        this.setState(this.computeStateFromConnections(connection, webRtc));
        if (existingConnection) {
            const error = `Replacing duplicate WebSocket connection on ${this.displayName}`;
            this.logger.debug(utils_1.ErrorUtils.renderError(new connections_1.NetworkError(error)));
            existingConnection.close(new connections_1.NetworkError(error));
        }
    }
    computeStateFromConnections(wsConnection, webRtcConnection) {
        // If both connections are either disconnected or don't exist, the
        // state should be DISCONNECTED
        if ((!wsConnection || wsConnection.state.type === 'DISCONNECTED') &&
            (!webRtcConnection || webRtcConnection.state.type === 'DISCONNECTED')) {
            return { type: 'DISCONNECTED', identity: this.state.identity };
        }
        // If at least one connection is CONNECTED, the state should be CONNECTED
        // TODO: Need to resolve what happens if identities conflict
        if (webRtcConnection && webRtcConnection.state.type === 'CONNECTED') {
            return {
                type: 'CONNECTED',
                identity: webRtcConnection.state.identity,
                connections: {
                    webSocket: wsConnection,
                    webRtc: webRtcConnection,
                },
            };
        }
        else if (wsConnection && wsConnection.state.type === 'CONNECTED') {
            return {
                type: 'CONNECTED',
                identity: wsConnection.state.identity,
                connections: {
                    webSocket: wsConnection,
                    webRtc: webRtcConnection,
                },
            };
        }
        if (webRtcConnection) {
            return {
                type: 'CONNECTING',
                identity: this.state.identity,
                connections: {
                    webRtc: webRtcConnection,
                    webSocket: wsConnection,
                },
            };
        }
        else if (wsConnection) {
            return {
                type: 'CONNECTING',
                identity: this.state.identity,
                connections: {
                    webRtc: webRtcConnection,
                    webSocket: wsConnection,
                },
            };
        }
        else {
            throw new Error('At least one of webRtcConnection or wsConnection must be defined');
        }
    }
    /**
     * Removes a connection from the peer, doing nothing if it doesn't exist on the peer.
     * @param connection The connection to remove
     */
    removeConnection(connection) {
        if (this.state.type === 'DISCONNECTED') {
            return connection;
        }
        const wsConnection = connection === this.state.connections.webSocket
            ? undefined
            : this.state.connections.webSocket;
        const webRtcConnection = connection === this.state.connections.webRtc ? undefined : this.state.connections.webRtc;
        this.setState(this.computeStateFromConnections(wsConnection, webRtcConnection));
        return connection;
    }
    /**
     * Gets the peer's identity, or throws an error if the peer is unidentified.
     */
    getIdentityOrThrow() {
        if (this.state.identity === null) {
            throw new Error('Called getIdentityOrThrow on an unidentified peer');
        }
        return this.state.identity;
    }
    /**
     * Get the peers connectable websocket address
     */
    getWebSocketAddress(includeProtocol = true) {
        let address = '';
        if (includeProtocol) {
            address = 'ws://' + address;
        }
        if (this.address) {
            address += this.address;
        }
        if (this.port) {
            address = address + ':' + String(this.port);
        }
        return address;
    }
    /**
     * Sets the address and peer by which the peer can be connected to over WebSockets.
     * Setting address and port to null makes a peer unconnectable via WebSocket outbound connections.
     * @param address Hostname of the address, or null to remove the address.
     * @param port Port to connect over. Must be null if address is null.
     */
    setWebSocketAddress(address, port) {
        if (address === null && port !== null) {
            throw new Error(`Called setWebSocketAddress on ${String(this.state.identity)} with a port but no address`);
        }
        // Don't do anything if the address and port stay the same
        if (address === this._address && port === this._port) {
            return;
        }
        this._address = address;
        this._port = port;
    }
    /**
     * Records number messages sent using a rolling average
     */
    recordMessageSent() {
        // don't start the meter until we actually want to record a message to save resources
        if (this.state.identity && this.metrics) {
            let meter = this.metrics.p2p_OutboundMessagesByPeer.get(this.state.identity);
            if (!meter) {
                meter = this.metrics.addMeter();
                this.metrics.p2p_OutboundMessagesByPeer.set(this.state.identity, meter);
            }
            meter.add(1);
        }
    }
    disposeMessageMeter() {
        if (this.state.identity && this.metrics) {
            this.metrics.p2p_OutboundMessagesByPeer.get(this.state.identity)?.stop();
            this.metrics.p2p_OutboundMessagesByPeer.delete(this.state.identity);
        }
    }
    /**
     * Sends a message over the peer's connection if CONNECTED, else drops it.
     * @param message The message to send.
     */
    send(message) {
        // Return early if peer is not in state CONNECTED
        if (this.state.type !== 'CONNECTED') {
            this.logger.debug(`Attempted to send a ${networkMessage_1.displayNetworkMessageType(message.type)} message to ${this.displayName} in state ${this.state.type}`);
            return null;
        }
        if (this.state.type === 'CONNECTED' &&
            this.state.connections.webRtc?.state.type === 'CONNECTED') {
            if (this.state.connections.webRtc.send(message)) {
                this.pushLoggedMessage({
                    direction: 'send',
                    message,
                    timestamp: Date.now(),
                    type: connection_1.ConnectionType.WebRtc,
                });
                this.recordMessageSent();
                return this.state.connections.webRtc;
            }
        }
        // If a WebRTC message fails to send and we don't have a WebSocket connection,
        // the peer's state will now be DISCONNECTED, so recheck the state here
        if (this.state.type === 'CONNECTED' &&
            this.state.connections.webSocket?.state.type === 'CONNECTED') {
            if (this.state.connections.webSocket.send(message)) {
                this.pushLoggedMessage({
                    direction: 'send',
                    message,
                    timestamp: Date.now(),
                    type: connection_1.ConnectionType.WebSocket,
                });
                this.recordMessageSent();
                return this.state.connections.webSocket;
            }
        }
        // The message could not be sent on any connection
        return null;
    }
    getConnectionStateOrDefault(state) {
        return state.type === 'DISCONNECTED'
            ? { webRtc: undefined, webSocket: undefined }
            : state.connections;
    }
    unbindConnectionEvents(connection) {
        if (!connection) {
            return;
        }
        // onMessage
        const messageHandler = this.connectionMessageHandlers.get(connection);
        if (messageHandler) {
            connection.onMessage.off(messageHandler);
            this.connectionMessageHandlers.delete(connection);
        }
        // onStateChanged
        const stateChangedHandler = this.connectionStateChangedHandlers.get(connection);
        if (stateChangedHandler) {
            connection.onStateChanged.off(stateChangedHandler);
            this.connectionStateChangedHandlers.delete(connection);
        }
    }
    bindConnectionEvents(connection) {
        if (!connection) {
            return;
        }
        if (connection.state.type === 'CONNECTED' &&
            connection instanceof connections_1.WebSocketConnection &&
            connection.hostname) {
            this.setWebSocketAddress(connection.hostname, connection.port || null);
        }
        // onMessage
        if (!this.connectionMessageHandlers.has(connection)) {
            const messageHandler = (message) => {
                this.pushLoggedMessage({
                    direction: 'receive',
                    message,
                    timestamp: Date.now(),
                    type: connection.type,
                });
                this.onMessage.emit(message, connection);
            };
            this.connectionMessageHandlers.set(connection, messageHandler);
            connection.onMessage.on(messageHandler);
        }
        // onStateChanged
        if (!this.connectionStateChangedHandlers.has(connection)) {
            const stateChangedHandler = () => {
                if (this.state.type === 'DISCONNECTED') {
                    throw new Error('Peer should not have any connections while in DISCONNECTED state');
                }
                if (connection.state.type === 'DISCONNECTED') {
                    this.logger.debug(`Connection closing ${connection.type} for ${this.displayName}: ${utils_1.ErrorUtils.renderError(connection.error) || 'Reason Unknown'}`);
                    if (connection.error !== null) {
                        this._error = connection.error;
                    }
                    this.removeConnection(connection);
                    return;
                }
                if (connection.state.type === 'CONNECTED') {
                    // If connection goes to connected, transition the peer to connected
                    if (connection instanceof connections_1.WebSocketConnection && connection.hostname) {
                        this.setWebSocketAddress(connection.hostname, connection.port || null);
                    }
                    this.setState(this.computeStateFromConnections(this.state.connections.webSocket, this.state.connections.webRtc));
                }
            };
            this.connectionStateChangedHandlers.set(connection, stateChangedHandler);
            connection.onStateChanged.on(stateChangedHandler);
        }
    }
    /**
     * Changes the peer's state from this.state to nextState.
     * @param nextState The new peer state.
     */
    setState(nextState) {
        // Perform pre-transition actions
        const lastConState = this.getConnectionStateOrDefault(this.state);
        const nextConState = this.getConnectionStateOrDefault(nextState);
        if (lastConState.webRtc !== nextConState.webRtc) {
            this.unbindConnectionEvents(lastConState.webRtc);
            this.bindConnectionEvents(nextConState.webRtc);
        }
        if (lastConState.webSocket !== nextConState.webSocket) {
            this.unbindConnectionEvents(lastConState.webSocket);
            this.bindConnectionEvents(nextConState.webSocket);
        }
        // Once a peer identity has been set, it must stay the same
        if (this.state.identity !== null && nextState.identity !== this.state.identity) {
            throw new Error(`Attempted to change state.identity from ${this.state.identity} to ${String(nextState.identity)}`);
        }
        // Transition the state
        const prevState = this._state;
        this._state = nextState;
        // Perform post-transition actions
        if (prevState.type !== 'CONNECTED' && this.state.type === 'CONNECTED') {
            this._error = null;
        }
        if (prevState.type !== nextState.type) {
            this.logger.debug(`${safe_1.default.green('PEER')} ${this.displayName} STATE ${prevState.type} -> ${this._state.type}`);
        }
        this.onStateChanged.emit({ peer: this, state: nextState, prevState });
    }
    /**
     * Set the peer's state to DISCONNECTED, closing open connections.
     */
    close(error) {
        const connections = this.getConnectionStateOrDefault(this.state);
        connections.webRtc && this.removeConnection(connections.webRtc).close(error);
        connections.webSocket && this.removeConnection(connections.webSocket).close(error);
        if (error !== undefined) {
            this._error = error;
        }
        this.setState({ type: 'DISCONNECTED', identity: this.state.identity });
    }
    /**
     * Clean up all resources managed by the peer.
     */
    dispose() {
        this.onStateChanged.clearAfter();
        this.onMessage.clear();
        this.onBanned.clear();
        this.disposeMessageMeter();
    }
    punish(score, reason) {
        this.banScore += score;
        if (this.banScore < this.maxBanScore) {
            return false;
        }
        this.logger.info(`Peer ${this.displayName} has been banned: ${reason || 'UNKNOWN'}`);
        this.onBanned.emit(reason || 'UNKNOWN');
        this.close(new Error(`BANNED: ${reason || 'UNKNOWN'}`));
        return true;
    }
    pushLoggedMessage(loggedMessage, forceLogMessage = false) {
        if (!this.shouldLogMessages) {
            return;
        }
        const { message } = loggedMessage;
        if (forceLogMessage || !UNLOGGED_MESSAGE_TYPES.includes(message.type)) {
            this.loggedMessages.push(loggedMessage);
        }
    }
}
exports.Peer = Peer;
//# sourceMappingURL=peer.js.map