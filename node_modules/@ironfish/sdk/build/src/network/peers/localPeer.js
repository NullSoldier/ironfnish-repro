"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.LocalPeer = void 0;
/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/. */
const rust_nodejs_1 = require("@ironfish/rust-nodejs");
const assert_1 = require("../../assert");
const identity_1 = require("../identity");
const identify_1 = require("../messages/identify");
/**
 * Wraps configuration needed for establishing connections with other peers
 * and maintains references to all known peers.
 */
class LocalPeer {
    constructor(identity, agent, version, chain, webSocket, networkId, enableSyncing) {
        // simulated latency in MS that gets added to connection.send
        this.simulateLatency = 0;
        this.privateIdentity = identity;
        this.publicIdentity = identity_1.privateIdentityToIdentity(identity);
        this.chain = chain;
        this.agent = agent;
        this.version = version;
        this.networkId = networkId;
        this.enableSyncing = enableSyncing;
        this.webSocket = webSocket;
        this.port = null;
        this.name = null;
    }
    /**
     * Construct an Identify message with our identity and version.
     */
    getIdentifyMessage() {
        assert_1.Assert.isNotNull(this.chain.head, 'Cannot connect to the network without a genesis block');
        return new identify_1.IdentifyMessage({
            agent: this.agent,
            head: this.chain.head.hash,
            identity: this.publicIdentity,
            name: this.name || undefined,
            port: this.port,
            sequence: Number(this.chain.head.sequence),
            version: this.version,
            work: this.chain.head.work,
            networkId: this.networkId,
            genesisBlockHash: this.chain.genesis.hash,
            features: {
                syncing: this.enableSyncing,
            },
        });
    }
    /**
     * Encrypt a string for recipient with the stored private identity.
     * @param plainTextMessage The string to encrypt.
     * @param recipient The public key of the recipient of the message.
     */
    boxMessage(plainTextMessage, recipient) {
        return rust_nodejs_1.boxMessage(plainTextMessage, this.privateIdentity.secretKey, recipient);
    }
    /**
     * Decrypt a message using a nonce from a sender.
     * @param boxedMessage An encrypted message string.
     * @param nonce A nonce, generated by boxMessage.
     * @param sender The public key of the message sender.
     */
    unboxMessage(boxedMessage, nonce, sender) {
        let message;
        try {
            message = rust_nodejs_1.unboxMessage(boxedMessage, nonce, sender, this.privateIdentity.secretKey);
        }
        catch {
            message = null;
        }
        return { message };
    }
}
exports.LocalPeer = LocalPeer;
//# sourceMappingURL=localPeer.js.map