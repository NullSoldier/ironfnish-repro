/// <reference types="node" />
import type { BlockHash } from '../../primitives/blockheader';
import LRU from 'blru';
import { Event } from '../../event';
import { Logger } from '../../logger';
import { MetricsMonitor } from '../../metrics';
import { Identity } from '../identity';
import { NetworkMessage } from '../messages/networkMessage';
import { WebRtcConnection, WebSocketConnection } from './connections';
import { Connection, ConnectionType } from './connections/connection';
import { Features } from './peerFeatures';
export declare enum BAN_SCORE {
    NO = 0,
    LOW = 1,
    MED = 5,
    MAX = 10
}
declare type LoggedMessage = {
    brokeringPeerDisplayName?: string;
    direction: 'send' | 'receive';
    message: NetworkMessage;
    timestamp: number;
    type: ConnectionType;
};
/**
 * PeerConnectionState contains at least one connection, as well as an optional second connection.
 */
declare type PeerConnectionState = {
    webSocket: WebSocketConnection;
    webRtc: WebRtcConnection;
} | {
    webSocket?: undefined;
    webRtc: WebRtcConnection;
} | {
    webSocket: WebSocketConnection;
    webRtc?: undefined;
};
export declare type PeerState = {
    type: 'DISCONNECTED';
    identity: Identity | null;
} | {
    type: 'CONNECTING';
    identity: Identity | null;
    connections: Readonly<PeerConnectionState>;
} | {
    type: 'CONNECTED';
    identity: Identity;
    connections: Readonly<PeerConnectionState>;
};
export declare enum KnownBlockHashesValue {
    Received = 1,
    Sent = 2
}
export declare class Peer {
    readonly pendingRPCMax: number;
    readonly logger: Logger;
    metrics?: MetricsMonitor;
    /**
     * The current state of the peer.
     */
    private _state;
    get state(): Readonly<PeerState>;
    get isSaturated(): boolean;
    /**
     * The last error the peer encountered
     */
    private _error;
    get error(): Readonly<unknown> | null;
    banScore: number;
    maxBanScore: number;
    /**
     * name associated with this peer
     */
    name: string | null;
    /**
     * The peer's protocol version
     */
    version: number | null;
    /**
     * The peer's agent
     */
    agent: string | null;
    /**
     * The peer's heaviest head hash
     */
    head: Buffer | null;
    /**
     * The peer's heaviest head cumulative work
     */
    work: bigint | null;
    /**
     * The peer's heaviest head sequence
     */
    sequence: number | null;
    /**
     * The peer's network ID
     */
    networkId: number | null;
    /**
     * The peer's genesis block hash
     */
    genesisBlockHash: Buffer | null;
    /**
     * Features supported by the peer
     */
    features: Features | null;
    /**
     * The loggable name of the peer. For a more specific value,
     * try Peer.name or Peer.state.identity.
     */
    get displayName(): string;
    /**
     * address associated with this peer
     */
    private _address;
    get address(): string | null;
    /**
     * port associated with this peer
     */
    private _port;
    get port(): number | null;
    /** how many outbound connections does the peer have */
    pendingRPC: number;
    /**
     * True if the peer is a known honest peer.
     */
    isWhitelisted: boolean;
    shouldLogMessages: boolean;
    loggedMessages: Array<LoggedMessage>;
    /**
     * Blocks that have been sent or received from this peer. Value is set to true if the block was received
     * from the peer, and false if the block was sent to the peer.
     */
    readonly knownBlockHashes: LRU<BlockHash, KnownBlockHashesValue>;
    /**
     * Event fired for every new incoming message that needs to be processed
     * by the application layer. Includes the connection from which the message
     * was received.
     */
    readonly onMessage: Event<[NetworkMessage, Connection]>;
    /**
     * Fired when the peer should be banned
     */
    readonly onBanned: Event<[string]>;
    /**
     * Event fired when the peer changes state. The event may fire when connections change, even if the
     * state type stays the same.
     */
    readonly onStateChanged: Event<[{
        peer: Peer;
        state: PeerState;
        prevState: PeerState;
    }]>;
    constructor(identity: Identity | null, { logger, maxPending, maxBanScore, shouldLogMessages, metrics, }?: {
        logger?: Logger;
        maxPending?: number;
        maxBanScore?: number;
        shouldLogMessages?: boolean;
        metrics?: MetricsMonitor;
    });
    /**
     * Sets a WebRTC connection on the peer, moving it into the CONNECTING state if necessary.
     * Ignores the connection if the peer already has a WebRTC connection.
     * @param connection The WebRTC connection to set
     */
    setWebRtcConnection(connection: WebRtcConnection): void;
    /**
     * Replaces a WebRTC connection on the peer, moving it into the CONNECTING state if necessary.
     * Closes the existing connection if the peer already has a WebRTC connection.
     * @param connection The WebRTC connection to set
     */
    replaceWebRtcConnection(connection: WebRtcConnection): void;
    /**
     * Sets a WebSocket connection on the peer, moving it into the CONNECTING state if necessary.
     * Ignores the connection if the peer already has a WebSocket connection.
     * @param connection The WebSocket connection to set
     */
    setWebSocketConnection(connection: WebSocketConnection): void;
    /**
     * Replaces a WebSocket connection on the peer, moving it into the CONNECTING state if necessary.
     * Closes the existing connection if the peer already has a WebSocket connection.
     * @param connection The WebSocket connection to set
     */
    replaceWebSocketConnection(connection: WebSocketConnection): void;
    private computeStateFromConnections;
    /**
     * Removes a connection from the peer, doing nothing if it doesn't exist on the peer.
     * @param connection The connection to remove
     */
    removeConnection(connection: Connection): Connection;
    /**
     * Gets the peer's identity, or throws an error if the peer is unidentified.
     */
    getIdentityOrThrow(): Identity;
    /**
     * Get the peers connectable websocket address
     */
    getWebSocketAddress(includeProtocol?: boolean): string;
    /**
     * Sets the address and peer by which the peer can be connected to over WebSockets.
     * Setting address and port to null makes a peer unconnectable via WebSocket outbound connections.
     * @param address Hostname of the address, or null to remove the address.
     * @param port Port to connect over. Must be null if address is null.
     */
    setWebSocketAddress(address: string | null, port: number | null): void;
    /**
     * Records number messages sent using a rolling average
     */
    private recordMessageSent;
    private disposeMessageMeter;
    /**
     * Sends a message over the peer's connection if CONNECTED, else drops it.
     * @param message The message to send.
     */
    send(message: NetworkMessage): Connection | null;
    private getConnectionStateOrDefault;
    private readonly connectionMessageHandlers;
    private readonly connectionStateChangedHandlers;
    private unbindConnectionEvents;
    private bindConnectionEvents;
    /**
     * Changes the peer's state from this.state to nextState.
     * @param nextState The new peer state.
     */
    private setState;
    /**
     * Set the peer's state to DISCONNECTED, closing open connections.
     */
    close(error?: Readonly<unknown>): void;
    /**
     * Clean up all resources managed by the peer.
     */
    dispose(): void;
    punish(score: number, reason?: string): boolean;
    pushLoggedMessage(loggedMessage: LoggedMessage, forceLogMessage?: boolean): void;
}
export {};
//# sourceMappingURL=peer.d.ts.map