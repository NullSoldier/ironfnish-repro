"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.PeerCandidates = void 0;
/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/. */
const array_1 = require("../../utils/array");
const connectionRetry_1 = require("./connectionRetry");
const peer_1 = require("./peer");
class PeerCandidates {
    constructor() {
        this.map = new Map();
    }
    get size() {
        return this.map.size;
    }
    addFromPeer(peer, neighbors = new Set()) {
        const address = peer.getWebSocketAddress();
        const addressPeerCandidate = this.map.get(address);
        const newPeerCandidate = {
            address: peer.address,
            port: peer.port,
            neighbors,
            webRtcRetry: new connectionRetry_1.ConnectionRetry(peer.isWhitelisted),
            websocketRetry: new connectionRetry_1.ConnectionRetry(peer.isWhitelisted),
            localRequestedDisconnectUntil: null,
            peerRequestedDisconnectUntil: null,
        };
        if (peer.state.identity !== null) {
            if (addressPeerCandidate) {
                this.map.delete(address);
            }
            if (!this.map.has(peer.state.identity)) {
                this.map.set(peer.state.identity, addressPeerCandidate ?? newPeerCandidate);
            }
        }
        else if (!addressPeerCandidate) {
            this.map.set(address, newPeerCandidate);
        }
    }
    addFromPeerList(sendingPeerIdentity, peer) {
        const peerIdentity = peer.identity.toString('base64');
        const peerCandidateValue = this.map.get(peerIdentity);
        if (peerCandidateValue) {
            peerCandidateValue.neighbors.add(sendingPeerIdentity);
        }
        else {
            const tempPeer = new peer_1.Peer(peerIdentity);
            tempPeer.setWebSocketAddress(peer.address, peer.port);
            this.addFromPeer(tempPeer, new Set([sendingPeerIdentity]));
        }
    }
    shufflePeerCandidates() {
        return array_1.ArrayUtils.shuffle([...this.map.keys()]);
    }
    get(identity) {
        return this.map.get(identity);
    }
    has(identity) {
        return this.map.has(identity);
    }
    set(identity, value) {
        this.map.set(identity, value);
    }
    clear() {
        this.map.clear();
    }
}
exports.PeerCandidates = PeerCandidates;
//# sourceMappingURL=peerCandidates.js.map