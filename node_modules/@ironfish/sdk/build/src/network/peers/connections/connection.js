"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Connection = exports.ConnectionDirection = exports.ConnectionType = void 0;
const safe_1 = __importDefault(require("colors/safe"));
const assert_1 = require("../../../assert");
const event_1 = require("../../../event");
const utils_1 = require("../../../utils");
const networkMessage_1 = require("../../messages/networkMessage");
const rpcNetworkMessage_1 = require("../../messages/rpcNetworkMessage");
const types_1 = require("../../types");
const version_1 = require("../../version");
const errors_1 = require("./errors");
/**
 * The type of peer connection. This should only be used for information
 * reporting purposes. Switching on the type indicates an api design flaw,
 * as peers should generally behave identically once connected.
 */
var ConnectionType;
(function (ConnectionType) {
    ConnectionType["WebSocket"] = "WebSocket";
    ConnectionType["WebRtc"] = "WebRtc";
})(ConnectionType = exports.ConnectionType || (exports.ConnectionType = {}));
var ConnectionDirection;
(function (ConnectionDirection) {
    ConnectionDirection["Inbound"] = "Inbound";
    ConnectionDirection["Outbound"] = "Outbound";
})(ConnectionDirection = exports.ConnectionDirection || (exports.ConnectionDirection = {}));
/**
 * Model any connection that can send and receive messages.
 */
class Connection {
    constructor(type, direction, logger, metrics, options = {}) {
        this.handshakeTimeout = null;
        /**
         * If set will simulate a random amount of latency up to this number
         */
        this.simulateLatency = 0;
        /**
         * Indicates the current state of the connection.
         */
        this._state = { type: 'DISCONNECTED' };
        /**
         * Event fired when the state of the connection changes.
         */
        this.onStateChanged = new event_1.Event();
        /**
         * Event fired when a new message comes in.
         */
        this.onMessage = new event_1.Event();
        this.type = type;
        this.direction = direction;
        this.logger = logger;
        this.metrics = metrics || null;
        this._error = null;
        this.simulateLatency = options.simulateLatency || 0;
        this.simulateLatencyQueue = [];
    }
    get error() {
        return this._error;
    }
    get state() {
        return this._state;
    }
    /**
     * The loggable name of the connection.
     */
    get displayName() {
        const name = this.state.type === 'CONNECTED' ? this.state.identity.slice(0, 7) : 'unidentified';
        return `${this.type} ${name}`;
    }
    send(object) {
        const data = object.serialize();
        const byteCount = data.byteLength;
        if (byteCount >= version_1.MAX_MESSAGE_SIZE) {
            this.logger.warn(`Attempted to send a message that exceeds the maximum size. ${object.type} (${byteCount})`);
            return false;
        }
        if (this.shouldLogMessageType(object.type)) {
            this.logger.debug(`${safe_1.default.yellow('SEND')} ${this.displayName}: ${networkMessage_1.displayNetworkMessageType(object.type)}`);
        }
        let sendResult;
        try {
            sendResult = this._send(data);
        }
        catch (e) {
            this.logger.debug(`Error occurred while sending ${networkMessage_1.displayNetworkMessageType(object.type)} message in state ${this.state.type} ${utils_1.ErrorUtils.renderError(e)}`);
            this.close(e);
            return false;
        }
        if (sendResult) {
            this.metrics?.p2p_OutboundTraffic.add(byteCount);
            this.metrics?.p2p_OutboundTrafficByMessage.get(object.type)?.add(byteCount);
            if (this.type === ConnectionType.WebRtc) {
                this.metrics?.p2p_OutboundTraffic_WebRTC.add(byteCount);
            }
            else if (this.type === ConnectionType.WebSocket) {
                this.metrics?.p2p_OutboundTraffic_WS.add(byteCount);
            }
            else {
                assert_1.Assert.isUnreachable(this.type);
            }
        }
        return sendResult;
    }
    setState(state) {
        const prevState = this._state;
        this._state = state;
        if (prevState.type !== state.type) {
            if (this.handshakeTimeout) {
                // Clear handshakeTimeout because were changing state
                // and we have a timeout per handshake phase or were
                // done doing the handshake
                clearTimeout(this.handshakeTimeout);
                this.handshakeTimeout = null;
            }
            if (state.type === 'CONNECTING' ||
                state.type === 'REQUEST_SIGNALING' ||
                state.type === 'SIGNALING' ||
                state.type === 'WAITING_FOR_IDENTITY') {
                const timeout = rpcNetworkMessage_1.RPC_TIMEOUT_MILLIS;
                this.handshakeTimeout = setTimeout(() => {
                    const error = `Closing ${this.type} connection because handshake timed out in state ${state.type} after ${timeout}ms`;
                    this.logger.debug(error);
                    this.close(new errors_1.HandshakeTimeoutError(state.type, timeout, error));
                }, timeout);
            }
            if (state.type === 'CONNECTED') {
                this._error = null;
            }
            this.logger.debug(`${safe_1.default.green('CONN')} ${this.displayName} STATE ${prevState.type} -> ${state.type}`);
        }
        this.onStateChanged.emit();
    }
    /**
     * Replaces the connection.send() function with one that randomly delays outbound messages
     */
    addLatencyWrapper() {
        if (!this.simulateLatency) {
            return;
        }
        const originalSend = this.send.bind(this);
        const wrapper = (...args) => {
            const message = args[0];
            this.simulateLatencyQueue.push(message);
            let latency = Math.random() * (this.simulateLatency || 0);
            if (args[0].type === types_1.NetworkMessageType.Disconnecting) {
                latency = 0;
            }
            setTimeout(() => {
                const toSend = this.simulateLatencyQueue.shift();
                if (this.state.type !== 'DISCONNECTED' && toSend) {
                    originalSend(toSend);
                }
            }, latency);
            // TODO: Not currently possible to propagate connection errors from sending
            return true;
        };
        this.send = wrapper;
    }
    shouldLogMessageType(messageType) {
        const bannedMessageTypes = [types_1.NetworkMessageType.PeerList, types_1.NetworkMessageType.Signal];
        return !bannedMessageTypes.includes(messageType);
    }
}
exports.Connection = Connection;
//# sourceMappingURL=connection.js.map