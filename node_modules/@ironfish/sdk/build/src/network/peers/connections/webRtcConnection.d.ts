/// <reference types="node" />
import type { Logger } from '../../../logger';
import nodeDataChannel from 'node-datachannel';
import { Event } from '../../../event';
import { MetricsMonitor } from '../../../metrics';
import { Connection } from './connection';
export declare type SignalData = {
    type: nodeDataChannel.DescriptionType;
    sdp: string;
} | CandidateSignal;
declare type CandidateSignal = {
    type: 'candidate';
    candidate: {
        candidate: string;
        sdpMid: string;
        sdpMLineIndex: number;
    };
};
/**
 * Light wrapper of node-datachannel that knows how to send and receive
 * LooseMessages instead of strings/data.
 */
export declare class WebRtcConnection extends Connection {
    private readonly peer;
    private datachannel;
    /**
     * True if we've received an SDP message from the peer.
     */
    private receivedDescription;
    /**
     * Queue for ICE candidates until we've received an SDP message from the peer.
     */
    private candidateQueue;
    /**
     * Event fired when the PeerConnection has an SDP message or ICE candidate to send to
     * the remote peer.
     */
    onSignal: Event<[SignalData]>;
    constructor(initiator: boolean, logger: Logger, metrics?: MetricsMonitor, options?: {
        simulateLatency?: number;
        stunServers?: string[];
    });
    initializeDataChannel(dc: nodeDataChannel.DataChannel): void;
    /**
     * Inject a signal from the peer during the connection negotiation phase
     */
    signal(data: SignalData): void;
    _send: (data: Buffer) => boolean;
    /**
     * Close the connection
     */
    close: (error?: unknown) => void;
}
export {};
//# sourceMappingURL=webRtcConnection.d.ts.map