"use strict";
/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/. */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.WebRtcConnection = void 0;
const safe_1 = __importDefault(require("colors/safe"));
const node_datachannel_1 = __importDefault(require("node-datachannel"));
const assert_1 = require("../../../assert");
const event_1 = require("../../../event");
const utils_1 = require("../../../utils");
const messageRegistry_1 = require("../../messageRegistry");
const networkMessage_1 = require("../../messages/networkMessage");
const version_1 = require("../../version");
const connection_1 = require("./connection");
const errors_1 = require("./errors");
/**
 * Light wrapper of node-datachannel that knows how to send and receive
 * LooseMessages instead of strings/data.
 */
class WebRtcConnection extends connection_1.Connection {
    constructor(initiator, logger, metrics, options = {}) {
        super(connection_1.ConnectionType.WebRtc, initiator ? connection_1.ConnectionDirection.Outbound : connection_1.ConnectionDirection.Inbound, logger.withTag('webrtcconnection'), metrics, options);
        this.datachannel = null;
        /**
         * True if we've received an SDP message from the peer.
         */
        this.receivedDescription = false;
        /**
         * Queue for ICE candidates until we've received an SDP message from the peer.
         */
        this.candidateQueue = [];
        /**
         * Event fired when the PeerConnection has an SDP message or ICE candidate to send to
         * the remote peer.
         */
        this.onSignal = new event_1.Event();
        this._send = (data) => {
            if (!this.datachannel) {
                return false;
            }
            if (!this.datachannel.isOpen()) {
                this.logger.debug('Datachannel no longer open, closing connection');
                this.close();
                return false;
            }
            this.datachannel.sendMessageBinary(data);
            return true;
        };
        /**
         * Close the connection
         */
        this.close = (error) => {
            if (error) {
                if (!(error instanceof Error)) {
                    this.logger.warn(`Error in close() not an instance of Error: ${JSON.stringify(error)}`);
                }
                this._error = error;
            }
            this.setState({ type: 'DISCONNECTED' });
            this.datachannel?.close();
            try {
                this.peer.destroy();
            }
            catch (e) {
                // peer.destroy() may throw "It seems peer-connection is closed" if the
                // peer connection has been disposed already
            }
            this.datachannel = null;
        };
        if (this.simulateLatency) {
            this.addLatencyWrapper();
        }
        this.peer = new node_datachannel_1.default.PeerConnection('peer', {
            iceServers: options.stunServers ?? [],
            maxMessageSize: version_1.MAX_MESSAGE_SIZE,
        });
        this.setState({ type: 'CONNECTING' });
        this.peer.onLocalDescription((sdp, type) => {
            // The TypeScript types for "type" in this callback might not be accurate.
            // They should be https://www.w3.org/TR/webrtc/#dom-rtcsdptype
            if (this.state.type !== 'CONNECTED' && this.state.type !== 'WAITING_FOR_IDENTITY') {
                this.setState({ type: 'SIGNALING' });
            }
            this.onSignal.emit({ type, sdp });
        });
        this.peer.onLocalCandidate((candidate, mid) => {
            if (this.state.type !== 'CONNECTED' && this.state.type !== 'WAITING_FOR_IDENTITY') {
                this.setState({ type: 'SIGNALING' });
            }
            this.onSignal.emit({
                type: 'candidate',
                candidate: {
                    candidate: candidate,
                    sdpMid: mid,
                    // sdpMLineIndex isn't used by node-datachannel, but helps compatibility
                    // with node-webrtc (and probably browser WebRTC)
                    sdpMLineIndex: 0,
                },
            });
        });
        this.peer.onDataChannel((dc) => {
            assert_1.Assert.isNull(this.datachannel);
            this.initializeDataChannel(dc);
        });
        if (initiator) {
            this.initializeDataChannel(this.peer.createDataChannel(''));
        }
    }
    initializeDataChannel(dc) {
        this.datachannel = dc;
        this.datachannel.onOpen(() => {
            if (this.state.type !== 'WAITING_FOR_IDENTITY' && this.state.type !== 'CONNECTED') {
                this.setState({ type: 'WAITING_FOR_IDENTITY' });
            }
        });
        this.datachannel.onError((e) => {
            this.close(new errors_1.NetworkError(e));
        });
        this.datachannel.onClosed(() => {
            this.close();
        });
        this.datachannel.onMessage((data) => {
            const bufferData = Buffer.from(data);
            const byteCount = bufferData.byteLength;
            this.metrics?.p2p_InboundTraffic.add(byteCount);
            this.metrics?.p2p_InboundTraffic_WebRTC.add(byteCount);
            let message;
            try {
                message = messageRegistry_1.parseNetworkMessage(bufferData);
            }
            catch (error) {
                this.logger.warn(`Unable to parse webrtc message`);
                this.close(error);
                return;
            }
            this.metrics?.p2p_InboundTrafficByMessage.get(message.type)?.add(byteCount);
            if (this.shouldLogMessageType(message.type)) {
                this.logger.debug(`${safe_1.default.yellow('RECV')} ${this.displayName}: ${networkMessage_1.displayNetworkMessageType(message.type)}`);
            }
            this.onMessage.emit(message);
        });
    }
    /**
     * Inject a signal from the peer during the connection negotiation phase
     */
    signal(data) {
        try {
            if (this.state.type === 'DISCONNECTED' || this.state.type === 'CONNECTING') {
                this.setState({ type: 'SIGNALING' });
            }
            if (data.type === 'candidate') {
                if (this.receivedDescription) {
                    this.peer.addRemoteCandidate(data.candidate.candidate, data.candidate.sdpMid);
                }
                else {
                    this.candidateQueue.push(data);
                }
            }
            else {
                this.peer.setRemoteDescription(data.sdp, data.type);
                this.receivedDescription = true;
                while (this.candidateQueue.length > 0) {
                    const data = this.candidateQueue.shift();
                    if (data) {
                        this.peer.addRemoteCandidate(data.candidate.candidate, data.candidate.sdpMid);
                    }
                }
            }
        }
        catch (error) {
            const err = new errors_1.NetworkError('An error occurred when loading signaling data', error);
            this.logger.debug(utils_1.ErrorUtils.renderError(err));
            this.close(err);
        }
    }
}
exports.WebRtcConnection = WebRtcConnection;
//# sourceMappingURL=webRtcConnection.js.map