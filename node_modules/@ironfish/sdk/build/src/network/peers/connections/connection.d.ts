/// <reference types="node" />
import type { Logger } from '../../../logger';
import { Event } from '../../../event';
import { MetricsMonitor } from '../../../metrics';
import { Identity } from '../../identity';
import { NetworkMessage } from '../../messages/networkMessage';
import { NetworkMessageType } from '../../types';
/**
 * The type of peer connection. This should only be used for information
 * reporting purposes. Switching on the type indicates an api design flaw,
 * as peers should generally behave identically once connected.
 */
export declare enum ConnectionType {
    WebSocket = "WebSocket",
    WebRtc = "WebRtc"
}
export declare enum ConnectionDirection {
    Inbound = "Inbound",
    Outbound = "Outbound"
}
declare type ConnectionState = {
    type: 'DISCONNECTED';
} | {
    type: 'CONNECTING';
} | {
    type: 'REQUEST_SIGNALING';
} | {
    type: 'SIGNALING';
} | {
    type: 'WAITING_FOR_IDENTITY';
} | {
    type: 'CONNECTED';
    identity: Identity;
};
/**
 * Model any connection that can send and receive messages.
 */
export declare abstract class Connection {
    readonly logger: Logger;
    readonly metrics: MetricsMonitor | null;
    readonly type: ConnectionType;
    readonly direction: ConnectionDirection;
    private handshakeTimeout;
    /**
     * If set will simulate a random amount of latency up to this number
     */
    protected readonly simulateLatency: number;
    protected readonly simulateLatencyQueue: Array<NetworkMessage>;
    /**
     * The last error received (if any), regardless of the current state of the connection.
     */
    protected _error: unknown | null;
    get error(): Readonly<unknown> | null;
    /**
     * Indicates the current state of the connection.
     */
    private _state;
    get state(): Readonly<ConnectionState>;
    /**
     * The loggable name of the connection.
     */
    get displayName(): string;
    /**
     * Event fired when the state of the connection changes.
     */
    readonly onStateChanged: Event<[]>;
    /**
     * Event fired when a new message comes in.
     */
    readonly onMessage: Event<[NetworkMessage]>;
    /**
     * Send a message into this connection.
     */
    abstract _send: (data: Buffer) => boolean;
    /**
     * Shutdown the connection, if possible
     */
    abstract readonly close: (error?: unknown) => void;
    constructor(type: ConnectionType, direction: ConnectionDirection, logger: Logger, metrics?: MetricsMonitor, options?: {
        simulateLatency?: number;
    });
    send(object: NetworkMessage): boolean;
    setState(state: Readonly<ConnectionState>): void;
    /**
     * Replaces the connection.send() function with one that randomly delays outbound messages
     */
    protected addLatencyWrapper(): void;
    shouldLogMessageType(messageType: NetworkMessageType): boolean;
}
export {};
//# sourceMappingURL=connection.d.ts.map