"use strict";
/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/. */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.WebSocketConnection = void 0;
const safe_1 = __importDefault(require("colors/safe"));
const messageRegistry_1 = require("../../messageRegistry");
const networkMessage_1 = require("../../messages/networkMessage");
const connection_1 = require("./connection");
const errors_1 = require("./errors");
/**
 * Light wrapper of node+browser WebSockets that knows how to send and receive
 * LooseMessages instead of strings/data.
 */
class WebSocketConnection extends connection_1.Connection {
    constructor(socket, direction, logger, metrics, options = {}) {
        super(connection_1.ConnectionType.WebSocket, direction, logger.withTag('WebSocketConnection'), metrics, options);
        this._send = (data) => {
            this.socket.send(data);
            return true;
        };
        /**
         * Close the connection
         */
        this.close = (error) => {
            if (error) {
                if (!(error instanceof Error)) {
                    this.logger.warn(`Error in close() not an instance of Error: ${JSON.stringify(error)}`);
                }
                this._error = error;
            }
            this.setState({ type: 'DISCONNECTED' });
            // Unbind event handlers, they can still fire with buffered inbound messages after
            // the socket is closed. onerror is intentionally left intact, since it will
            // trigger if a WebSocket is closed before the connection was established
            this.socket.onmessage = null;
            this.socket.onclose = null;
            this.socket.onopen = null;
            this.socket.close();
        };
        this.socket = socket;
        this.hostname = options.hostname;
        this.port = options.port;
        if (this.simulateLatency) {
            this.addLatencyWrapper();
        }
        if (this.socket.readyState === this.socket.OPEN) {
            this.setState({ type: 'WAITING_FOR_IDENTITY' });
        }
        else {
            this.setState({ type: 'CONNECTING' });
        }
        this.socket.onerror = (...args) => {
            // Browser WebSockets call onerror with (this, ErrorEvent), but the ws library
            // calls onerror with (ErrorEvent), so grab ErrorEvent in either case
            let error = null;
            if (args.length === 1) {
                error = args[0];
            }
            else if (args.length === 2) {
                error = args[1];
            }
            this.close(new errors_1.NetworkError(error?.message, error));
        };
        this.socket.onclose = () => {
            this.setState({ type: 'DISCONNECTED' });
        };
        this.socket.onopen = () => {
            this.setState({ type: 'WAITING_FOR_IDENTITY' });
        };
        this.socket.onmessage = (event) => {
            if (!Buffer.isBuffer(event.data)) {
                const message = 'Received non-buffer message';
                this.logger.debug(message, event.data);
                this.close(new errors_1.NetworkError(message));
                return;
            }
            this.metrics?.p2p_InboundTraffic.add(event.data.byteLength);
            this.metrics?.p2p_InboundTraffic_WS.add(event.data.byteLength);
            let message;
            try {
                message = messageRegistry_1.parseNetworkMessage(event.data);
                this.metrics?.p2p_InboundTrafficByMessage.get(message.type)?.add(event.data.byteLength);
            }
            catch (error) {
                // TODO: any socket that sends invalid messages should probably
                // be punished with some kind of "downgrade" event. This should
                // probably happen at a higher layer of abstraction
                const message = 'Error parsing message';
                this.logger.warn(message);
                this.close(new errors_1.NetworkError(message));
                return;
            }
            if (this.shouldLogMessageType(message.type)) {
                this.logger.debug(`${safe_1.default.yellow('RECV')} ${this.displayName}: ${networkMessage_1.displayNetworkMessageType(message.type)}`);
            }
            this.onMessage.emit(message);
        };
    }
}
exports.WebSocketConnection = WebSocketConnection;
//# sourceMappingURL=webSocketConnection.js.map