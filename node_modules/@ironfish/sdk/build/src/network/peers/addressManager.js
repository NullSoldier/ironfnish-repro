"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.AddressManager = void 0;
const utils_1 = require("../../utils");
/**
 * AddressManager stores the necessary data for connecting to new peers
 * and provides functionality for persistence of said data.
 */
class AddressManager {
    constructor(hostsStore, peerManager) {
        this.hostsStore = hostsStore;
        this.peerManager = peerManager;
    }
    get priorConnectedPeerAddresses() {
        return this.hostsStore.getArray('priorPeers');
    }
    /**
     * Returns a peer address for a disconnected peer by using current peers to
     * filter out peer addresses. It attempts to find a previously-connected
     * peer address that is not part of an active connection.
     */
    getRandomDisconnectedPeerAddress(peerIdentities) {
        if (this.priorConnectedPeerAddresses.length === 0) {
            return null;
        }
        const currentPeerIdentities = new Set(peerIdentities);
        const disconnectedPriorAddresses = this.filterConnectedIdentities(this.priorConnectedPeerAddresses, currentPeerIdentities);
        if (disconnectedPriorAddresses.length) {
            return utils_1.ArrayUtils.sampleOrThrow(disconnectedPriorAddresses);
        }
        return null;
    }
    filterConnectedIdentities(priorConnectedAddresses, connectedPeerIdentities) {
        const disconnectedAddresses = priorConnectedAddresses.filter((address) => address.identity !== null && !connectedPeerIdentities.has(address.identity));
        return disconnectedAddresses;
    }
    /**
     * Removes address associated with a peer from address stores
     */
    removePeerAddress(peer) {
        const filteredPriorConnected = this.priorConnectedPeerAddresses.filter((prior) => prior.identity !== peer.state.identity);
        this.hostsStore.set('priorPeers', filteredPriorConnected);
    }
    /**
     * Persist all currently connected peers to disk
     */
    async save() {
        // TODO: Ideally, we would like persist peers with whom we've
        // successfully established an outbound Websocket connection at
        // least once.
        const inUsePeerAddresses = this.peerManager.peers.flatMap((peer) => {
            if (peer.state.type === 'CONNECTED') {
                return {
                    address: peer.address,
                    port: peer.port,
                    identity: peer.state.identity ?? null,
                    name: peer.name ?? null,
                };
            }
            else {
                return [];
            }
        });
        this.hostsStore.set('priorPeers', inUsePeerAddresses);
        await this.hostsStore.save();
    }
}
exports.AddressManager = AddressManager;
//# sourceMappingURL=addressManager.js.map