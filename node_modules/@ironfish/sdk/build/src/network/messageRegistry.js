"use strict";
/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/. */
Object.defineProperty(exports, "__esModule", { value: true });
exports.isRpcNetworkMessageType = exports.parseNetworkMessage = void 0;
const cannotSatisfyRequest_1 = require("./messages/cannotSatisfyRequest");
const disconnecting_1 = require("./messages/disconnecting");
const getBlockHeaders_1 = require("./messages/getBlockHeaders");
const getBlocks_1 = require("./messages/getBlocks");
const getBlockTransactions_1 = require("./messages/getBlockTransactions");
const getCompactBlock_1 = require("./messages/getCompactBlock");
const identify_1 = require("./messages/identify");
const networkMessage_1 = require("./messages/networkMessage");
const newBlockHashes_1 = require("./messages/newBlockHashes");
const newCompactBlock_1 = require("./messages/newCompactBlock");
const newPooledTransactionHashes_1 = require("./messages/newPooledTransactionHashes");
const newTransactions_1 = require("./messages/newTransactions");
const peerList_1 = require("./messages/peerList");
const peerListRequest_1 = require("./messages/peerListRequest");
const pooledTransactions_1 = require("./messages/pooledTransactions");
const rpcNetworkMessage_1 = require("./messages/rpcNetworkMessage");
const signal_1 = require("./messages/signal");
const signalRequest_1 = require("./messages/signalRequest");
const types_1 = require("./types");
const parseNetworkMessage = (buffer) => {
    const { type, remaining: body } = networkMessage_1.NetworkMessage.deserializeType(buffer);
    if (exports.isRpcNetworkMessageType(type)) {
        return parseRpcNetworkMessage(type, body);
    }
    return parseGenericNetworkMessage(type, body);
};
exports.parseNetworkMessage = parseNetworkMessage;
const isRpcNetworkMessageType = (type) => {
    return [
        types_1.NetworkMessageType.CannotSatisfyRequest,
        types_1.NetworkMessageType.GetBlocksRequest,
        types_1.NetworkMessageType.GetBlocksResponse,
        types_1.NetworkMessageType.PooledTransactionsRequest,
        types_1.NetworkMessageType.PooledTransactionsResponse,
        types_1.NetworkMessageType.GetBlockTransactionsRequest,
        types_1.NetworkMessageType.GetBlockTransactionsResponse,
        types_1.NetworkMessageType.GetCompactBlockRequest,
        types_1.NetworkMessageType.GetCompactBlockResponse,
        types_1.NetworkMessageType.GetBlockHeadersRequest,
        types_1.NetworkMessageType.GetBlockHeadersResponse,
    ].includes(type);
};
exports.isRpcNetworkMessageType = isRpcNetworkMessageType;
const parseRpcNetworkMessage = (type, bodyWithHeader) => {
    const { rpcId, remaining: body } = rpcNetworkMessage_1.RpcNetworkMessage.deserializeHeader(bodyWithHeader);
    switch (type) {
        case types_1.NetworkMessageType.CannotSatisfyRequest:
            return cannotSatisfyRequest_1.CannotSatisfyRequest.deserializePayload(rpcId);
        case types_1.NetworkMessageType.GetBlocksRequest:
            return getBlocks_1.GetBlocksRequest.deserializePayload(body, rpcId);
        case types_1.NetworkMessageType.GetBlocksResponse:
            return getBlocks_1.GetBlocksResponse.deserializePayload(body, rpcId);
        case types_1.NetworkMessageType.PooledTransactionsRequest:
            return pooledTransactions_1.PooledTransactionsRequest.deserializePayload(body, rpcId);
        case types_1.NetworkMessageType.PooledTransactionsResponse:
            return pooledTransactions_1.PooledTransactionsResponse.deserializePayload(body, rpcId);
        case types_1.NetworkMessageType.GetBlockTransactionsRequest:
            return getBlockTransactions_1.GetBlockTransactionsRequest.deserializePayload(body, rpcId);
        case types_1.NetworkMessageType.GetBlockTransactionsResponse:
            return getBlockTransactions_1.GetBlockTransactionsResponse.deserializePayload(body, rpcId);
        case types_1.NetworkMessageType.GetCompactBlockRequest:
            return getCompactBlock_1.GetCompactBlockRequest.deserializePayload(body, rpcId);
        case types_1.NetworkMessageType.GetCompactBlockResponse:
            return getCompactBlock_1.GetCompactBlockResponse.deserializePayload(body, rpcId);
        case types_1.NetworkMessageType.GetBlockHeadersRequest:
            return getBlockHeaders_1.GetBlockHeadersRequest.deserializePayload(body, rpcId);
        case types_1.NetworkMessageType.GetBlockHeadersResponse:
            return getBlockHeaders_1.GetBlockHeadersResponse.deserializePayload(body, rpcId);
        default:
            throw new Error(`Unknown RPC network message type: ${type}`);
    }
};
const parseGenericNetworkMessage = (type, body) => {
    switch (type) {
        case types_1.NetworkMessageType.Disconnecting:
            return disconnecting_1.DisconnectingMessage.deserializePayload(body);
        case types_1.NetworkMessageType.Identify:
            return identify_1.IdentifyMessage.deserializePayload(body);
        case types_1.NetworkMessageType.PeerList:
            return peerList_1.PeerListMessage.deserializePayload(body);
        case types_1.NetworkMessageType.PeerListRequest:
            return peerListRequest_1.PeerListRequestMessage.deserializePayload();
        case types_1.NetworkMessageType.Signal:
            return signal_1.SignalMessage.deserializePayload(body);
        case types_1.NetworkMessageType.SignalRequest:
            return signalRequest_1.SignalRequestMessage.deserializePayload(body);
        case types_1.NetworkMessageType.NewPooledTransactionHashes:
            return newPooledTransactionHashes_1.NewPooledTransactionHashes.deserializePayload(body);
        case types_1.NetworkMessageType.NewTransactions:
            return newTransactions_1.NewTransactionsMessage.deserializePayload(body);
        case types_1.NetworkMessageType.NewBlockHashes:
            return newBlockHashes_1.NewBlockHashesMessage.deserializePayload(body);
        case types_1.NetworkMessageType.NewCompactBlock:
            return newCompactBlock_1.NewCompactBlockMessage.deserializePayload(body);
        default:
            throw new Error(`Unknown network message type: ${type}`);
    }
};
//# sourceMappingURL=messageRegistry.js.map