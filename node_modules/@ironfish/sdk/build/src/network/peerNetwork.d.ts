/// <reference types="node" />
import { Blockchain } from '../blockchain';
import { Event } from '../event';
import { HostsStore } from '../fileStores/hosts';
import { Logger } from '../logger';
import { MetricsMonitor } from '../metrics';
import { FullNode } from '../node';
import { Transaction } from '../primitives';
import { Block } from '../primitives/block';
import { BlockHash, BlockHeader } from '../primitives/blockheader';
import { TransactionHash } from '../primitives/transaction';
import { Telemetry } from '../telemetry';
import { Identity, PrivateIdentity } from './identity';
import { LocalPeer } from './peers/localPeer';
import { Peer } from './peers/peer';
import { PeerManager } from './peers/peerManager';
import { IsomorphicWebSocketConstructor } from './types';
export declare type TransactionOrHash = {
    type: 'FULL';
    value: Transaction;
} | {
    type: 'HASH';
    value: TransactionHash;
};
/**
 * Entry point for the peer-to-peer network. Manages connections to other peers on the network
 * and provides abstractions for several methods of sending/receiving network messages.
 */
export declare class PeerNetwork {
    private readonly networkId;
    private webSocketServer?;
    private readonly incomingWebSocketWhitelist;
    readonly localPeer: LocalPeer;
    readonly peerManager: PeerManager;
    readonly onIsReadyChanged: Event<[boolean]>;
    readonly onTransactionAccepted: Event<[transaction: Transaction, received: Date]>;
    readonly onBlockGossipReceived: Event<[BlockHeader]>;
    readonly onTransactionGossipReceived: Event<[transaction: Transaction, valid: boolean]>;
    private started;
    private readonly minPeers;
    private readonly bootstrapNodes;
    private readonly listen;
    private readonly peerConnectionManager;
    private readonly logger;
    private readonly metrics;
    private readonly telemetry;
    private readonly node;
    private readonly chain;
    private readonly requests;
    private readonly enableSyncing;
    private readonly blockFetcher;
    private readonly transactionFetcher;
    private readonly recentlyAddedToChain;
    private readonly knownTransactionFilter;
    /**
     * If the peer network is ready for messages to be sent or not
     */
    private _isReady;
    get isReady(): boolean;
    constructor(options: {
        networkId: number;
        identity: PrivateIdentity;
        agent?: string;
        webSocket: IsomorphicWebSocketConstructor;
        listen?: boolean;
        port?: number;
        bootstrapNodes?: string[];
        stunServers?: string[];
        name?: string | null;
        maxPeers?: number;
        minPeers?: number;
        targetPeers?: number;
        enableSyncing?: boolean;
        logPeerMessages?: boolean;
        simulateLatency?: number;
        logger?: Logger;
        metrics?: MetricsMonitor;
        telemetry: Telemetry;
        node: FullNode;
        chain: Blockchain;
        hostsStore: HostsStore;
        incomingWebSocketWhitelist?: string[];
    });
    start(): void;
    /**
     * Call close when shutting down the PeerNetwork to clean up
     * outstanding connections.
     */
    stop(): Promise<void>;
    /**
     * Send a compact block to a sqrt subset of peers who haven't yet received the block
     */
    private broadcastBlock;
    /**
     * Send a block hash to all connected peers who haven't yet received the block.
     */
    private broadcastBlockHash;
    /**
     * Send out the transaction only to peers that have not yet heard about it.
     * The full transaction will be sent to a subset of sqrt(num_peers)
     * and the rest of the peers will receive the transaction hash
     */
    broadcastTransaction(transaction: Transaction): void;
    knowsTransaction(hash: TransactionHash, peerId: Identity): boolean;
    private markKnowsTransaction;
    private connectedPeersWithoutTransaction;
    private connectedPeersWithoutBlock;
    /**
     * Fire an RPC request to the given peer identity. Returns a promise that
     * will resolve when the response is received, or will be rejected if the
     * request cannot be completed before timing out.
     */
    private requestFrom;
    getBlockHeaders(peer: Peer, start: number | Buffer, limit: number, skip?: number, reverse?: boolean): Promise<{
        headers: BlockHeader[];
        time: number;
    }>;
    getBlocks(peer: Peer, start: Buffer, limit: number): Promise<{
        blocks: Block[];
        time: number;
        isMessageFull: boolean;
    }>;
    private handleMessage;
    /**
     * Handle an incoming RPC message. This may be an incoming request for some
     * data, or an incoming response to one of our requests.
     *
     * If it is a request, we pass it to the handler registered for it.
     * If a response, we resolve the promise waiting for it.
     *
     * The handler for a given request should either return a payload or throw
     * a CannotSatisfyRequest error
     */
    private handleRpcMessage;
    private handleNewBlockHashesMessage;
    private onNewBlockTransactions;
    private onNewCompactBlock;
    private handleNewPooledTransactionHashes;
    private updateIsReady;
    private onGetBlockHeadersRequest;
    private onGetBlocksRequest;
    private onPooledTransactionsRequest;
    private onGetBlockTransactionsRequest;
    private onGetCompactBlockRequest;
    private handleRequestedBlock;
    private onNewFullBlock;
    private shouldProcessNewBlocks;
    private shouldProcessTransactions;
    alreadyHaveBlock(headerOrHash: BlockHeader | BlockHash): Promise<boolean>;
    private onNewTransaction;
}
//# sourceMappingURL=peerNetwork.d.ts.map