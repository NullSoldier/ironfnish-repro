"use strict";
/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/. */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.GetBlockHeadersResponse = exports.GetBlockHeadersRequest = void 0;
const bufio_1 = __importDefault(require("bufio"));
const types_1 = require("../types");
const serializers_1 = require("../utils/serializers");
const rpcNetworkMessage_1 = require("./rpcNetworkMessage");
class GetBlockHeadersRequest extends rpcNetworkMessage_1.RpcNetworkMessage {
    constructor(start, limit, skip, reverse, rpcId) {
        super(types_1.NetworkMessageType.GetBlockHeadersRequest, rpcNetworkMessage_1.Direction.Request, rpcId);
        this.start = start;
        this.limit = limit;
        this.skip = skip;
        this.reverse = reverse;
    }
    serializePayload(bw) {
        if (Buffer.isBuffer(this.start)) {
            bw.writeU8(1);
            bw.writeHash(this.start);
        }
        else {
            bw.writeU8(0);
            bw.writeU32(this.start);
        }
        bw.writeU16(this.limit);
        bw.writeU16(this.skip);
        bw.writeU8(Number(this.reverse));
    }
    static deserializePayload(buffer, rpcId) {
        const reader = bufio_1.default.read(buffer, true);
        const isBuffer = Boolean(reader.readU8());
        const start = isBuffer ? reader.readHash() : reader.readU32();
        const limit = reader.readU16();
        const skip = reader.readU16();
        const reverse = Boolean(reader.readU8());
        return new GetBlockHeadersRequest(start, limit, skip, reverse, rpcId);
    }
    getSize() {
        let size = 0;
        size += 1; // is buffer flag
        if (Buffer.isBuffer(this.start)) {
            size += 32; // start as hash
        }
        else {
            size += 4; // start as number
        }
        size += 2; // limit
        size += 2; // skip
        size += 1; // reverse
        return size;
    }
}
exports.GetBlockHeadersRequest = GetBlockHeadersRequest;
class GetBlockHeadersResponse extends rpcNetworkMessage_1.RpcNetworkMessage {
    constructor(headers, rpcId) {
        super(types_1.NetworkMessageType.GetBlockHeadersResponse, rpcNetworkMessage_1.Direction.Response, rpcId);
        this.headers = headers;
    }
    serializePayload(bw) {
        bw.writeU16(this.headers.length);
        for (const header of this.headers) {
            serializers_1.writeBlockHeader(bw, header);
        }
    }
    static deserializePayload(buffer, rpcId) {
        const reader = bufio_1.default.read(buffer, true);
        const headers = [];
        const headersLength = reader.readU16();
        for (let i = 0; i < headersLength; i++) {
            const header = serializers_1.readBlockHeader(reader);
            headers.push(header);
        }
        return new GetBlockHeadersResponse(headers, rpcId);
    }
    getSize() {
        let size = 0;
        size += 2; // headers length
        size += serializers_1.getBlockHeaderSize() * this.headers.length;
        return size;
    }
}
exports.GetBlockHeadersResponse = GetBlockHeadersResponse;
//# sourceMappingURL=getBlockHeaders.js.map