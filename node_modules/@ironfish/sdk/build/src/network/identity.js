"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.privateIdentityToIdentity = exports.canKeepDuplicateConnection = exports.canInitiateWebRTC = exports.isIdentity = exports.base64IdentityLength = exports.secretKeyLength = exports.identityLength = void 0;
/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/. */
const rust_nodejs_1 = require("@ironfish/rust-nodejs");
/**
 * Length of the identity in bytes.
 */
exports.identityLength = rust_nodejs_1.KEY_LENGTH;
/**
 * Length of the secret key from PrivateIdentity in bytes.
 */
exports.secretKeyLength = rust_nodejs_1.KEY_LENGTH;
/**
 * Length of the identity as a base64-encoded string.
 */
exports.base64IdentityLength = Math.ceil(exports.identityLength / 3) * 4;
function isIdentity(obj) {
    // Should be a base64-encoded string with the expected length
    return (obj.length === exports.base64IdentityLength && Buffer.from(obj, 'base64').toString('base64') === obj);
}
exports.isIdentity = isIdentity;
function canInitiateWebRTC(source, dest) {
    return source > dest;
}
exports.canInitiateWebRTC = canInitiateWebRTC;
function canKeepDuplicateConnection(source, dest) {
    return canInitiateWebRTC(source, dest);
}
exports.canKeepDuplicateConnection = canKeepDuplicateConnection;
function privateIdentityToIdentity(identity) {
    return Buffer.from(identity.publicKey).toString('base64');
}
exports.privateIdentityToIdentity = privateIdentityToIdentity;
//# sourceMappingURL=identity.js.map