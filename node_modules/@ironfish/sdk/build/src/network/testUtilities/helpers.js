"use strict";
/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/. */
Object.defineProperty(exports, "__esModule", { value: true });
exports.expectGetBlocksResponseToMatch = exports.expectGetBlockHeadersResponseToMatch = exports.expectGetBlockTransactionsResponseToMatch = exports.expectGetCompactBlockResponseToMatch = exports.getSignalingWebRtcPeer = exports.getDisconnectedPeer = exports.getConnectedPeer = exports.getConnectedPeersWithSpies = exports.peerMessage = exports.getWaitingForIdentityPeer = exports.getConnectingPeer = void 0;
const assert_1 = require("../../assert");
const identity_1 = require("../identity");
const connections_1 = require("../peers/connections");
const peerFeatures_1 = require("../peers/peerFeatures");
const webSocketClient_1 = require("../webSocketClient");
const mockIdentity_1 = require("./mockIdentity");
function getConnectingPeer(pm, direction = connections_1.ConnectionDirection.Outbound, identity) {
    let peer;
    if (direction === connections_1.ConnectionDirection.Outbound) {
        peer = pm.connectToWebSocketAddress({
            host: 'testuri',
            port: 9033,
        });
    }
    else {
        peer = pm.getOrCreatePeer(identity ?? null);
        const connection = new connections_1.WebSocketConnection(new webSocketClient_1.WebSocketClient(''), connections_1.ConnectionDirection.Inbound, peer.logger);
        peer.setWebSocketConnection(connection);
    }
    assert_1.Assert.isNotUndefined(peer);
    expect(peer.state).toEqual({
        type: 'CONNECTING',
        identity: peer.state.identity,
        connections: {
            // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
            webSocket: expect.any(connections_1.WebSocketConnection),
        },
    });
    if (peer.state.type !== 'CONNECTING') {
        throw new Error('state should be CONNECTING');
    }
    if (peer.state.connections.webSocket === undefined) {
        throw new Error('WebSocket connection should be defined');
    }
    jest.spyOn(peer.state.connections.webSocket, 'send').mockImplementation(() => true);
    return { peer, connection: peer.state.connections.webSocket };
}
exports.getConnectingPeer = getConnectingPeer;
function getWaitingForIdentityPeer(pm, direction = connections_1.ConnectionDirection.Outbound, identity) {
    const { peer, connection } = getConnectingPeer(pm, direction, identity);
    connection.setState({ type: 'WAITING_FOR_IDENTITY' });
    expect(peer.state.type).toBe('CONNECTING');
    return { peer, connection: connection };
}
exports.getWaitingForIdentityPeer = getWaitingForIdentityPeer;
/* Used for constructing stubbed messages to send to the PeerManager.onMessage */
function peerMessage(peer, message) {
    return [peer, message];
}
exports.peerMessage = peerMessage;
/* Add new peers to the PeerManager and spy on peer.send() */
const getConnectedPeersWithSpies = (peerManager, count) => {
    return [...Array(count)].map((_) => {
        const { peer } = getConnectedPeer(peerManager);
        const sendSpy = jest.spyOn(peer, 'send');
        return { peer, sendSpy };
    });
};
exports.getConnectedPeersWithSpies = getConnectedPeersWithSpies;
function getConnectedPeer(pm, identity) {
    const { peer, connection } = getConnectingPeer(pm);
    if (!identity) {
        identity = jest.requireActual('uuid').v4();
    }
    if (!identity_1.isIdentity(identity)) {
        identity = mockIdentity_1.mockIdentity(identity);
    }
    connection.setState({ type: 'CONNECTED', identity });
    peer.features = peerFeatures_1.defaultFeatures();
    return { peer, connection: connection };
}
exports.getConnectedPeer = getConnectedPeer;
function getDisconnectedPeer(pm, identity) {
    if (!identity) {
        identity = jest.requireActual('uuid').v4();
    }
    if (!identity_1.isIdentity(identity)) {
        identity = mockIdentity_1.mockIdentity(identity);
    }
    const peer = pm.getOrCreatePeer(identity);
    return peer;
}
exports.getDisconnectedPeer = getDisconnectedPeer;
function getSignalingWebRtcPeer(pm, brokeringPeerIdentity, peerIdentity) {
    // Create the peers
    const { peer: brokeringPeer, connection: brokeringConnection } = getConnectedPeer(pm, brokeringPeerIdentity);
    const peer = pm.getOrCreatePeer(peerIdentity);
    // We don't expect this function to be called multiple times, so make sure
    // we're not resetting pre-existing peer candidate data.
    assert_1.Assert.isFalse(pm.peerCandidates.has(peerIdentity));
    // Link the peers
    pm.peerCandidates.addFromPeerList(brokeringPeerIdentity, {
        address: peer.address,
        port: peer.port,
        identity: Buffer.from(peerIdentity, 'base64'),
    });
    // Verify peer2 is not connected
    expect(peer.address).toBeNull();
    expect(peer.state).toEqual({
        type: 'DISCONNECTED',
        identity: peerIdentity,
    });
    pm.connectToWebRTC(peer);
    expect(peer.state).toEqual({
        type: 'CONNECTING',
        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
        connections: { webRtc: expect.any(connections_1.WebRtcConnection) },
        identity: peer.state.identity,
    });
    if (peer.state.type !== 'CONNECTING') {
        throw new Error('Peer state should be CONNECTING');
    }
    const connection = peer.state.connections.webRtc;
    // Send a signal to trigger the connection into a SIGNALING state
    connection?.signal({
        type: 'candidate',
        candidate: {
            candidate: '',
            sdpMLineIndex: 0,
            sdpMid: '0',
        },
    });
    expect(connection?.state.type).toBe('SIGNALING');
    if (connection?.state.type !== 'SIGNALING') {
        throw new Error('Connection');
    }
    return { peer, connection: connection, brokeringPeer, brokeringConnection };
}
exports.getSignalingWebRtcPeer = getSignalingWebRtcPeer;
function expectGetCompactBlockResponseToMatch(a, b) {
    // Test transactions separately because Transaction is not a primitive type
    expect(a.compactBlock.transactions.length).toEqual(b.compactBlock.transactions.length);
    a.compactBlock.transactions.forEach((transactionA, transactionIndexA) => {
        const transactionB = b.compactBlock.transactions[transactionIndexA];
        expect(transactionA.index).toEqual(transactionB.index);
        expect(transactionA.transaction.hash().equals(transactionB.transaction.hash())).toBe(true);
    });
    expect({
        ...a,
        compactBlock: { ...a.compactBlock, transactions: undefined },
    }).toMatchObject({ ...b, compactBlock: { ...b.compactBlock, transactions: undefined } });
}
exports.expectGetCompactBlockResponseToMatch = expectGetCompactBlockResponseToMatch;
function expectGetBlockTransactionsResponseToMatch(a, b) {
    // Test transactions separately because Transaction is not a primitive type
    expect(a.transactions.length).toEqual(b.transactions.length);
    a.transactions.forEach((transactionA, transactionIndexA) => {
        const transactionB = b.transactions[transactionIndexA];
        expect(transactionA.hash().equals(transactionB.hash())).toBe(true);
    });
    expect({ ...a, transactions: undefined }).toMatchObject({ ...b, transactions: undefined });
}
exports.expectGetBlockTransactionsResponseToMatch = expectGetBlockTransactionsResponseToMatch;
function expectGetBlockHeadersResponseToMatch(a, b) {
    expect(a.headers.length).toEqual(b.headers.length);
    a.headers.forEach((headerA, headerIndexA) => {
        const headerB = b.headers[headerIndexA];
        expect(headerA.hash).toEqual(headerB.hash);
    });
    expect({ ...a, headers: undefined }).toMatchObject({ ...b, headers: undefined });
}
exports.expectGetBlockHeadersResponseToMatch = expectGetBlockHeadersResponseToMatch;
function expectGetBlocksResponseToMatch(a, b) {
    expect(a.blocks.length).toEqual(b.blocks.length);
    a.blocks.forEach((blockA, blockIndexA) => {
        const blockB = b.blocks[blockIndexA];
        expect(blockA.equals(blockB)).toBe(true);
    });
    expect({ ...a, blocks: undefined }).toMatchObject({ ...b, blocks: undefined });
}
exports.expectGetBlocksResponseToMatch = expectGetBlocksResponseToMatch;
//# sourceMappingURL=helpers.js.map