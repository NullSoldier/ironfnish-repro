"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getTransactionSize = exports.readTransaction = exports.writeTransaction = exports.getCompactBlockSize = exports.readCompactBlock = exports.writeCompactBlock = exports.getBlockWithMinersFeeSize = exports.getBlockSize = exports.readBlock = exports.writeBlock = exports.getBlockHeaderSize = exports.readBlockHeader = exports.writeBlockHeader = exports.MINERS_FEE_TRANSACTION_SIZE_BYTES = void 0;
/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/. */
const bufio_1 = require("bufio");
const assert_1 = require("../../assert");
const block_1 = require("../../primitives/block");
const blockheader_1 = require("../../primitives/blockheader");
const target_1 = require("../../primitives/target");
const transaction_1 = require("../../primitives/transaction");
exports.MINERS_FEE_TRANSACTION_SIZE_BYTES = 664;
const BLOCK_TRANSACTIONS_LENGTH_BYTES = 2;
function writeBlockHeader(bw, header) {
    bw.writeU32(header.sequence);
    bw.writeHash(header.previousBlockHash);
    bw.writeHash(header.noteCommitment);
    bw.writeHash(header.transactionCommitment);
    bw.writeBigU256BE(header.target.targetValue);
    bw.writeBigU64(header.randomness);
    bw.writeU64(header.timestamp.getTime());
    assert_1.Assert.isTrue(header.graffiti.byteLength === block_1.GRAFFITI_SIZE);
    bw.writeBytes(header.graffiti);
    return bw;
}
exports.writeBlockHeader = writeBlockHeader;
function readBlockHeader(reader) {
    const sequence = reader.readU32();
    const previousBlockHash = reader.readHash();
    const noteCommitment = reader.readHash();
    const transactionCommitment = reader.readHash();
    const target = reader.readBigU256BE();
    const randomness = reader.readBigU64();
    const timestamp = reader.readU64();
    const graffiti = reader.readBytes(block_1.GRAFFITI_SIZE);
    return new blockheader_1.BlockHeader(sequence, previousBlockHash, noteCommitment, transactionCommitment, new target_1.Target(target), randomness, new Date(timestamp), graffiti);
}
exports.readBlockHeader = readBlockHeader;
function getBlockHeaderSize() {
    let size = 0;
    size += 4; // sequence
    size += 32; // previousBlockHash
    size += 32; // noteCommitment
    size += 32; // transactionCommitment
    size += 32; // target
    size += 8; // randomness
    size += 8; // timestamp
    size += block_1.GRAFFITI_SIZE; // graffiti
    return size;
}
exports.getBlockHeaderSize = getBlockHeaderSize;
function writeBlock(bw, block) {
    bw = writeBlockHeader(bw, block.header);
    bw.writeU16(block.transactions.length);
    for (const transaction of block.transactions) {
        writeTransaction(bw, transaction);
    }
    return bw;
}
exports.writeBlock = writeBlock;
function readBlock(reader) {
    const header = readBlockHeader(reader);
    const transactionsLength = reader.readU16();
    const transactions = [];
    for (let j = 0; j < transactionsLength; j++) {
        transactions.push(readTransaction(reader));
    }
    return new block_1.Block(header, transactions);
}
exports.readBlock = readBlock;
function getBlockSize(block) {
    let size = getBlockHeaderSize();
    size += BLOCK_TRANSACTIONS_LENGTH_BYTES;
    for (const transaction of block.transactions) {
        size += getTransactionSize(transaction);
    }
    return size;
}
exports.getBlockSize = getBlockSize;
function getBlockWithMinersFeeSize() {
    return (getBlockHeaderSize() + BLOCK_TRANSACTIONS_LENGTH_BYTES + exports.MINERS_FEE_TRANSACTION_SIZE_BYTES);
}
exports.getBlockWithMinersFeeSize = getBlockWithMinersFeeSize;
function writeCompactBlock(bw, compactBlock) {
    bw = writeBlockHeader(bw, compactBlock.header);
    bw.writeVarint(compactBlock.transactionHashes.length);
    for (const transactionHash of compactBlock.transactionHashes) {
        bw.writeHash(transactionHash);
    }
    bw.writeVarint(compactBlock.transactions.length);
    for (const transaction of compactBlock.transactions) {
        bw.writeVarint(transaction.index);
        writeTransaction(bw, transaction.transaction);
    }
    return bw;
}
exports.writeCompactBlock = writeCompactBlock;
function readCompactBlock(reader) {
    const header = readBlockHeader(reader);
    const transactionHashes = [];
    const transactionHashesLength = reader.readVarint();
    for (let i = 0; i < transactionHashesLength; i++) {
        const transactionHash = reader.readHash();
        transactionHashes.push(transactionHash);
    }
    const transactions = [];
    const transactionsLength = reader.readVarint();
    for (let i = 0; i < transactionsLength; i++) {
        const index = reader.readVarint();
        const transaction = readTransaction(reader);
        transactions.push({ index, transaction });
    }
    return {
        header,
        transactionHashes,
        transactions,
    };
}
exports.readCompactBlock = readCompactBlock;
function getCompactBlockSize(compactBlock) {
    let size = getBlockHeaderSize();
    size += bufio_1.sizeVarint(compactBlock.transactionHashes.length);
    size += 32 * compactBlock.transactionHashes.length;
    size += bufio_1.sizeVarint(compactBlock.transactions.length);
    for (const transaction of compactBlock.transactions) {
        size += bufio_1.sizeVarint(transaction.index);
        size += getTransactionSize(transaction.transaction);
    }
    return size;
}
exports.getCompactBlockSize = getCompactBlockSize;
function writeTransaction(bw, transaction) {
    bw.writeVarBytes(transaction.serialize());
}
exports.writeTransaction = writeTransaction;
function readTransaction(reader) {
    return new transaction_1.Transaction(reader.readVarBytes());
}
exports.readTransaction = readTransaction;
function getTransactionSize(transaction) {
    return bufio_1.sizeVarBytes(transaction.serialize());
}
exports.getTransactionSize = getTransactionSize;
//# sourceMappingURL=serializers.js.map