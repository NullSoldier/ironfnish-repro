import { TransactionHash } from '../primitives/transaction';
import { PeerNetwork } from './peerNetwork';
import { Peer } from './peers/peer';
/**
 * When a node receives a new transaction hash it needs to query the sender for
 * the full transaction object. This class encapsulates logic for resolving transaction
 * hashes to full transactions from the network. It operates as a state machine. Each transaction
 * hash has it's own state which changes when peers are queried, requests timeout or a
 * full transaction is received from the network
 */
export declare class TransactionFetcher {
    private readonly pending;
    private readonly peerNetwork;
    constructor(peerNetwork: PeerNetwork);
    /**
     * Called when a new transaction hash is received from the network
     * This schedules requests for the hash to be sent out and if
     * requests are already in progress, it adds the peer as a backup source */
    hashReceived(hash: TransactionHash, peer: Peer): void;
    /**
     * Called when a transaction has been received from the network
     * but has not yet been processed (validated and added to mempool etc.) */
    receivedTransaction(hash: TransactionHash): void;
    /**
     * Called when a transaction has been received and confirmed from the network
     * either in a block or in a gossiped transaction request */
    removeTransaction(hash: TransactionHash): void;
    private requestFromNextPeer;
    stop(): void;
    private requestTransaction;
    private popRandomPeer;
    private cleanupCallbacks;
}
//# sourceMappingURL=transactionFetcher.d.ts.map