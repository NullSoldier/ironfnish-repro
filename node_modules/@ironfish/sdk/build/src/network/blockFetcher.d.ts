import { Block, CompactBlock } from '../primitives/block';
import { BlockHash, BlockHeader } from '../primitives/blockheader';
import { GetBlockTransactionsResponse } from './messages/getBlockTransactions';
import { PeerNetwork, TransactionOrHash } from './peerNetwork';
import { Peer } from './peers/peer';
export declare class BlockFetcher {
    private readonly pending;
    private readonly peerNetwork;
    constructor(peerNetwork: PeerNetwork);
    /**
     * Called when a new block hash is received from the network
     * This schedules requests for the hash to be sent out and if
     * requests are already in progress, it adds the peer as a backup source */
    receivedHash(hash: BlockHash, peer: Peer): void;
    private requestCompactBlock;
    /**
     * Called when a compact block has been received from the network
     * but has not yet been processed (validated, assembled into a full
     * block, etc.) Returns true if the caller (PeerNetwork) should continue
     * processing this compact block or not */
    receivedCompactBlock(compactBlock: CompactBlock, peer: Peer): boolean;
    requestBlockTransactions(peer: Peer, header: BlockHeader, partialTransactions: TransactionOrHash[], missingTransactions: number[]): void;
    /**
     * Called when receiving a response to a request for missing transactions on a block. */
    receivedBlockTransactions(message: GetBlockTransactionsResponse): Block | null;
    requestFullBlock(hash: BlockHash): void;
    /**
     * Called when a block has been assembled from a compact block
     * but has not yet been validated and added to the chain. */
    receivedFullBlock(block: Block): void;
    /**
     * Handles the case where a block may be undergoing verification, but peers
     * that received the compact block may need transactions from it. */
    getFullBlock(hash: BlockHash): Block | null;
    /**
     * Called when a block has been added to the chain or is known to be invalid. */
    removeBlock(hash: BlockHash): void;
    stop(): void;
    private popRandomPeer;
    private cleanupCallbacks;
}
//# sourceMappingURL=blockFetcher.d.ts.map