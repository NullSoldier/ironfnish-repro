"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.KeyStore = void 0;
const event_1 = require("../event");
const utils_1 = require("../utils");
const fileStore_1 = require("./fileStore");
class KeyStore {
    constructor(files, configName, defaults, dataDir, schema) {
        this.overrides = {};
        this.keysLoaded = new Set();
        this.onConfigChange = new event_1.Event();
        this.files = files;
        this.storage = new fileStore_1.FileStore(files, configName, dataDir);
        this.schema = schema;
        this.dataDir = this.storage.dataDir;
        const loaded = Object.setPrototypeOf({}, defaults);
        const overrides = Object.setPrototypeOf({}, loaded);
        const config = Object.setPrototypeOf({}, overrides);
        this.defaults = defaults;
        this.loaded = loaded;
        this.overrides = overrides;
        this.config = config;
    }
    async load() {
        const data = await this.storage.load();
        // Validate file store if we have a schema
        if (this.schema) {
            const { error, result } = await utils_1.YupUtils.tryValidate(this.schema, data);
            if (error) {
                throw new Error(error.message);
            }
            if (data != null) {
                Object.assign(data, result);
            }
        }
        this.keysLoaded.clear();
        if (data !== null) {
            let key;
            for (key in data) {
                this.keysLoaded.add(key);
            }
        }
        this.loaded = { ...data };
        //  Patch back in inheritance so config is still TSchema
        Object.setPrototypeOf(this.loaded, this.defaults);
        Object.setPrototypeOf(this.overrides, this.loaded);
        // Write the file out if it doesnt exist
        if (data === null) {
            await this.save();
        }
    }
    async save() {
        const save = {};
        let key;
        for (key in this.loaded) {
            const shouldSaveKey = this.keysLoaded.has(key) || this.loaded[key] !== this.defaults[key];
            if (shouldSaveKey) {
                Object.assign(save, { [key]: this.config[key] });
            }
        }
        await this.storage.save(save);
    }
    clear(key) {
        const previousValue = this.config[key];
        delete this.loaded[key];
        this.keysLoaded.delete(key);
        if (Object.prototype.hasOwnProperty.call(this.overrides, key)) {
            delete this.overrides[key];
        }
        const newValue = this.get(key);
        if (previousValue !== newValue) {
            this.onConfigChange.emit(key, newValue);
        }
    }
    set(key, value) {
        const schema = this.schema?.fields[key];
        if (schema) {
            const { error, result } = utils_1.YupUtils.tryValidateSync(schema, value);
            if (error) {
                throw error;
            }
            value = result;
        }
        const previousValue = this.config[key];
        Object.assign(this.loaded, { [key]: value });
        this.keysLoaded.add(key);
        if (Object.prototype.hasOwnProperty.call(this.overrides, key)) {
            delete this.overrides[key];
        }
        if (previousValue !== value) {
            this.onConfigChange.emit(key, value);
        }
    }
    setMany(params) {
        for (const key in params) {
            const value = params[key];
            this.set(key, value);
        }
    }
    setOverride(key, value) {
        const previousValue = this.config[key];
        Object.assign(this.overrides, { [key]: value });
        if (previousValue !== value) {
            this.onConfigChange.emit(key, value);
        }
    }
    get(key) {
        return this.config[key];
    }
    getArray(key) {
        const value = this.get(key);
        if (Array.isArray(value)) {
            return value;
        }
        if (typeof value !== 'string') {
            throw new Error(`${String(key)} must be array or string`);
        }
        return value.split(',').filter(Boolean);
    }
    /**
     * Returns true if the key is set, or false if its value is from the defaults
     */
    isSet(key) {
        return this.keysLoaded.has(key) || Object.prototype.hasOwnProperty.call(this.overrides, key);
    }
}
exports.KeyStore = KeyStore;
//# sourceMappingURL=keyStore.js.map