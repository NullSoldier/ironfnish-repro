import * as yup from 'yup';
import { FileSystem } from '../fileSystems';
import { KeyStore } from './keyStore';
export declare const DEFAULT_CONFIG_NAME = "config.json";
export declare const DEFAULT_DATA_DIR = "~/.ironfish";
export declare const DEFAULT_WEBSOCKET_PORT = 9033;
export declare const DEFAULT_DISCORD_INVITE = "https://discord.ironfish.network";
export declare const DEFAULT_USE_RPC_IPC = true;
export declare const DEFAULT_USE_RPC_TCP = false;
export declare const DEFAULT_USE_RPC_TLS = true;
export declare const DEFAULT_USE_RPC_HTTP = false;
export declare const DEFAULT_POOL_HOST = "::";
export declare const DEFAULT_POOL_PORT = 9034;
export declare const DEFAULT_NETWORK_ID = 1;
export declare const DEFAULT_FEE_ESTIMATOR_MAX_BLOCK_HISTORY = 10;
export declare const DEFAULT_FEE_ESTIMATOR_PERCENTILE_SLOW = 10;
export declare const DEFAULT_FEE_ESTIMATOR_PERCENTILE_AVERAGE = 20;
export declare const DEFAULT_FEE_ESTIMATOR_PERCENTILE_FAST = 30;
export declare type ConfigOptions = {
    bootstrapNodes: string[];
    /**
     * STUN servers to use for inititating WebRTC connections.
     */
    p2pStunServers: string[];
    databaseMigrate: boolean;
    enableWallet: boolean;
    editor: string;
    enableListenP2P: boolean;
    enableLogFile: boolean;
    enableRpc: boolean;
    enableRpcIpc: boolean;
    enableRpcTcp: boolean;
    enableRpcTls: boolean;
    enableRpcHttp: boolean;
    enableSyncing: boolean;
    enableTelemetry: boolean;
    enableMetrics: boolean;
    enableAssetVerification: boolean;
    getFundsApi: string;
    ipcPath: string;
    /**
     * Should the mining director mine, even if we are not synced?
     * Only useful if no miner has been on the network in a long time
     * otherwise you should not turn this on or you'll create useless
     * forks while you sync.
     */
    miningForce: boolean;
    /**
     * If true, track all sent and received network messages per-peer.
     */
    logPeerMessages: boolean;
    /**
     * Log levels are formatted like so:
     * `*:warn,tag:info`
     *
     * ex: `warn` or `*:warn` displays only logs that are warns or errors.
     *
     * ex: `*:warn,peernetwork:info` displays warns and errors, as well as info
     *     logs from peernetwork and its submodules.
     */
    logLevel: string;
    /**
     * String to be prefixed to all logs. Accepts the following replacements:
     * %time% : The time of the log
     * %tag% : The tags on the log
     * %level% : The log level
     *
     * ex: `[%time%] [%level%] [%tag%]`
     */
    logPrefix: string;
    /**
     * When mining new blocks, blockGraffiti will be set on the `graffiti` field of
     * newly created blocks.
     * Length is truncated to 32 bytes.
     */
    blockGraffiti: string;
    nodeName: string;
    /**
     * The number of CPU workers to use for long-running node operations, like creating
     * transactions and verifying blocks. 0 disables workers (this is likely to cause
     * performance issues), and -1 auto-detects based on the number of CPU cores.
     * Each worker uses several hundred MB of memory, so try a lower value to reduce memory
     * consumption.
     */
    nodeWorkers: number;
    /**
     * The max number of node workers. See config "nodeWorkers"
     */
    nodeWorkersMax: number;
    p2pSimulateLatency: number;
    peerPort: number;
    rpcTcpHost: string;
    rpcTcpPort: number;
    tlsKeyPath: string;
    tlsCertPath: string;
    rpcHttpHost: string;
    rpcHttpPort: number;
    /**
     * The maximum number of peers we can be connected to at a time. Past this number,
     * new connections will be rejected.
     */
    maxPeers: number;
    minPeers: number;
    /**
     * The ideal number of peers we'd like to be connected to. The node will attempt to
     * establish new connections when below this number.
     */
    targetPeers: number;
    telemetryApi: string;
    assetVerificationApi: string;
    /**
     * When the option is true, then each invocation of start command will invoke generation of new identity.
     * In situation, when the option is false, the app check if identity already exists in internal.json file,
     * if exists then will use it, otherwise will generate new.
     */
    generateNewIdentity: boolean;
    /**
     * The default delta of block sequence for which to expire transactions from the
     * mempool.
     */
    transactionExpirationDelta: number;
    /**
     * The default number of blocks to request per message when syncing.
     */
    blocksPerMessage: number;
    /**
     * The number of hashes processed by miner per worker request.
     */
    minerBatchSize: number;
    /**
     * The minimum number of block confirmations needed when computing account
     * balance.
     */
    confirmations: number;
    /**
     * The name that the pool will use in block graffiti and transaction memo.
     */
    poolName: string;
    /**
     * The name of the account that the pool will use to payout from.
     */
    poolAccountName?: string;
    /**
     * Should pool clients be banned for perceived bad behavior
     */
    poolBanning: boolean;
    /**
     * The host that the pool is listening for miner connections on.
     */
    poolHost: string;
    /**
     * The port that the pool is listening for miner connections on.
     */
    poolPort: number;
    /**
     * The pool difficulty, which determines how often miners submit shares.
     */
    poolDifficulty: string;
    /**
     * The length of time in seconds that the pool will wait between status
     * messages. Setting to 0 disables status messages.
     */
    poolStatusNotificationInterval: number;
    /**
     * The length of time in seconds that will be used to calculate hashrate for the pool.
     */
    poolRecentShareCutoff: number;
    /**
     * The length of time in seconds for each payout period. This is used to
     * calculate the number of shares and how much they earn per period.
     */
    poolPayoutPeriodDuration: number;
    /**
     * The discord webhook URL to post pool critical pool information to
     */
    poolDiscordWebhook: '';
    /**
     * The maximum number of concurrent open connections per remote address.
     * Setting this to 0 disabled the limit
     */
    poolMaxConnectionsPerIp: number;
    /**
     * The lark webhook URL to post pool critical pool information to
     */
    poolLarkWebhook: '';
    /**
     * Whether we want the logs to the console to be in JSON format or not. This can be used to log to
     * more easily process logs on a remote server using a log service like Datadog
     */
    jsonLogs: boolean;
    /**
     * URL for viewing block information in a block explorer
     */
    explorerBlocksUrl: string;
    /**
     * URL for viewing transaction information in a block explorer
     */
    explorerTransactionsUrl: string;
    /**
     * How many blocks back from the head of the chain to use to calculate the fee
     * estimate
     */
    feeEstimatorMaxBlockHistory: number;
    /**
     * The percentile to use as an estimate for a slow transaction
     */
    feeEstimatorPercentileSlow: number;
    /**
     * The percentile to use as an estimate for an average transaction
     */
    feeEstimatorPercentileAverage: number;
    /**
     * The percentile to use as an estimate for a fast transaction
     */
    feeEstimatorPercentileFast: number;
    /**
     * Network ID of an official Iron Fish network
     */
    networkId: number;
    /**
     * Path to a JSON file containing the network definition of a custom network
     */
    customNetwork: string;
    /**
     * The oldest the tip should be before we consider the chain synced
     */
    maxSyncedAgeBlocks: number;
    /**
     * Limit the number of bytes of transactions stored in the mempool. Does NOT account for the
     * entire size of the mempool (like indices and caches)
     */
    memPoolMaxSizeBytes: number;
    /**
     * Limit how many entries the mempool's recently evicted caches stores. This cache is used to keep
     * track of transaction hashes recently evicted from the mempool after it exceeds mempoolMaxSizeBytes
     */
    memPoolRecentlyEvictedCacheSize: number;
    networkDefinitionPath: string;
    /**
     * Always allow incoming connections from these IPs even if the node is at maxPeers
     */
    incomingWebSocketWhitelist: string[];
    /**
     * When the wallet listens for incoming unconfirmed transactions, limit the
     * number of transactions the wallet can queue up before it starts dropping them.
     */
    walletGossipTransactionsMaxQueueSize: number;
    /**
     * Enable standalone wallet process to connect to a node via IPC
     */
    walletNodeIpcEnabled: boolean;
    walletNodeIpcPath: string;
    /**
     * Enable stanalone wallet process to connect to a node via TCP
     */
    walletNodeTcpEnabled: boolean;
    walletNodeTcpHost: string;
    walletNodeTcpPort: number;
    walletNodeTlsEnabled: boolean;
    walletNodeRpcAuthToken: string;
    walletSyncingMaxQueueSize: number;
};
export declare const ConfigOptionsSchema: yup.ObjectSchema<Partial<ConfigOptions>>;
export declare class Config extends KeyStore<ConfigOptions> {
    readonly chainDatabasePath: string;
    readonly walletDatabasePath: string;
    readonly tempDir: string;
    constructor(files: FileSystem, dataDir: string, configName?: string);
    static GetDefaults(files: FileSystem, dataDir: string): ConfigOptions;
}
//# sourceMappingURL=config.d.ts.map