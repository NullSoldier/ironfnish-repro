"use strict";
/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/. */
Object.defineProperty(exports, "__esModule", { value: true });
exports.addGenesisTransaction = void 0;
const rust_nodejs_1 = require("@ironfish/rust-nodejs");
const primitives_1 = require("../primitives");
const blockheader_1 = require("../primitives/blockheader");
const transaction_1 = require("../primitives/transaction");
const utils_1 = require("../utils");
async function addGenesisTransaction(node, account, allocations, logger) {
    logger = logger.withTag('addGenesisTransaction');
    if (!account.spendingKey) {
        throw new Error('Must be a full account, not a view account');
    }
    // Sum the allocations to get the total number of coins
    const allocationSum = allocations.reduce((sum, cur) => sum + cur.amountInOre, 0n);
    const allocationSumInIron = utils_1.CurrencyUtils.encodeIron(allocationSum);
    logger.info('Generating a transaction for distributing allocations...');
    // Get a previous note owned by the given account from the existing genesis block
    let note = null;
    let witness = null;
    const genesisTransactions = await node.chain.getBlockTransactions(node.chain.genesis);
    for (const { transaction, initialNoteIndex } of genesisTransactions) {
        let noteIndex = -1;
        for (const encryptedNote of transaction.notes) {
            noteIndex += 1;
            // If this account can't decrypt this note, we can't use it
            const decryptedNote = encryptedNote.decryptNoteForOwner(account.incomingViewKey);
            if (decryptedNote == null) {
                continue;
            }
            // If the nullifier has already been revealed, we can't use it
            const nullifier = decryptedNote.nullifier(account.viewKey, BigInt(initialNoteIndex + noteIndex));
            if (await node.chain.nullifiers.get(nullifier)) {
                continue;
            }
            // We want the note with the exact value
            if (decryptedNote.value() !== allocationSum) {
                continue;
            }
            witness = await node.chain.notes.witness(initialNoteIndex + noteIndex);
            note = decryptedNote.takeReference();
            decryptedNote.returnReference();
            break;
        }
        if (note != null) {
            break;
        }
    }
    if (note == null) {
        throw new Error('The given account does not have a suitable note to spend for the new allocations');
    }
    if (witness == null) {
        throw new Error('The witness is missing, this should not happen');
    }
    if (note.value() !== allocationSum) {
        throw new Error('The value of the note to spend does not match the sum of the allocations');
    }
    // Create the new transaction to be appended to the new genesis block
    const transaction = new rust_nodejs_1.Transaction(account.spendingKey);
    logger.info(`  Generating a spend for ${allocationSumInIron} coins...`);
    transaction.spend(note, witness);
    for (const alloc of allocations) {
        logger.info(`  Generating an output for ${utils_1.CurrencyUtils.encodeIron(alloc.amountInOre)} coins for ${alloc.publicAddress}...`);
        const note = new rust_nodejs_1.Note(alloc.publicAddress, BigInt(alloc.amountInOre), alloc.memo, rust_nodejs_1.Asset.nativeId(), account.publicAddress);
        transaction.output(note);
    }
    logger.info('  Posting the transaction...');
    const postedTransaction = new transaction_1.Transaction(transaction.post(undefined, BigInt(0)));
    logger.info('Creating the modified genesis block...');
    // Get the existing genesis block
    const genesisBlock = await node.chain.getBlock(node.chain.genesis);
    if (genesisBlock == null) {
        throw new Error('An existing genesis block was not found');
    }
    // Append the new transaction
    genesisBlock.transactions.push(postedTransaction);
    // Add the new notes to the merkle tree
    await node.chain.notes.addBatch(postedTransaction.notes);
    // Generate a new block header for the new genesis block
    const noteCommitment = await node.chain.notes.rootHash();
    const noteSize = await node.chain.notes.size();
    const newGenesisHeader = new primitives_1.BlockHeader(1, genesisBlock.header.previousBlockHash, noteCommitment, blockheader_1.transactionCommitment(genesisBlock.transactions), genesisBlock.header.target, genesisBlock.header.randomness, genesisBlock.header.timestamp, genesisBlock.header.graffiti, noteSize);
    genesisBlock.header = newGenesisHeader;
    logger.info('Block complete.');
    return { block: genesisBlock };
}
exports.addGenesisTransaction = addGenesisTransaction;
//# sourceMappingURL=addGenesisTransaction.js.map