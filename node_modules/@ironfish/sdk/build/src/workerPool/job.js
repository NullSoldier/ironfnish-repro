"use strict";
/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/. */
Object.defineProperty(exports, "__esModule", { value: true });
exports.Job = void 0;
const event_1 = require("../event");
const utils_1 = require("../utils");
const handlers_1 = require("./tasks/handlers");
const jobAbort_1 = require("./tasks/jobAbort");
class Job {
    constructor(request) {
        this.onEnded = new event_1.Event();
        this.onChange = new event_1.Event();
        // This determines if JobAbortedError is fed into the response if the job is
        // aborted. The code base hasn't been upgraded to handle these so it should be
        // enabled for each job that now properly handles it until all jobs handle it.
        // Then this should be removed.
        this.enableJobAbortedError = false;
        this.id = request.jobId;
        this.request = request;
        this.worker = null;
        this.status = 'queued';
        const [promise, resolve, reject] = utils_1.PromiseUtils.split();
        this.promise = promise;
        this.resolve = resolve;
        this.reject = reject;
        this.promise.catch(() => {
            // Eat the exception. You can still catch
            // the exception using job.response()
        });
    }
    abort() {
        if (this.status !== 'queued' && this.status !== 'executing') {
            return;
        }
        const prevStatus = this.status;
        this.status = 'aborted';
        this.onChange.emit(this, prevStatus);
        this.onEnded.emit(this);
        if (this.worker) {
            this.worker.send(new jobAbort_1.JobAbortedMessage(this.id));
            this.worker.jobs.delete(this.id);
        }
        if (this.reject && this.enableJobAbortedError) {
            this.reject(new jobAbort_1.JobAbortedError());
        }
    }
    execute(worker = null) {
        this.worker = worker;
        const prevStatus = this.status;
        this.status = 'executing';
        this.onChange.emit(this, prevStatus);
        if (worker) {
            try {
                worker.send(this.request);
            }
            catch (e) {
                const prevStatus = this.status;
                this.status = 'error';
                this.onChange.emit(this, prevStatus);
                this.onEnded.emit(this);
                throw e;
            }
            worker.jobs.set(this.id, this);
            return this;
        }
        void handlers_1.handleRequest(this.request, this)
            .then((r) => {
            if (this.status !== 'aborted') {
                const prevStatus = this.status;
                this.status = 'success';
                this.onChange.emit(this, prevStatus);
                this.onEnded.emit(this);
                this.resolve(r);
            }
        })
            .catch((e) => {
            if (this.status !== 'aborted') {
                const prevStatus = this.status;
                this.status = 'error';
                this.onChange.emit(this, prevStatus);
                this.onEnded.emit(this);
                this.reject(e);
            }
        });
        return this;
    }
    result() {
        return this.promise;
    }
}
exports.Job = Job;
//# sourceMappingURL=job.js.map