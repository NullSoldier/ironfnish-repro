"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.DecryptNotesTask = exports.DecryptNotesResponse = exports.DecryptNotesRequest = void 0;
/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/. */
const rust_nodejs_1 = require("@ironfish/rust-nodejs");
const bufio_1 = __importDefault(require("bufio"));
const noteEncrypted_1 = require("../../primitives/noteEncrypted");
const wallet_1 = require("../../wallet");
const accountValue_1 = require("../../wallet/walletdb/accountValue");
const workerMessage_1 = require("./workerMessage");
const workerTask_1 = require("./workerTask");
class DecryptNotesRequest extends workerMessage_1.WorkerMessage {
    constructor(payloads, jobId) {
        super(workerMessage_1.WorkerMessageType.DecryptNotes, jobId);
        this.payloads = payloads;
    }
    serializePayload(bw) {
        for (const payload of this.payloads) {
            let flags = 0;
            flags |= Number(!!payload.currentNoteIndex) << 0;
            flags |= Number(payload.decryptForSpender) << 1;
            bw.writeU8(flags);
            bw.writeBytes(payload.serializedNote);
            bw.writeBytes(Buffer.from(payload.incomingViewKey, 'hex'));
            bw.writeBytes(Buffer.from(payload.outgoingViewKey, 'hex'));
            bw.writeBytes(Buffer.from(payload.viewKey, 'hex'));
            if (payload.currentNoteIndex) {
                bw.writeU32(payload.currentNoteIndex);
            }
        }
    }
    static deserializePayload(jobId, buffer) {
        const reader = bufio_1.default.read(buffer, true);
        const payloads = [];
        while (reader.left() > 0) {
            const flags = reader.readU8();
            const hasCurrentNoteIndex = flags & (1 << 0);
            const decryptForSpender = Boolean(flags & (1 << 1));
            const serializedNote = reader.readBytes(rust_nodejs_1.ENCRYPTED_NOTE_LENGTH);
            const incomingViewKey = reader.readBytes(wallet_1.ACCOUNT_KEY_LENGTH).toString('hex');
            const outgoingViewKey = reader.readBytes(wallet_1.ACCOUNT_KEY_LENGTH).toString('hex');
            const viewKey = reader.readBytes(accountValue_1.VIEW_KEY_LENGTH).toString('hex');
            const currentNoteIndex = hasCurrentNoteIndex ? reader.readU32() : null;
            payloads.push({
                serializedNote,
                incomingViewKey,
                outgoingViewKey,
                currentNoteIndex,
                decryptForSpender,
                viewKey,
            });
        }
        return new DecryptNotesRequest(payloads, jobId);
    }
    getSize() {
        let size = 0;
        for (const payload of this.payloads) {
            size += 1;
            size += rust_nodejs_1.ENCRYPTED_NOTE_LENGTH;
            size += wallet_1.ACCOUNT_KEY_LENGTH;
            size += wallet_1.ACCOUNT_KEY_LENGTH;
            size += accountValue_1.VIEW_KEY_LENGTH;
            if (payload.currentNoteIndex) {
                size += 4;
            }
        }
        return size;
    }
}
exports.DecryptNotesRequest = DecryptNotesRequest;
class DecryptNotesResponse extends workerMessage_1.WorkerMessage {
    constructor(notes, jobId) {
        super(workerMessage_1.WorkerMessageType.DecryptNotes, jobId);
        this.notes = notes;
    }
    serializePayload(bw) {
        for (const note of this.notes) {
            const hasDecryptedNote = Number(!!note);
            bw.writeU8(hasDecryptedNote);
            if (note) {
                let flags = 0;
                flags |= Number(!!note.index) << 0;
                flags |= Number(!!note.nullifier) << 1;
                flags |= Number(note.forSpender) << 2;
                bw.writeU8(flags);
                bw.writeHash(note.hash);
                bw.writeBytes(note.serializedNote);
                if (note.index) {
                    bw.writeU32(note.index);
                }
                if (note.nullifier) {
                    bw.writeHash(note.nullifier);
                }
            }
        }
    }
    static deserializePayload(jobId, buffer) {
        const reader = bufio_1.default.read(buffer);
        const notes = [];
        while (reader.left() > 0) {
            const hasDecryptedNote = reader.readU8();
            if (!hasDecryptedNote) {
                notes.push(null);
                continue;
            }
            const flags = reader.readU8();
            const hasIndex = flags & (1 << 0);
            const hasNullifier = flags & (1 << 1);
            const forSpender = Boolean(flags & (1 << 2));
            const hash = reader.readHash();
            const serializedNote = reader.readBytes(rust_nodejs_1.DECRYPTED_NOTE_LENGTH);
            let index = null;
            if (hasIndex) {
                index = reader.readU32();
            }
            let nullifier = null;
            if (hasNullifier) {
                nullifier = reader.readHash();
            }
            notes.push({
                forSpender,
                index,
                hash,
                nullifier,
                serializedNote,
            });
        }
        return new DecryptNotesResponse(notes, jobId);
    }
    getSize() {
        let size = 0;
        for (const note of this.notes) {
            size += 1;
            if (note) {
                size += 1 + 32 + rust_nodejs_1.DECRYPTED_NOTE_LENGTH;
                if (note.index) {
                    size += 4;
                }
                if (note.nullifier) {
                    size += 32;
                }
            }
        }
        return size;
    }
}
exports.DecryptNotesResponse = DecryptNotesResponse;
class DecryptNotesTask extends workerTask_1.WorkerTask {
    static getInstance() {
        if (!DecryptNotesTask.instance) {
            DecryptNotesTask.instance = new DecryptNotesTask();
        }
        return DecryptNotesTask.instance;
    }
    execute({ payloads, jobId }) {
        const decryptedNotes = [];
        for (const { serializedNote, incomingViewKey, outgoingViewKey, viewKey, currentNoteIndex, decryptForSpender, } of payloads) {
            const note = new noteEncrypted_1.NoteEncrypted(serializedNote);
            // Try decrypting the note as the owner
            const receivedNote = note.decryptNoteForOwner(incomingViewKey);
            if (receivedNote && receivedNote.value() !== 0n) {
                decryptedNotes.push({
                    index: currentNoteIndex,
                    forSpender: false,
                    hash: note.hash(),
                    nullifier: currentNoteIndex !== null
                        ? receivedNote.nullifier(viewKey, BigInt(currentNoteIndex))
                        : null,
                    serializedNote: receivedNote.serialize(),
                });
                continue;
            }
            if (decryptForSpender) {
                // Try decrypting the note as the spender
                const spentNote = note.decryptNoteForSpender(outgoingViewKey);
                if (spentNote && spentNote.value() !== 0n) {
                    decryptedNotes.push({
                        index: currentNoteIndex,
                        forSpender: true,
                        hash: note.hash(),
                        nullifier: null,
                        serializedNote: spentNote.serialize(),
                    });
                    continue;
                }
            }
            decryptedNotes.push(null);
        }
        return new DecryptNotesResponse(decryptedNotes, jobId);
    }
}
exports.DecryptNotesTask = DecryptNotesTask;
//# sourceMappingURL=decryptNotes.js.map