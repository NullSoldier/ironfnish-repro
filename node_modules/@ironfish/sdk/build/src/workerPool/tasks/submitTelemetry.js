"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.SubmitTelemetryTask = exports.SubmitTelemetryResponse = exports.SubmitTelemetryRequest = void 0;
/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/. */
const bufio_1 = __importDefault(require("bufio"));
const buffer_1 = require("../../utils/buffer");
const webApi_1 = require("../../webApi");
const workerMessage_1 = require("./workerMessage");
const workerTask_1 = require("./workerTask");
class SubmitTelemetryRequest extends workerMessage_1.WorkerMessage {
    constructor(points, graffiti, apiHost, jobId) {
        super(workerMessage_1.WorkerMessageType.SubmitTelemetry, jobId);
        this.points = points;
        this.graffiti = graffiti;
        this.apiHost = apiHost;
    }
    serializePayload(bw) {
        bw.writeVarBytes(this.graffiti);
        bw.writeVarString(this.apiHost, 'utf8');
        bw.writeU64(this.points.length);
        for (const point of this.points) {
            bw.writeVarString(point.measurement, 'utf8');
            bw.writeVarString(point.timestamp.toISOString(), 'utf8');
            const { fields } = point;
            bw.writeU64(fields.length);
            for (const field of fields) {
                bw.writeVarString(field.name, 'utf8');
                try {
                    bw.writeVarString(field.type, 'utf8');
                    switch (field.type) {
                        case 'string':
                            bw.writeVarString(field.value, 'utf8');
                            break;
                        case 'boolean':
                            bw.writeU8(Number(field.value));
                            break;
                        case 'float':
                            bw.writeDouble(field.value);
                            break;
                        case 'integer':
                            bw.writeU64(Math.round(field.value));
                            break;
                    }
                }
                catch (e) {
                    if (e instanceof TypeError) {
                        throw new TypeError(`Failed to serialize field ${field.name}: expected value of ${field.type} type but received ${field.value.toString()}`);
                    }
                    throw e;
                }
            }
            const tags = point.tags;
            if (tags) {
                bw.writeU64(tags.length);
                for (const tag of tags) {
                    bw.writeVarString(tag.name, 'utf8');
                    bw.writeVarString(tag.value, 'utf8');
                }
            }
        }
    }
    static deserializePayload(jobId, buffer) {
        const reader = bufio_1.default.read(buffer, true);
        const graffiti = reader.readVarBytes();
        const apiHost = reader.readVarString('utf8');
        const pointsLength = reader.readU64();
        const points = [];
        for (let i = 0; i < pointsLength; i++) {
            const measurement = reader.readVarString('utf8');
            const timestamp = new Date(reader.readVarString('utf8'));
            const fieldsLength = reader.readU64();
            const fields = [];
            for (let j = 0; j < fieldsLength; j++) {
                const name = reader.readVarString('utf8');
                const type = reader.readVarString('utf8');
                switch (type) {
                    case 'string': {
                        const value = reader.readVarString('utf8');
                        fields.push({ name, type, value });
                        break;
                    }
                    case 'boolean': {
                        const value = Boolean(reader.readU8());
                        fields.push({ name, type, value });
                        break;
                    }
                    case 'float': {
                        const value = reader.readDouble();
                        fields.push({ name, type, value });
                        break;
                    }
                    case 'integer': {
                        const value = reader.readU64();
                        fields.push({ name, type, value });
                        break;
                    }
                    default:
                        throw new Error(`Invalid type: '${type}'`);
                }
            }
            let tags;
            if (reader.left()) {
                const tagsLength = reader.readU64();
                tags = [];
                for (let k = 0; k < tagsLength; k++) {
                    const name = reader.readVarString('utf8');
                    const value = reader.readVarString('utf8');
                    tags.push({ name, value });
                }
            }
            points.push({ measurement, tags, timestamp, fields });
        }
        return new SubmitTelemetryRequest(points, graffiti, apiHost, jobId);
    }
    getSize() {
        let size = 8 + bufio_1.default.sizeVarBytes(this.graffiti);
        size += bufio_1.default.sizeVarString(this.apiHost, 'utf8');
        for (const point of this.points) {
            size += bufio_1.default.sizeVarString(point.measurement, 'utf8');
            size += bufio_1.default.sizeVarString(point.timestamp.toISOString(), 'utf8');
            size += 8;
            for (const field of point.fields) {
                size += bufio_1.default.sizeVarString(field.name, 'utf8');
                size += bufio_1.default.sizeVarString(field.type, 'utf8');
                switch (field.type) {
                    case 'string':
                        size += bufio_1.default.sizeVarString(field.value, 'utf8');
                        break;
                    case 'boolean':
                        size += 1;
                        break;
                    case 'float':
                    case 'integer':
                        size += 8;
                        break;
                }
            }
            const tags = point.tags;
            if (tags) {
                size += 8;
                for (const tag of tags) {
                    size += bufio_1.default.sizeVarString(tag.name, 'utf8');
                    size += bufio_1.default.sizeVarString(tag.value, 'utf8');
                }
            }
        }
        return size;
    }
}
exports.SubmitTelemetryRequest = SubmitTelemetryRequest;
class SubmitTelemetryResponse extends workerMessage_1.WorkerMessage {
    constructor(jobId) {
        super(workerMessage_1.WorkerMessageType.SubmitTelemetry, jobId);
    }
    serializePayload() {
        return;
    }
    static deserializePayload(jobId) {
        return new SubmitTelemetryResponse(jobId);
    }
    getSize() {
        return 0;
    }
}
exports.SubmitTelemetryResponse = SubmitTelemetryResponse;
class SubmitTelemetryTask extends workerTask_1.WorkerTask {
    static getInstance() {
        if (!SubmitTelemetryTask.instance) {
            SubmitTelemetryTask.instance = new SubmitTelemetryTask();
        }
        return SubmitTelemetryTask.instance;
    }
    async execute({ jobId, points, graffiti, apiHost, }) {
        const api = new webApi_1.WebApi({ host: apiHost });
        await api.submitTelemetry({ points, graffiti: buffer_1.BufferUtils.toHuman(graffiti) });
        return new SubmitTelemetryResponse(jobId);
    }
}
exports.SubmitTelemetryTask = SubmitTelemetryTask;
//# sourceMappingURL=submitTelemetry.js.map