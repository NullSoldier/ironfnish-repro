"use strict";
/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/. */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.SleepTask = exports.SleepResponse = exports.SleepRequest = void 0;
const bufio_1 = __importDefault(require("bufio"));
const utils_1 = require("../../utils");
const workerMessage_1 = require("./workerMessage");
const workerTask_1 = require("./workerTask");
class SleepRequest extends workerMessage_1.WorkerMessage {
    constructor(sleep, error, jobId) {
        super(workerMessage_1.WorkerMessageType.Sleep, jobId);
        this.sleep = sleep;
        this.error = error;
    }
    serializePayload(bw) {
        bw.writeDouble(this.sleep);
        bw.writeVarString(this.error, 'utf8');
    }
    static deserializePayload(jobId, buffer) {
        const reader = bufio_1.default.read(buffer, true);
        const sleep = reader.readDouble();
        const error = reader.readVarString('utf8');
        return new SleepRequest(sleep, error, jobId);
    }
    getSize() {
        return 8 + bufio_1.default.sizeVarString(this.error, 'utf8');
    }
}
exports.SleepRequest = SleepRequest;
class SleepResponse extends workerMessage_1.WorkerMessage {
    constructor(aborted, jobId) {
        super(workerMessage_1.WorkerMessageType.Sleep, jobId);
        this.aborted = aborted;
    }
    serializePayload(bw) {
        bw.writeU8(Number(this.aborted));
    }
    static deserializePayload(jobId, buffer) {
        const reader = bufio_1.default.read(buffer, true);
        const aborted = Boolean(reader.readU8());
        return new SleepResponse(aborted, jobId);
    }
    getSize() {
        return 1;
    }
}
exports.SleepResponse = SleepResponse;
class SleepTask extends workerTask_1.WorkerTask {
    static getInstance() {
        if (!SleepTask.instance) {
            SleepTask.instance = new SleepTask();
        }
        return SleepTask.instance;
    }
    async execute({ jobId, sleep, error }, job) {
        await utils_1.PromiseUtils.sleep(sleep);
        if (error) {
            throw new Error(error);
        }
        if (job.status === 'aborted') {
            return new SleepResponse(true, jobId);
        }
        return new SleepResponse(false, jobId);
    }
}
exports.SleepTask = SleepTask;
//# sourceMappingURL=sleep.js.map