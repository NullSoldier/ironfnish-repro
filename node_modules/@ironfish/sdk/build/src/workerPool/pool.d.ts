/// <reference types="node" />
import { VerificationResult } from '../consensus';
import { Logger } from '../logger';
import { Meter, MetricsMonitor } from '../metrics';
import { RawTransaction } from '../primitives/rawTransaction';
import { Transaction } from '../primitives/transaction';
import { Metric } from '../telemetry/interfaces/metric';
import { WorkerMessageStats } from './interfaces/workerMessageStats';
import { Job } from './job';
import { RoundRobinQueue } from './roundRobinQueue';
import { DecryptedNote, DecryptNoteOptions } from './tasks/decryptNotes';
import { WorkerMessageType } from './tasks/workerMessage';
import { Worker } from './worker';
/**
 * Manages the creation of worker threads and distribution of jobs to them.
 */
export declare class WorkerPool {
    readonly maxJobs: number;
    readonly maxQueue: number;
    readonly numWorkers: number;
    readonly logger: Logger;
    queue: RoundRobinQueue;
    workers: Array<Worker>;
    started: boolean;
    completed: number;
    change: Meter | null;
    speed: Meter | null;
    readonly stats: Map<WorkerMessageType, WorkerMessageStats>;
    get saturated(): boolean;
    get executing(): number;
    get queued(): number;
    get capacity(): number;
    constructor(options?: {
        metrics?: MetricsMonitor;
        numWorkers?: number;
        maxQueue?: number;
        maxJobs?: number;
        logger?: Logger;
    });
    start(): void;
    stop(): Promise<void>;
    createMinersFee(spendKey: string, amount: bigint, memo: string): Promise<Transaction>;
    postTransaction(transaction: RawTransaction, spendingKey: string): Promise<Transaction>;
    verifyTransactions(transactions: Array<Transaction>): Promise<VerificationResult>;
    decryptNotes(payloads: DecryptNoteOptions[]): Promise<Array<DecryptedNote | null>>;
    /**
     * A test worker task that sleeps for specified milliseconds
     */
    sleep(sleep?: number, error?: string): Job;
    submitTelemetry(points: Metric[], graffiti: Buffer, apiHost: string): Promise<void>;
    private execute;
    private executeQueue;
    private jobEnded;
    private jobChange;
}
/**
 * Calculates the number of workers to use based on machine's number of cpus
 */
export declare function calculateWorkers(nodeWorkers: number, nodeWorkersMax: number): number;
//# sourceMappingURL=pool.d.ts.map