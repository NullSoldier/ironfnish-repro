"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getWorkerPath = exports.Worker = void 0;
/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/. */
const rust_nodejs_1 = require("@ironfish/rust-nodejs");
const path_1 = __importDefault(require("path"));
const worker_threads_1 = require("worker_threads");
const assert_1 = require("../assert");
const logger_1 = require("../logger");
const job_1 = require("./job");
const createMinersFee_1 = require("./tasks/createMinersFee");
const decryptNotes_1 = require("./tasks/decryptNotes");
const jobAbort_1 = require("./tasks/jobAbort");
const jobError_1 = require("./tasks/jobError");
const postTransaction_1 = require("./tasks/postTransaction");
const sleep_1 = require("./tasks/sleep");
const submitTelemetry_1 = require("./tasks/submitTelemetry");
const verifyTransactions_1 = require("./tasks/verifyTransactions");
const workerMessage_1 = require("./tasks/workerMessage");
class Worker {
    constructor(options) {
        this.thread = null;
        this.parent = null;
        this.onMessageFromParent = (request) => {
            const message = Buffer.from(request);
            let header;
            try {
                header = workerMessage_1.WorkerMessage.deserializeHeader(message);
            }
            catch {
                this.logger.error(`Could not parse header from request: '${message.toString('hex')}'`);
                return;
            }
            const { body, jobId, type } = header;
            let requestBody;
            try {
                requestBody = this.parseRequest(jobId, type, body);
            }
            catch {
                const args = `(jobId: ${jobId}, type: ${workerMessage_1.WorkerMessageType[type]}, body: '${body.toString('hex')}')`;
                this.logger.error(`Could not parse payload from request: ${args}`);
                return;
            }
            if (type === workerMessage_1.WorkerMessageType.JobAborted) {
                const job = this.jobs.get(jobId);
                if (job) {
                    this.jobs.delete(job.id);
                    job.abort();
                }
                return;
            }
            const job = new job_1.Job(requestBody);
            this.jobs.set(job.id, job);
            job
                .execute()
                .result()
                .then((response) => {
                this.send(response);
            })
                .catch((e) => {
                this.send(new jobError_1.JobErrorMessage(job.id, e));
            })
                .finally(() => {
                this.jobs.delete(job.id);
            });
        };
        this.onMessageFromWorker = (response) => {
            const message = Buffer.from(response);
            let header;
            try {
                header = workerMessage_1.WorkerMessage.deserializeHeader(message);
            }
            catch {
                this.logger.error(`Could not parse header from response: '${message.toString('hex')}'`);
                return;
            }
            const { body, jobId, type } = header;
            const job = this.jobs.get(jobId);
            this.jobs.delete(jobId);
            if (!job) {
                return;
            }
            const prevStatus = job.status;
            job.status = 'success';
            job.onChange.emit(job, prevStatus);
            job.onEnded.emit(job);
            let result;
            try {
                result = this.parseResponse(jobId, type, body);
            }
            catch {
                const args = `(jobId: ${jobId}, type: ${workerMessage_1.WorkerMessageType[type]}, body: '${body.toString('hex')}')`;
                this.logger.error(`Could not parse payload from response: ${args}`);
                return;
            }
            if (result instanceof jobError_1.JobError) {
                job.status = 'error';
                job.reject(result);
                return;
            }
            else if (result instanceof jobAbort_1.JobAbortedError) {
                job.status = 'aborted';
                job.reject(result);
                return;
            }
            job.resolve(result);
            return;
        };
        this.path = options.path ?? '';
        this.maxJobs = options.maxJobs ?? 1;
        this.parent = options.parent ?? null;
        this.jobs = new Map();
        this.started = true;
        this.logger = options.logger || logger_1.createRootLogger();
        if (options.parent) {
            this.spawned();
        }
        else {
            this.spawn();
        }
    }
    get executing() {
        return this.jobs.size > 0;
    }
    get canTakeJobs() {
        return this.jobs.size < this.maxJobs;
    }
    send(message) {
        if (this.thread) {
            this.thread.postMessage(message.serialize());
        }
        else if (this.parent) {
            this.parent.postMessage(message.serialize());
        }
        else {
            throw new Error(`Cannot send message: no thread or worker`);
        }
    }
    async stop() {
        if (!this.started) {
            return;
        }
        this.started = false;
        const jobs = Array.from(this.jobs.values());
        this.jobs.clear();
        for (const job of jobs) {
            job.abort();
        }
        if (this.thread) {
            this.thread.removeAllListeners();
            await this.thread.terminate();
            this.thread = null;
        }
        if (this.parent) {
            this.parent.removeAllListeners();
            this.parent = null;
        }
    }
    /**
     * Called from the main process to spawn a worker thread
     */
    spawn() {
        assert_1.Assert.isNull(this.parent);
        this.thread = new worker_threads_1.Worker(this.path);
        this.thread.on('message', this.onMessageFromWorker);
    }
    /**
     * Called from the worker thread once the worker spawns in the thread
     */
    spawned() {
        assert_1.Assert.isNotNull(this.parent);
        this.parent.on('message', this.onMessageFromParent);
        // Trigger loading of Sapling parameters if we're in a worker thread
        rust_nodejs_1.initializeSapling();
    }
    parseRequest(jobId, type, request) {
        switch (type) {
            case workerMessage_1.WorkerMessageType.CreateMinersFee:
                return createMinersFee_1.CreateMinersFeeRequest.deserializePayload(jobId, request);
            case workerMessage_1.WorkerMessageType.PostTransaction:
                return postTransaction_1.PostTransactionRequest.deserializePayload(jobId, request);
            case workerMessage_1.WorkerMessageType.DecryptNotes:
                return decryptNotes_1.DecryptNotesRequest.deserializePayload(jobId, request);
            case workerMessage_1.WorkerMessageType.JobAborted:
                throw new Error('JobAbort should not be sent as a request');
            case workerMessage_1.WorkerMessageType.JobError:
                throw new Error('JobError should not be sent as a request');
            case workerMessage_1.WorkerMessageType.Sleep:
                return sleep_1.SleepRequest.deserializePayload(jobId, request);
            case workerMessage_1.WorkerMessageType.SubmitTelemetry:
                return submitTelemetry_1.SubmitTelemetryRequest.deserializePayload(jobId, request);
            case workerMessage_1.WorkerMessageType.VerifyTransactions:
                return verifyTransactions_1.VerifyTransactionsRequest.deserializePayload(jobId, request);
        }
    }
    parseResponse(jobId, type, response) {
        switch (type) {
            case workerMessage_1.WorkerMessageType.CreateMinersFee:
                return createMinersFee_1.CreateMinersFeeResponse.deserializePayload(jobId, response);
            case workerMessage_1.WorkerMessageType.PostTransaction:
                return postTransaction_1.PostTransactionResponse.deserializePayload(jobId, response);
            case workerMessage_1.WorkerMessageType.DecryptNotes:
                return decryptNotes_1.DecryptNotesResponse.deserializePayload(jobId, response);
            case workerMessage_1.WorkerMessageType.JobAborted:
                return jobAbort_1.JobAbortedMessage.deserializePayload();
            case workerMessage_1.WorkerMessageType.JobError:
                return jobError_1.JobErrorMessage.deserializePayload(jobId, response);
            case workerMessage_1.WorkerMessageType.Sleep:
                return sleep_1.SleepResponse.deserializePayload(jobId, response);
            case workerMessage_1.WorkerMessageType.SubmitTelemetry:
                return submitTelemetry_1.SubmitTelemetryResponse.deserializePayload(jobId);
            case workerMessage_1.WorkerMessageType.VerifyTransactions:
                return verifyTransactions_1.VerifyTransactionsResponse.deserializePayload(jobId, response);
        }
    }
}
exports.Worker = Worker;
if (worker_threads_1.parentPort !== null) {
    new Worker({ parent: worker_threads_1.parentPort });
}
function getWorkerPath() {
    let workerPath = __dirname;
    // Works around different paths when run under ts-jest
    const workerPoolPath = path_1.default.join('ironfish', 'src', 'workerPool');
    if (workerPath.includes(workerPoolPath)) {
        workerPath = workerPath.replace(workerPoolPath, path_1.default.join('ironfish', 'build', 'src', 'workerPool'));
    }
    return path_1.default.join(workerPath, 'worker.js');
}
exports.getWorkerPath = getWorkerPath;
//# sourceMappingURL=worker.js.map