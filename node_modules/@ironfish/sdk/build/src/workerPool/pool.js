"use strict";
/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/. */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.calculateWorkers = exports.WorkerPool = void 0;
const lodash_1 = __importDefault(require("lodash"));
const os_1 = __importDefault(require("os"));
const consensus_1 = require("../consensus");
const logger_1 = require("../logger");
const transaction_1 = require("../primitives/transaction");
const job_1 = require("./job");
const roundRobinQueue_1 = require("./roundRobinQueue");
const createMinersFee_1 = require("./tasks/createMinersFee");
const decryptNotes_1 = require("./tasks/decryptNotes");
const postTransaction_1 = require("./tasks/postTransaction");
const sleep_1 = require("./tasks/sleep");
const submitTelemetry_1 = require("./tasks/submitTelemetry");
const verifyTransactions_1 = require("./tasks/verifyTransactions");
const workerMessage_1 = require("./tasks/workerMessage");
const worker_1 = require("./worker");
/**
 * Manages the creation of worker threads and distribution of jobs to them.
 */
class WorkerPool {
    constructor(options) {
        this.queue = new roundRobinQueue_1.RoundRobinQueue();
        this.workers = [];
        this.started = false;
        this.completed = 0;
        this.stats = new Map([
            [workerMessage_1.WorkerMessageType.CreateMinersFee, { complete: 0, error: 0, queue: 0, execute: 0 }],
            [workerMessage_1.WorkerMessageType.DecryptNotes, { complete: 0, error: 0, queue: 0, execute: 0 }],
            [workerMessage_1.WorkerMessageType.JobAborted, { complete: 0, error: 0, queue: 0, execute: 0 }],
            [workerMessage_1.WorkerMessageType.PostTransaction, { complete: 0, error: 0, queue: 0, execute: 0 }],
            [workerMessage_1.WorkerMessageType.Sleep, { complete: 0, error: 0, queue: 0, execute: 0 }],
            [workerMessage_1.WorkerMessageType.SubmitTelemetry, { complete: 0, error: 0, queue: 0, execute: 0 }],
            [workerMessage_1.WorkerMessageType.VerifyTransactions, { complete: 0, error: 0, queue: 0, execute: 0 }],
        ]);
        this.jobEnded = () => {
            this.change?.add(-1);
            this.speed?.add(1);
            this.completed++;
            this.executeQueue();
        };
        this.jobChange = (job, prevStatus) => {
            const stats = this.stats.get(job.request.type);
            if (!stats) {
                return;
            }
            switch (prevStatus) {
                case 'queued':
                    stats.queue--;
                    break;
                case 'executing':
                    stats.execute--;
                    break;
            }
            switch (job.status) {
                case 'queued':
                    stats.queue++;
                    break;
                case 'executing':
                    stats.execute++;
                    break;
                case 'aborted':
                    stats.complete++;
                    break;
                case 'success':
                    stats.complete++;
                    break;
                case 'error':
                    stats.error++;
                    break;
            }
        };
        this.numWorkers = options?.numWorkers ?? 1;
        this.maxJobs = options?.maxJobs ?? 1;
        this.maxQueue = options?.maxQueue ?? 500;
        this.change = options?.metrics?.addMeter() ?? null;
        this.speed = options?.metrics?.addMeter() ?? null;
        this.logger = options?.logger ?? logger_1.createRootLogger();
    }
    get saturated() {
        return this.queue.length >= this.maxQueue;
    }
    get executing() {
        return lodash_1.default.sumBy(this.workers, (w) => w.jobs.size);
    }
    get queued() {
        return this.queue.length;
    }
    get capacity() {
        return this.workers.length * this.maxJobs;
    }
    start() {
        if (this.started) {
            return;
        }
        this.started = true;
        const path = worker_1.getWorkerPath();
        for (let i = 0; i < this.numWorkers; i++) {
            const worker = new worker_1.Worker({ path, maxJobs: this.maxJobs });
            this.workers.push(worker);
        }
        this.logger.debug(`Started worker pool with ${this.numWorkers} workers using ${path}`);
    }
    async stop() {
        if (!this.started) {
            return;
        }
        this.started = false;
        const workers = this.workers;
        const queue = this.queue;
        this.workers = [];
        queue.abortAll();
        await Promise.all(workers.map((w) => w.stop()));
    }
    async createMinersFee(spendKey, amount, memo) {
        const request = new createMinersFee_1.CreateMinersFeeRequest(amount, memo, spendKey);
        const response = await this.execute(request).result();
        if (!(response instanceof createMinersFee_1.CreateMinersFeeResponse)) {
            throw new Error('Invalid response');
        }
        return new transaction_1.Transaction(Buffer.from(response.serializedTransactionPosted));
    }
    async postTransaction(transaction, spendingKey) {
        const request = new postTransaction_1.PostTransactionRequest(transaction, spendingKey);
        const response = await this.execute(request).result();
        if (!(response instanceof postTransaction_1.PostTransactionResponse)) {
            throw new Error('Invalid response');
        }
        return response.transaction;
    }
    async verifyTransactions(transactions) {
        const txs = transactions.map((tx) => tx.serialize());
        const request = new verifyTransactions_1.VerifyTransactionsRequest(txs);
        const response = await this.execute(request).result();
        if (!(response instanceof verifyTransactions_1.VerifyTransactionsResponse)) {
            throw new Error('Invalid response');
        }
        return response.verified
            ? { valid: true }
            : { valid: false, reason: consensus_1.VerificationResultReason.ERROR };
    }
    async decryptNotes(payloads) {
        const request = new decryptNotes_1.DecryptNotesRequest(payloads);
        const response = await this.execute(request).result();
        if (!(response instanceof decryptNotes_1.DecryptNotesResponse)) {
            throw new Error('Invalid response');
        }
        return response.notes;
    }
    /**
     * A test worker task that sleeps for specified milliseconds
     */
    sleep(sleep = 0, error = '') {
        const request = new sleep_1.SleepRequest(sleep, error);
        const job = this.execute(request);
        job.enableJobAbortedError = true;
        return job;
    }
    async submitTelemetry(points, graffiti, apiHost) {
        const request = new submitTelemetry_1.SubmitTelemetryRequest(points, graffiti, apiHost);
        await this.execute(request).result();
    }
    execute(request) {
        const job = new job_1.Job(request);
        job.onEnded.once(this.jobEnded);
        job.onChange.on(this.jobChange);
        job.onChange.emit(job, 'init');
        // If there are no workers, execute in process
        if (this.workers.length === 0) {
            void job.execute();
            return job;
        }
        this.change?.add(1);
        // If we already have queue, put it at the end of the queue
        if (this.queue.length > 0) {
            this.queue.enqueue(request.type, job);
            return job;
        }
        const worker = this.workers.find((w) => w.canTakeJobs);
        if (!worker) {
            this.queue.enqueue(request.type, job);
            return job;
        }
        job.execute(worker);
        return job;
    }
    executeQueue() {
        if (this.queue.length === 0) {
            return;
        }
        const worker = this.workers.find((w) => w.canTakeJobs);
        if (!worker) {
            return;
        }
        const job = this.queue.nextJob();
        if (!job) {
            return;
        }
        job.execute(worker);
    }
}
exports.WorkerPool = WorkerPool;
/**
 * Calculates the number of workers to use based on machine's number of cpus
 */
function calculateWorkers(nodeWorkers, nodeWorkersMax) {
    let workers = nodeWorkers;
    if (workers === -1) {
        workers = os_1.default.cpus().length - 1;
        const maxWorkers = nodeWorkersMax;
        if (maxWorkers !== -1) {
            workers = Math.min(workers, maxWorkers);
        }
    }
    return workers;
}
exports.calculateWorkers = calculateWorkers;
//# sourceMappingURL=pool.js.map