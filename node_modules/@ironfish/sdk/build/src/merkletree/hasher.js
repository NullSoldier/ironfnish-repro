"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.StructureHasher = exports.RangeHasher = exports.ConcatHasher = exports.NoteHasher = void 0;
/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/. */
const rust_nodejs_1 = require("@ironfish/rust-nodejs");
const noteEncrypted_1 = require("../primitives/noteEncrypted");
const serde_1 = require("../serde");
/**
 * Hasher implementation for notes to satisfy the MerkleTree requirements.
 */
class NoteHasher {
    constructor() {
        this._merkleNoteSerde = new noteEncrypted_1.NoteEncryptedSerde();
        this._merkleNoteHashSerde = new noteEncrypted_1.NoteEncryptedHashSerde();
    }
    elementSerde() {
        return this._merkleNoteSerde;
    }
    hashSerde() {
        return this._merkleNoteHashSerde;
    }
    hash(note) {
        return note.hash();
    }
    combineHash(depth, left, right) {
        return Buffer.from(rust_nodejs_1.NoteEncrypted.combineHash(depth, left, right));
    }
}
exports.NoteHasher = NoteHasher;
/**
 * Demo merkle hasher implementation that combines hashes via concatenation.
 *
 * Useful for unit testing or displaying demo trees.
 */
class ConcatHasher {
    elementSerde() {
        return new serde_1.StringSerde();
    }
    hashSerde() {
        return new serde_1.StringSerde();
    }
    combineHash(depth, left, right) {
        return left + right;
    }
    hash(element) {
        return element;
    }
}
exports.ConcatHasher = ConcatHasher;
/**
 * Demo merkle hasher implementation that indicates a range of hashes.
 *
 * Useful for unit testing or displaying demo trees. Assumes the hashes are
 * in ascending order. Takes the left and right side of a hyphen in each hash
 * and combines them.
 */
class RangeHasher {
    elementSerde() {
        return new serde_1.StringSerde();
    }
    hashSerde() {
        return new serde_1.StringSerde();
    }
    combineHash(depth, left, right) {
        const leftSplit = left.split('-');
        const rightSplit = right.split('-');
        return leftSplit[0] + '-' + rightSplit[rightSplit.length - 1];
    }
    hash(element) {
        return element;
    }
}
exports.RangeHasher = RangeHasher;
/**
 * Simple hasher that encodes the tree structure in its hashes so its easy
 * to test if said structure is correct.
 *
 * Only useful for various types of unit testing.
 */
class StructureHasher {
    elementSerde() {
        return new serde_1.StringSerde();
    }
    hashSerde() {
        return new serde_1.StringSerde();
    }
    combineHash(depth, left, right) {
        return `<${left}|${right}-${depth}>`;
    }
    hash(element) {
        return element;
    }
}
exports.StructureHasher = StructureHasher;
//# sourceMappingURL=hasher.js.map