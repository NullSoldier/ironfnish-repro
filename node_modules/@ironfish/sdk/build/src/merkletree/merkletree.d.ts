import { JsonSerializable } from '../serde';
import { DatabaseKey, IDatabase, IDatabaseEncoding, IDatabaseStore, IDatabaseTransaction, SchemaValue } from '../storage';
import { MerkleHasher } from './hasher';
import { CounterSchema, LeavesIndexSchema, LeavesSchema, NodesSchema } from './schema';
import { Witness } from './witness';
export declare class MerkleTree<E, H extends DatabaseKey, SE extends JsonSerializable, SH extends JsonSerializable> {
    readonly hasher: MerkleHasher<E, H, SE, SH>;
    readonly db: IDatabase;
    readonly name: string;
    readonly depth: number;
    readonly defaultValue: H;
    readonly counter: IDatabaseStore<CounterSchema>;
    readonly leaves: IDatabaseStore<LeavesSchema<H>>;
    readonly leavesIndex: IDatabaseStore<LeavesIndexSchema<H>>;
    readonly nodes: IDatabaseStore<NodesSchema<H>>;
    private readonly pastRootCache;
    private readonly transactionPastRootCache;
    constructor({ hasher, db, leafEncoding, leafIndexKeyEncoding, nodeEncoding, defaultValue, name, depth, }: {
        hasher: MerkleHasher<E, H, SE, SH>;
        db: IDatabase;
        leafEncoding: IDatabaseEncoding<LeavesSchema<H>['value']>;
        leafIndexKeyEncoding: IDatabaseEncoding<LeavesIndexSchema<H>['key']>;
        nodeEncoding: IDatabaseEncoding<NodesSchema<H>['value']>;
        defaultValue: H;
        name?: string;
        depth?: number;
    });
    /**
     * Get the number of leaf nodes (elements) in the tree.
     */
    size(tx?: IDatabaseTransaction): Promise<number>;
    /**
     * Get the leaf element at the given index. Throws an error if the
     * index is not in bounds.
     */
    getLeaf(index: LeafIndex, tx?: IDatabaseTransaction): Promise<SchemaValue<LeavesSchema<H>>>;
    /**
     * Get the leaf element at the given index. Returns null if the
     * index is not in bounds.
     */
    getLeafOrNull(index: LeafIndex, tx?: IDatabaseTransaction): Promise<SchemaValue<LeavesSchema<H>> | null>;
    /**
     * Get the node element at the given index. Throws an error if the
     * index is not in bounds.
     */
    getNode(index: NodeIndex, tx?: IDatabaseTransaction): Promise<SchemaValue<NodesSchema<H>>>;
    /**
     * Get the node element at the given index. Returns null if the
     * index is not in bounds.
     */
    getNodeOrNull(index: NodeIndex, tx?: IDatabaseTransaction): Promise<SchemaValue<NodesSchema<H>> | null>;
    /**
     * Get the count of a given tree. Throws an error if the
     * count is not in the store.
     */
    getCount(countType: 'Leaves' | 'Nodes', tx?: IDatabaseTransaction): Promise<LeafIndex>;
    /**
     * Add the new leaf element into the tree, and update all hashes.
     */
    add(element: E, tx?: IDatabaseTransaction): Promise<void>;
    /**
     * Add the new leaf element into the tree, creating new nodes if necessary.
     *
     * Requires running hashTree to update the tree's hash values.
     */
    private addLeafWithNodes;
    addBatch(elements: Iterable<E>, tx?: IDatabaseTransaction): Promise<void>;
    private addLeaf;
    /**
     * Truncate the tree to the values it contained when it contained pastSize
     * elements.
     *
     * After calling, it will contain at most pastSize elements, but truncating
     * to a size that is higher than this.length is a no-op.
     *
     * This function doesn't do any garbage collection. The old leaves and nodes
     * are still in the database, but they will be overwritten as the new tree
     * grows.
     */
    truncate(pastSize: number, tx?: IDatabaseTransaction): Promise<void>;
    private invalidatePastRootCache;
    private setPastRootCache;
    private getPastRootCache;
    pastRootTxCommitted(tx: IDatabaseTransaction): void;
    /**
     * Calculate what the root hash was at the time the tree contained
     * `pastSize` elements. Throws an error if the tree is empty,
     * the request size is greater than the size of the tree, or the requested
     * size is 0
     */
    pastRoot(pastSize: number, tx?: IDatabaseTransaction): Promise<H>;
    /**
     * Calculate what the hash was at the time the tree contained
     * `pastSize` elements for each node index on the right side of the tree.
     */
    pastRightSiblingHashes(pastSize: number, tx?: IDatabaseTransaction): Promise<Map<number, H>>;
    /**
     * Get the root hash of the tree. Throws an error if the tree is empty.
     */
    rootHash(tx?: IDatabaseTransaction): Promise<H>;
    /**
     * Check if the tree currently contains the given element.
     */
    contains(value: E, tx?: IDatabaseTransaction): Promise<boolean>;
    /**
     * Construct the proof that the leaf node at `position` exists.
     *
     * The length of the returned vector is the depth of the leaf node in the tree
     *
     * The leftmost value in the vector, the hash at index 0, is the hash of the
     * leaf node's sibling. The rightmost value in the vector contains the hash of
     * sibling of the child of the root node.
     *
     * The root hash is not included in the authentication path.
     *
     * returns null if there are no leaves or the position is not in the list.
     */
    witness(index: LeafIndex, size?: number, tx?: IDatabaseTransaction): Promise<Witness<E, H, SE, SH> | null>;
    /**
     * Update hashes in the tree for leaves including and after startingLeafIndex.
     */
    private hashTree;
    /**
     * Updates hashOfSibling on a given node at a given index.
     */
    private updateHash;
}
export declare enum Side {
    Left = "Left",
    Right = "Right"
}
export declare type LeafIndex = number;
export declare type NodeIndex = number;
//# sourceMappingURL=merkletree.d.ts.map