/// <reference types="node" />
import { NoteEncrypted, NoteEncryptedHash, NoteEncryptedHashSerde, NoteEncryptedSerde, SerializedNoteEncrypted, SerializedNoteEncryptedHash } from '../primitives/noteEncrypted';
import { StringSerde } from '../serde';
import { JsonSerializable, Serde } from '../serde';
/**
 * Interface for objects that can calculate the hashes of elements.
 */
export interface MerkleHasher<E, H, SE extends JsonSerializable, SH extends JsonSerializable> {
    /**
     * Serializer and equality checker for the notes in the tree
     */
    elementSerde: () => Serde<E, SE>;
    /**
     * Serializer and equality checker for the hashes in the tree
     */
    hashSerde: () => Serde<H, SH>;
    /**
     * Get the hash of a given element
     */
    hash: (element: E) => H;
    /**
     * Combine two hashes to get the parent hash
     */
    combineHash: (depth: number, left: H, right: H) => H;
}
/**
 * Hasher implementation for notes to satisfy the MerkleTree requirements.
 */
export declare class NoteHasher implements MerkleHasher<NoteEncrypted, NoteEncryptedHash, SerializedNoteEncrypted, SerializedNoteEncryptedHash> {
    _merkleNoteSerde: NoteEncryptedSerde;
    _merkleNoteHashSerde: NoteEncryptedHashSerde;
    constructor();
    elementSerde(): Serde<NoteEncrypted, SerializedNoteEncrypted>;
    hashSerde(): Serde<NoteEncryptedHash, SerializedNoteEncryptedHash>;
    hash(note: NoteEncrypted): Buffer;
    combineHash(depth: number, left: NoteEncryptedHash, right: NoteEncryptedHash): NoteEncryptedHash;
}
/**
 * Demo merkle hasher implementation that combines hashes via concatenation.
 *
 * Useful for unit testing or displaying demo trees.
 */
export declare class ConcatHasher implements MerkleHasher<string, string, string, string> {
    elementSerde(): StringSerde;
    hashSerde(): StringSerde;
    combineHash(depth: number, left: string, right: string): string;
    hash(element: string): string;
}
/**
 * Demo merkle hasher implementation that indicates a range of hashes.
 *
 * Useful for unit testing or displaying demo trees. Assumes the hashes are
 * in ascending order. Takes the left and right side of a hyphen in each hash
 * and combines them.
 */
export declare class RangeHasher implements MerkleHasher<string, string, string, string> {
    elementSerde(): StringSerde;
    hashSerde(): StringSerde;
    combineHash(depth: number, left: string, right: string): string;
    hash(element: string): string;
}
/**
 * Simple hasher that encodes the tree structure in its hashes so its easy
 * to test if said structure is correct.
 *
 * Only useful for various types of unit testing.
 */
export declare class StructureHasher implements MerkleHasher<string, string, string, string> {
    elementSerde(): StringSerde;
    hashSerde(): StringSerde;
    combineHash(depth: number, left: string, right: string): string;
    hash(element: string): string;
}
//# sourceMappingURL=hasher.d.ts.map