"use strict";
/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/. */
Object.defineProperty(exports, "__esModule", { value: true });
exports.IsNoteWitnessEqual = exports.Witness = exports.SerializedWitnessNode = void 0;
const merkletree_1 = require("./merkletree");
class SerializedWitnessNode {
    constructor(_side, _hashOfSibling) {
        this._side = _side;
        this._hashOfSibling = _hashOfSibling;
        this.side = () => this._side;
        this.hashOfSibling = () => this._hashOfSibling;
    }
}
exports.SerializedWitnessNode = SerializedWitnessNode;
/**
 * Commitment that a leaf node exists in the tree with an authentication path
 * and the rootHash of the tree at the time the authentication path was calculated.
 */
class Witness {
    constructor(_treeSize, rootHash, authenticationPath, merkleHasher) {
        this._treeSize = _treeSize;
        this.rootHash = rootHash;
        this.authenticationPath = authenticationPath;
        this.merkleHasher = merkleHasher;
    }
    verify(myHash) {
        let currentHash = myHash;
        for (let i = 0; i < this.authenticationPath.length; i++) {
            const node = this.authenticationPath[i];
            if (node.side === merkletree_1.Side.Left) {
                currentHash = this.merkleHasher.combineHash(i, currentHash, node.hashOfSibling);
            }
            else {
                currentHash = this.merkleHasher.combineHash(i, node.hashOfSibling, currentHash);
            }
        }
        return this.merkleHasher.hashSerde().equals(currentHash, this.rootHash);
    }
    authPath() {
        return this.authenticationPath.map((n) => new SerializedWitnessNode(n.side, this.merkleHasher.hashSerde().serialize(n.hashOfSibling)));
    }
    treeSize() {
        return this._treeSize;
    }
    serializeRootHash() {
        return this.merkleHasher.hashSerde().serialize(this.rootHash);
    }
}
exports.Witness = Witness;
function IsNoteWitnessEqual(a, b) {
    if (a.treeSize() !== b.treeSize()) {
        return false;
    }
    if (!a.rootHash.equals(b.rootHash)) {
        return false;
    }
    const otherAuth = b.authPath();
    const thisAuth = a.authPath();
    if (thisAuth.length !== otherAuth.length) {
        return false;
    }
    for (let i = 0; i < thisAuth.length; i++) {
        const thisNode = thisAuth[i];
        const otherNode = otherAuth[i];
        const equals = thisNode.side() === otherNode.side() &&
            thisNode.hashOfSibling().equals(otherNode.hashOfSibling());
        if (!equals) {
            return false;
        }
    }
    return true;
}
exports.IsNoteWitnessEqual = IsNoteWitnessEqual;
//# sourceMappingURL=witness.js.map