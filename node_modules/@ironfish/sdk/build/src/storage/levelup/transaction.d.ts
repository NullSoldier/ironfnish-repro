import type { LevelupDatabase } from './database';
import type { LevelupStore } from './store';
import { MutexUnlockFunction } from '../../mutex';
import { DatabaseSchema, IDatabaseTransaction, SchemaKey, SchemaValue } from '../database';
import { LevelupBatch } from './batch';
export declare class LevelupTransaction implements IDatabaseTransaction {
    db: LevelupDatabase;
    batch: LevelupBatch;
    committing: boolean;
    aborting: boolean;
    cache: Map<string, unknown>;
    cacheDelete: Set<string>;
    unlock: MutexUnlockFunction | null;
    waiting: Promise<void> | null;
    waitingResolve: (() => void) | null;
    id: number;
    static id: number;
    constructor(db: LevelupDatabase);
    get size(): number;
    acquireLock(): Promise<void>;
    releaseLock(): void;
    has<Schema extends DatabaseSchema>(store: LevelupStore<Schema>, key: SchemaKey<Schema>): Promise<boolean>;
    get<Schema extends DatabaseSchema>(store: LevelupStore<Schema>, key: SchemaKey<Schema>): Promise<SchemaValue<Schema> | undefined>;
    put<Schema extends DatabaseSchema>(store: LevelupStore<Schema>, key: SchemaKey<Schema>, value: SchemaValue<Schema>): Promise<void>;
    add<Schema extends DatabaseSchema>(store: LevelupStore<Schema>, key: SchemaKey<Schema>, value: SchemaValue<Schema>): Promise<void>;
    del<Schema extends DatabaseSchema>(store: LevelupStore<Schema>, key: SchemaKey<Schema>): Promise<void>;
    update(): Promise<void>;
    commit(): Promise<void>;
    abort(): Promise<void>;
    private assertIsSameDatabase;
    private assertCanRead;
    private assertCanWrite;
}
//# sourceMappingURL=transaction.d.ts.map