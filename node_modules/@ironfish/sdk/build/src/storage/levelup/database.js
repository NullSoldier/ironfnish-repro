"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.LevelupDatabase = void 0;
const level_errors_1 = __importDefault(require("level-errors"));
const leveldown_1 = __importDefault(require("leveldown"));
const levelup_1 = __importDefault(require("levelup"));
const assert_1 = require("../../assert");
const mutex_1 = require("../../mutex");
const database_1 = require("../database");
const errors_1 = require("../database/errors");
const batch_1 = require("./batch");
const store_1 = require("./store");
const transaction_1 = require("./transaction");
function isNotFoundError(error) {
    return error?.type === 'NotFoundError';
}
class LevelupDatabase extends database_1.Database {
    constructor(db) {
        super();
        this.lock = new mutex_1.Mutex();
        this._levelup = null;
        this.db = db;
        this.metaStore = this.addStore({
            name: 'Meta',
            keyEncoding: new database_1.StringEncoding(),
            valueEncoding: new database_1.JsonEncoding(),
        });
    }
    get levelup() {
        if (!this._levelup) {
            throw new Error('Database is not open. Call IDatabase.open() first');
        }
        return this._levelup;
    }
    get isOpen() {
        return this._levelup?.isOpen() || false;
    }
    /**
     * @param options https://github.com/Level/leveldown/blob/51979d11f576c480bc5729a6adea6ac9fed57216/binding.cc#L980k,
     */
    async open() {
        this._levelup = await new Promise((resolve, reject) => {
            const opened = levelup_1.default(this.db, (error) => {
                if (error) {
                    if (error instanceof level_errors_1.default.OpenError) {
                        // Here we coerce leveldb specific errors into ironfish storage
                        // layer errors. We need to do message discrimination because the
                        // leveldb JS wrapper does not provide a way to discriminate on the
                        // various native errors. See https://github.com/Level/errors for
                        // more information.
                        if (error.message.indexOf('Corruption') !== -1) {
                            reject(new errors_1.DatabaseIsCorruptError(error.message, error));
                        }
                        else if (error.message.indexOf('IO error: lock') !== -1) {
                            reject(new errors_1.DatabaseIsLockedError(error.message, error));
                        }
                        else {
                            reject(new errors_1.DatabaseIsOpenError(error.message, error));
                        }
                    }
                    else {
                        reject(error);
                    }
                }
                else {
                    resolve(opened);
                }
            });
        });
        await this._levelup.open();
    }
    async close() {
        await this._levelup?.close();
        this._levelup = null;
    }
    async upgrade(version) {
        assert_1.Assert.isTrue(this.isOpen, 'Database needs to be open');
        const current = await this.getVersion();
        if (current !== version) {
            throw new errors_1.DatabaseVersionError(current, version);
        }
    }
    compact() {
        return new Promise((resolve, reject) => {
            if (this.db instanceof leveldown_1.default) {
                const start = database_1.DATABASE_ALL_KEY_RANGE.gte;
                const end = database_1.DATABASE_ALL_KEY_RANGE.lt;
                assert_1.Assert.isNotUndefined(start);
                assert_1.Assert.isNotUndefined(end);
                this.db.compactRange(start, end, (err) => (err ? reject(err) : resolve()));
            }
            else {
                resolve();
            }
        });
    }
    transaction(handler) {
        if (handler === undefined) {
            return new transaction_1.LevelupTransaction(this);
        }
        return this.withTransaction(null, handler);
    }
    batch(writes) {
        const batch = new batch_1.LevelupBatch(this);
        if (!writes) {
            return batch;
        }
        for (const write of writes) {
            const [store, key, value] = write;
            if (!(store instanceof store_1.LevelupStore)) {
                throw new Error();
            }
            if (value === undefined) {
                batch.del(store, key);
            }
            else {
                batch.put(store, key, value);
            }
        }
        return batch.commit();
    }
    async get(key) {
        try {
            const data = (await this.levelup.get(key));
            if (!(data instanceof Buffer)) {
                return undefined;
            }
            return data;
        }
        catch (error) {
            if (isNotFoundError(error)) {
                return undefined;
            }
            throw error;
        }
    }
    async put(key, value) {
        await this.levelup.put(key, value);
    }
    async *getAllIter(range, options) {
        const stream = this.levelup.createReadStream({ ...range, ...options });
        // The return type for createReadStream is wrong
        const iter = stream;
        for await (const { key, value } of iter) {
            yield [key, value];
        }
    }
    async getVersion() {
        let current = await this.metaStore.get('version');
        if (current === undefined) {
            current = 0;
            await this.metaStore.put('version', current);
        }
        if (typeof current !== 'number') {
            throw new Error(`Corrupted database version ${typeof current}: ${String(current)}`);
        }
        return current;
    }
    async putVersion(version, transaction) {
        await this.metaStore.put('version', version, transaction);
    }
    _createStore(options) {
        return new store_1.LevelupStore(this, options);
    }
    size() {
        return new Promise((resolve, reject) => {
            if (this.db instanceof leveldown_1.default) {
                const start = database_1.DATABASE_ALL_KEY_RANGE.gte;
                const end = database_1.DATABASE_ALL_KEY_RANGE.lt;
                assert_1.Assert.isNotUndefined(start);
                assert_1.Assert.isNotUndefined(end);
                this.db.approximateSize(start, end, (err, size) => (err ? reject(err) : resolve(size)));
            }
            else {
                resolve(0);
            }
        });
    }
}
exports.LevelupDatabase = LevelupDatabase;
//# sourceMappingURL=database.js.map