"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.LevelupTransaction = void 0;
const database_1 = require("../database");
const batch_1 = require("./batch");
class LevelupTransaction {
    constructor(db) {
        this.committing = false;
        this.aborting = false;
        this.cache = new Map();
        this.cacheDelete = new Set();
        this.unlock = null;
        this.waiting = null;
        this.waitingResolve = null;
        this.id = 0;
        this.db = db;
        this.id = ++LevelupTransaction.id;
        this.batch = new batch_1.LevelupBatch(db);
    }
    get size() {
        return this.batch.queue.length;
    }
    async acquireLock() {
        if (this.unlock) {
            return;
        }
        if (!this.waiting) {
            this.waiting = new Promise((resolve) => (this.waitingResolve = resolve));
            this.unlock = await this.db.lock.lock();
            if (this.waitingResolve) {
                this.waitingResolve();
            }
            this.waiting = null;
            this.waitingResolve = null;
        }
        else {
            await this.waiting;
        }
    }
    releaseLock() {
        if (!this.unlock) {
            return;
        }
        this.unlock();
    }
    async has(store, key) {
        await this.acquireLock();
        return (await this.get(store, key)) !== undefined;
    }
    async get(store, key) {
        await this.acquireLock();
        this.assertIsSameDatabase(store);
        this.assertCanRead();
        const [encodedKey] = store.encode(key);
        const cacheKey = database_1.BufferToStringEncoding.serialize(encodedKey);
        if (this.cacheDelete.has(cacheKey)) {
            return undefined;
        }
        if (this.cache.has(cacheKey)) {
            const cached = this.cache.get(cacheKey);
            return cached;
        }
        const value = await store.get(key);
        this.cache.set(cacheKey, value);
        return value;
    }
    async put(store, key, value) {
        await this.acquireLock();
        this.assertIsSameDatabase(store);
        this.assertCanWrite();
        const [encodedKey, encodedValue] = store.encode(key, value);
        const cacheKey = database_1.BufferToStringEncoding.serialize(encodedKey);
        this.batch.putEncoded(encodedKey, encodedValue);
        this.cache.set(cacheKey, value);
        this.cacheDelete.delete(cacheKey);
    }
    async add(store, key, value) {
        await this.acquireLock();
        this.assertIsSameDatabase(store);
        this.assertCanWrite();
        if (await this.has(store, key)) {
            throw new database_1.DuplicateKeyError(`Key already exists ${String(key)}`);
        }
        const [encodedKey, encodedValue] = store.encode(key, value);
        const cacheKey = database_1.BufferToStringEncoding.serialize(encodedKey);
        this.batch.putEncoded(encodedKey, encodedValue);
        this.cache.set(cacheKey, value);
        this.cacheDelete.delete(cacheKey);
    }
    async del(store, key) {
        await this.acquireLock();
        this.assertIsSameDatabase(store);
        this.assertCanWrite();
        const [encodedKey] = store.encode(key);
        const cacheKey = database_1.BufferToStringEncoding.serialize(encodedKey);
        this.batch.delEncoded(encodedKey);
        this.cache.set(cacheKey, undefined);
        this.cacheDelete.add(cacheKey);
    }
    async update() {
        try {
            if (!this.aborting) {
                await this.batch.commit();
            }
        }
        finally {
            this.cache.clear();
            this.cacheDelete.clear();
            this.committing = false;
        }
    }
    async commit() {
        try {
            await this.update();
        }
        finally {
            this.releaseLock();
        }
    }
    async abort() {
        this.aborting = true;
        this.releaseLock();
        return Promise.resolve();
    }
    assertIsSameDatabase(store) {
        if (store.db !== this.db) {
            throw new database_1.TransactionWrongDatabaseError(store.name);
        }
    }
    assertCanRead() {
        this.assertCanWrite();
    }
    assertCanWrite() {
        if (this.committing) {
            throw new Error(`Transaction is being committed`);
        }
    }
}
exports.LevelupTransaction = LevelupTransaction;
LevelupTransaction.id = 0;
//# sourceMappingURL=transaction.js.map