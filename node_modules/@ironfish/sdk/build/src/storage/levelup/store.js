"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.LevelupStore = void 0;
const buffer_map_1 = require("buffer-map");
const fastpriorityqueue_1 = __importDefault(require("fastpriorityqueue"));
const imurmurhash_1 = __importDefault(require("imurmurhash"));
const assert_1 = require("../../assert");
const async_1 = require("../../utils/async");
const database_1 = require("../database");
const encoding_1 = require("../database/encoding");
const utils_1 = require("../database/utils");
const transaction_1 = require("./transaction");
const ENABLE_TRANSACTIONS = true;
class LevelupStore extends database_1.DatabaseStore {
    constructor(db, options) {
        super(options);
        this.db = db;
        // Hash the prefix key to ensure identical length and avoid collisions
        const prefixHash = new imurmurhash_1.default(this.name, 1).result();
        this.prefixBuffer = Buffer.alloc(4);
        this.prefixBuffer.writeUInt32BE(prefixHash);
        this.allKeysRange = utils_1.StorageUtils.getPrefixKeyRange(this.prefixBuffer);
    }
    async has(key, transaction) {
        const [encodedKey] = this.encode(key);
        if (ENABLE_TRANSACTIONS && transaction instanceof transaction_1.LevelupTransaction) {
            return transaction.has(this, key);
        }
        return (await this.db.get(encodedKey)) !== undefined;
    }
    async get(key, transaction) {
        const [encodedKey] = this.encode(key);
        if (ENABLE_TRANSACTIONS && transaction instanceof transaction_1.LevelupTransaction) {
            return transaction.get(this, key);
        }
        const data = await this.db.get(encodedKey);
        if (data === undefined) {
            return undefined;
        }
        return this.valueEncoding.deserialize(data);
    }
    /* Get an [[`AsyncGenerator`]] that yields all of the key/value pairs in the IDatastore */
    async *getAllIter(transaction, keyRange, iteratorOptions) {
        if (keyRange) {
            keyRange = utils_1.StorageUtils.addPrefixToRange(keyRange, this.prefixBuffer);
        }
        else {
            keyRange = this.allKeysRange;
        }
        const seen = new buffer_map_1.BufferSet();
        const cacheElements = new fastpriorityqueue_1.default(({ key: a }, { key: b }) => iteratorOptions?.reverse ? b.compare(a) < 0 : a.compare(b) < 0);
        if (ENABLE_TRANSACTIONS && transaction) {
            assert_1.Assert.isInstanceOf(transaction, transaction_1.LevelupTransaction);
            await transaction.acquireLock();
            for (const [keyString, value] of transaction.cache.entries()) {
                const key = encoding_1.BufferToStringEncoding.deserialize(keyString);
                if (!utils_1.StorageUtils.hasPrefix(key, this.prefixBuffer)) {
                    continue;
                }
                if (!utils_1.StorageUtils.isInRange(key, keyRange)) {
                    continue;
                }
                seen.add(key);
                if (value === undefined) {
                    continue;
                }
                if (iteratorOptions?.ordered) {
                    cacheElements.add({ key: key, value: value });
                }
                else {
                    yield [this.decodeKey(key), value];
                }
            }
        }
        let nextCacheElement = cacheElements.peek();
        for await (const [key, value] of this.db.getAllIter(keyRange, iteratorOptions)) {
            while (nextCacheElement &&
                (iteratorOptions?.reverse
                    ? key.compare(nextCacheElement.key) <= 0
                    : key.compare(nextCacheElement.key) >= 0)) {
                const element = cacheElements.poll();
                assert_1.Assert.isNotUndefined(element);
                yield [this.decodeKey(element.key), element.value];
                nextCacheElement = cacheElements.peek();
            }
            if (seen.has(key)) {
                continue;
            }
            else {
                yield [this.decodeKey(key), this.valueEncoding.deserialize(value)];
            }
        }
        while (!cacheElements.isEmpty()) {
            const element = cacheElements.poll();
            assert_1.Assert.isNotUndefined(element);
            yield [this.decodeKey(element.key), element.value];
        }
    }
    async getAll(transaction, keyRange, iteratorOptions) {
        return async_1.AsyncUtils.materialize(this.getAllIter(transaction, keyRange, iteratorOptions));
    }
    async *getAllValuesIter(transaction, keyRange, iteratorOptions) {
        for await (const [, value] of this.getAllIter(transaction, keyRange, iteratorOptions)) {
            yield value;
        }
    }
    async getAllValues(transaction, keyRange, iteratorOptions) {
        return async_1.AsyncUtils.materialize(this.getAllValuesIter(transaction, keyRange, iteratorOptions));
    }
    async *getAllKeysIter(transaction, keyRange, iteratorOptions) {
        for await (const [key] of this.getAllIter(transaction, keyRange, iteratorOptions)) {
            yield key;
        }
    }
    async getAllKeys(transaction, keyRange, iteratorOptions) {
        return async_1.AsyncUtils.materialize(this.getAllKeysIter(transaction, keyRange, iteratorOptions));
    }
    async clear(transaction, keyRange) {
        if (transaction) {
            for await (const key of this.getAllKeysIter(transaction, keyRange)) {
                await this.del(key, transaction);
            }
            return;
        }
        if (keyRange) {
            keyRange = utils_1.StorageUtils.addPrefixToRange(keyRange, this.prefixBuffer);
        }
        else {
            keyRange = this.allKeysRange;
        }
        await this.db.levelup.clear(keyRange ?? this.allKeysRange);
    }
    async put(a, b, c) {
        const { key, value, transaction } = parsePut(a, b, c);
        if (key === undefined) {
            throw new Error('No key defined');
        }
        if (ENABLE_TRANSACTIONS && transaction instanceof transaction_1.LevelupTransaction) {
            return transaction.put(this, key, value);
        }
        const [encodedKey, encodedValue] = this.encode(key, value);
        await this.db.put(encodedKey, encodedValue);
    }
    async add(a, b, c) {
        const { key, value, transaction } = parsePut(a, b, c);
        if (key === undefined) {
            throw new Error('No key defined');
        }
        if (ENABLE_TRANSACTIONS && transaction instanceof transaction_1.LevelupTransaction) {
            return transaction.add(this, key, value);
        }
        if (await this.has(key, transaction)) {
            throw new database_1.DuplicateKeyError(`Key already exists ${String(key)}`);
        }
        const [encodedKey, encodedValue] = this.encode(key, value);
        await this.db.put(encodedKey, encodedValue);
    }
    async del(key, transaction) {
        if (ENABLE_TRANSACTIONS && transaction instanceof transaction_1.LevelupTransaction) {
            return transaction.del(this, key);
        }
        const [encodedKey] = this.encode(key);
        await this.db.levelup.del(encodedKey);
    }
    encode(key, value) {
        const keyBuffer = this.keyEncoding.serialize(key);
        const encodedKey = Buffer.concat([this.prefixBuffer, keyBuffer]);
        if (value === undefined) {
            return [encodedKey];
        }
        return [encodedKey, this.valueEncoding.serialize(value)];
    }
    decodeKey(key) {
        const keyWithoutPrefix = key.slice(this.prefixBuffer.byteLength);
        return this.keyEncoding.deserialize(keyWithoutPrefix);
    }
}
exports.LevelupStore = LevelupStore;
function parsePut(keyOrValue, valueOrTransaction, transaction) {
    if (transaction instanceof transaction_1.LevelupTransaction) {
        return {
            key: keyOrValue,
            value: valueOrTransaction,
            transaction: transaction,
        };
    }
    if (valueOrTransaction instanceof transaction_1.LevelupTransaction) {
        return {
            value: keyOrValue,
            transaction: valueOrTransaction,
        };
    }
    if (valueOrTransaction !== undefined) {
        return {
            key: keyOrValue,
            value: valueOrTransaction,
        };
    }
    return {
        value: keyOrValue,
    };
}
//# sourceMappingURL=store.js.map