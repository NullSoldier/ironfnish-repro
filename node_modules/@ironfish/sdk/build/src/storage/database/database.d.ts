/// <reference types="node" />
import { BatchOperation, IDatabaseBatch } from './batch';
import { IDatabaseStore, IDatabaseStoreOptions } from './store';
import { IDatabaseTransaction } from './transaction';
import { DatabaseIteratorOptions, DatabaseKeyRange, DatabaseOptions, DatabaseSchema, SchemaKey, SchemaValue } from './types';
export declare const DATABASE_ALL_KEY_RANGE: DatabaseKeyRange;
/**
 * A database interface to represent a wrapper for a key value store database. The database is the entry point for creating stores, batches, transactions.
 *
 * The general idea is that you should create a database and add [[`IDatabaseStore`]]s to it. The stores are where all the operations occur, and accept transactions.

* Three important functions on this interface are
* * [[`IDatabase.addStore`]]
* * [[`IDatabase.transaction`]]
* * [[`IDatabase.batch`]]
*/
export interface IDatabase {
    /**
     * If the database is open and available for operations
     */
    readonly isOpen: boolean;
    /**
     * Opens a connection to the database with the given options
     *
     * Your provided upgrade function in [[`DatabaseOptions.upgrade`]] will be called if
     * the version you provide is larger than the stored version.
     */
    open(options?: DatabaseOptions): Promise<void>;
    /** Closes the database and does not handle any open transactions */
    close(): Promise<void>;
    /** Internal book keeping function to clean up unused space by the database */
    compact(): Promise<void>;
    /**
     * Check if the database needs to be upgraded
     */
    upgrade(version: number): Promise<void>;
    getVersion(): Promise<number>;
    putVersion(version: number, transaction?: IDatabaseTransaction): Promise<void>;
    /**
     * Add an {@link IDatabaseStore} to the database
     *
     * You can only add a store to the database if the database is not open. This is because some databases only
     * allow initializing new stores when the database is being opened.
     * @param options The options for the new store
     */
    addStore<Schema extends DatabaseSchema>(options: IDatabaseStoreOptions<Schema>, requireUnique?: boolean): IDatabaseStore<Schema>;
    /** Get all the stores added with [[`IDatabase.addStore`]] */
    getStores(): Array<IDatabaseStore<DatabaseSchema>>;
    /**
     * Starts a {@link IDatabaseTransaction} and returns it.
     *
     * @warning If you use this then it's up to you to manage the transactions life cycle.
     * You should not forget to call [[`IDatabaseTransaction.commit`]] or [[`IDatabaseTransaction.abort`]].
     * If you don't you will deadlock the database. This is why it's better and safer to use [[`IDatabase.transaction::OVERLOAD_2`]]
     *
     * @returns A new transaction
     */
    transaction(): IDatabaseTransaction;
    /**
     * Starts a {@link IDatabaseTransaction} and executes your handler with it
     *
     * This is the safest transactional function because it guarantees when your
     * code finishes, the transaction will be either committed or aborted if an
     * exception has been thrown.
     *
     * @param handler You should pass in a function with your code that you want
     * to run in the transaction. The handler accepts a transaction and any returns
     * are forwarded out.
     *
     * @returns Forwards the result of your handler to it's return value
     */
    transaction<TResult>(handler: (transaction: IDatabaseTransaction) => Promise<TResult>): Promise<TResult>;
    /**
     * Uses an existing transaction or starts a transaction and executes your
     * handler with it. It commits or aborts the transaction only if a call to
     * this function has created one.
     *
     * Use this when you are given an optional transaction, where you may want
     * to create one if one has not been created.
     *
     * @param handler You should pass in a function with your code that you want
     * to run in the transaction. The handler accepts a transaction and any returns
     * are forwarded out.
     *
     * @returns Forwards the result of your handler to it's return value
     */
    withTransaction<TResult>(transaction: IDatabaseTransaction | undefined | null, handler: (transaction: IDatabaseTransaction) => Promise<TResult>): Promise<TResult>;
    /** Creates a batch of commands that are executed atomically
     * once it's committed using {@link IDatabaseBatch.commit}
     *
     * @see [[`IDatabaseBatch`]] for what operations are supported
     */
    batch(): IDatabaseBatch;
    /**
     * Executes a batch of database operations atomically
     *
     * @returns A promise that resolves when the operations are committed to the database
     */
    batch(writes: BatchOperation<DatabaseSchema, SchemaKey<DatabaseSchema>, SchemaValue<DatabaseSchema>>[]): Promise<void>;
    /**
     * Used to get a value from the database at a given key
  
    * @param key - The key to fetch
    *
    * @returns resolves with the serialized value if found, or undefined if not found.
    */
    get(key: Readonly<Buffer>): Promise<Buffer | undefined>;
    /**
     * Put a value into the store with the given key.
  
    * @param key - The key to insert
    * @param value - The value to insert
    *
    * @returns A promise that resolves when the operation has been executed.
    */
    put(key: Readonly<Buffer>, value: Buffer): Promise<void>;
    getAllIter(range?: DatabaseKeyRange, options?: DatabaseIteratorOptions): AsyncGenerator<[Buffer, Buffer]>;
    size(): Promise<number>;
}
export declare abstract class Database implements IDatabase {
    stores: IDatabaseStore<DatabaseSchema<unknown, unknown>>[];
    abstract get isOpen(): boolean;
    abstract open(options?: DatabaseOptions): Promise<void>;
    abstract close(): Promise<void>;
    abstract upgrade(version: number): Promise<void>;
    abstract getVersion(): Promise<number>;
    abstract putVersion(version: number): Promise<void>;
    abstract compact(): Promise<void>;
    abstract transaction(): IDatabaseTransaction;
    abstract transaction<TResult>(handler: (transaction: IDatabaseTransaction) => Promise<TResult>): Promise<TResult>;
    abstract batch(): IDatabaseBatch;
    abstract batch(writes: BatchOperation<DatabaseSchema, SchemaKey<DatabaseSchema>, SchemaValue<DatabaseSchema>>[]): Promise<void>;
    abstract get(key: Readonly<Buffer>): Promise<Buffer | undefined>;
    abstract put(key: Readonly<Buffer>, value: Buffer): Promise<void>;
    abstract getAllIter(range?: DatabaseKeyRange, options?: DatabaseIteratorOptions): AsyncGenerator<[Buffer, Buffer]>;
    protected abstract _createStore<Schema extends DatabaseSchema>(options: IDatabaseStoreOptions<Schema>): IDatabaseStore<Schema>;
    getStores(): Array<IDatabaseStore<DatabaseSchema>>;
    addStore<Schema extends DatabaseSchema>(options: IDatabaseStoreOptions<Schema>, requireUnique?: boolean): IDatabaseStore<Schema>;
    abstract size(): Promise<number>;
    withTransaction<TResult>(transaction: IDatabaseTransaction | undefined | null, handler: (transaction: IDatabaseTransaction) => Promise<TResult>): Promise<TResult>;
}
//# sourceMappingURL=database.d.ts.map