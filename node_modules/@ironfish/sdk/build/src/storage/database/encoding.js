"use strict";
/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/. */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.U64_ENCODING = exports.NULL_ENCODING = exports.U32_ENCODING_BE = exports.U32_ENCODING = exports.BUFFER_ENCODING = exports.BufferToStringEncoding = exports.U64Encoding = exports.BigU64BEEncoding = exports.BigIntLEEncoding = exports.ArrayEncoding = exports.NullableStringEncoding = exports.StringHashEncoding = exports.NullableBufferEncoding = exports.PrefixEncoding = exports.PrefixSizeError = exports.BufferEncoding = exports.NullEncoding = exports.U32EncodingBE = exports.U32Encoding = exports.StringEncoding = exports.JsonEncoding = void 0;
const bufio_1 = __importDefault(require("bufio"));
const serde_1 = require("../../serde");
const utils_1 = require("../../utils");
class JsonEncoding {
    constructor() {
        this.serialize = (value) => Buffer.from(serde_1.IJSON.stringify(value), 'utf8');
        this.deserialize = (buffer) => serde_1.IJSON.parse(buffer.toString('utf8'));
    }
}
exports.JsonEncoding = JsonEncoding;
class StringEncoding {
    constructor() {
        this.serialize = (value) => Buffer.from(value, 'utf8');
        this.deserialize = (buffer) => buffer.toString('utf8');
    }
}
exports.StringEncoding = StringEncoding;
class U32Encoding {
    serialize(value) {
        const buffer = Buffer.alloc(4);
        buffer.writeUInt32LE(value);
        return buffer;
    }
    deserialize(buffer) {
        return buffer.readUInt32LE();
    }
}
exports.U32Encoding = U32Encoding;
class U32EncodingBE {
    serialize(value) {
        const buffer = Buffer.alloc(4);
        buffer.writeUInt32BE(value);
        return buffer;
    }
    deserialize(buffer) {
        return buffer.readUInt32BE();
    }
}
exports.U32EncodingBE = U32EncodingBE;
class NullEncoding {
    serialize() {
        return NullEncoding.EMPTY_BUFFER;
    }
    deserialize() {
        return null;
    }
}
exports.NullEncoding = NullEncoding;
NullEncoding.EMPTY_BUFFER = Buffer.alloc(0);
class BufferEncoding {
    constructor() {
        this.serialize = (value) => value;
        this.deserialize = (buffer) => buffer;
    }
}
exports.BufferEncoding = BufferEncoding;
class PrefixSizeError extends Error {
    constructor() {
        super(...arguments);
        this.name = this.constructor.name;
    }
}
exports.PrefixSizeError = PrefixSizeError;
class PrefixEncoding {
    constructor(prefixEncoding, keyEncoding, prefixSize) {
        this.serialize = (value) => {
            const prefixEncoded = this.prefixEncoding.serialize(value[0]);
            const keyEncoded = this.keyEncoding.serialize(value[1]);
            if (prefixEncoded.byteLength !== this.prefixSize) {
                throw new PrefixSizeError(`key prefix expected to be ${this.prefixSize} byte(s) but was ${prefixEncoded.byteLength}`);
            }
            return Buffer.concat([prefixEncoded, keyEncoded]);
        };
        this.deserialize = (buffer) => {
            const prefix = buffer.slice(0, this.prefixSize);
            const key = buffer.slice(this.prefixSize);
            const prefixDecoded = this.prefixEncoding.deserialize(prefix);
            const keyDecoded = this.keyEncoding.deserialize(key);
            return [prefixDecoded, keyDecoded];
        };
        this.keyEncoding = keyEncoding;
        this.prefixEncoding = prefixEncoding;
        this.prefixSize = prefixSize;
    }
}
exports.PrefixEncoding = PrefixEncoding;
class NullableBufferEncoding {
    constructor() {
        this.serialize = (value) => {
            const size = value ? bufio_1.default.sizeVarBytes(value) : 0;
            const buffer = bufio_1.default.write(size);
            if (value) {
                buffer.writeVarBytes(value);
            }
            return buffer.render();
        };
    }
    deserialize(buffer) {
        const reader = bufio_1.default.read(buffer, true);
        if (reader.left()) {
            return reader.readVarBytes();
        }
        return null;
    }
}
exports.NullableBufferEncoding = NullableBufferEncoding;
class StringHashEncoding {
    serialize(value) {
        const buffer = bufio_1.default.write(32);
        buffer.writeHash(value);
        return buffer.render();
    }
    deserialize(buffer) {
        const reader = bufio_1.default.read(buffer, true);
        const hash = reader.readHash();
        return hash.toString('hex');
    }
}
exports.StringHashEncoding = StringHashEncoding;
class NullableStringEncoding {
    serialize(value) {
        const size = value ? bufio_1.default.sizeVarString(value, 'utf8') : 0;
        const buffer = bufio_1.default.write(size);
        if (value) {
            buffer.writeVarString(value, 'utf8');
        }
        return buffer.render();
    }
    deserialize(buffer) {
        const reader = bufio_1.default.read(buffer, true);
        if (reader.left()) {
            return reader.readVarString('utf8');
        }
        return null;
    }
}
exports.NullableStringEncoding = NullableStringEncoding;
class ArrayEncoding extends JsonEncoding {
}
exports.ArrayEncoding = ArrayEncoding;
class BigIntLEEncoding {
    serialize(value) {
        return utils_1.BigIntUtils.toBytesLE(value);
    }
    deserialize(buffer) {
        return utils_1.BigIntUtils.fromBytesLE(buffer);
    }
}
exports.BigIntLEEncoding = BigIntLEEncoding;
class BigU64BEEncoding {
    serialize(value) {
        const buffer = bufio_1.default.write(8);
        buffer.writeBigU64BE(value);
        return buffer.render();
    }
    deserialize(buffer) {
        const reader = bufio_1.default.read(buffer, true);
        return reader.readBigU64BE();
    }
}
exports.BigU64BEEncoding = BigU64BEEncoding;
class U64Encoding {
    serialize(value) {
        const buffer = bufio_1.default.write(8);
        buffer.writeBigU64BE(BigInt(value));
        return buffer.render();
    }
    deserialize(buffer) {
        const reader = bufio_1.default.read(buffer, true);
        return Number(reader.readBigU64BE());
    }
}
exports.U64Encoding = U64Encoding;
class BufferToStringEncoding {
    static serialize(element) {
        return element.toString('hex');
    }
    static deserialize(data) {
        return Buffer.from(data, 'hex');
    }
}
exports.BufferToStringEncoding = BufferToStringEncoding;
exports.BUFFER_ENCODING = new BufferEncoding();
exports.U32_ENCODING = new U32Encoding();
exports.U32_ENCODING_BE = new U32EncodingBE();
exports.NULL_ENCODING = new NullEncoding();
exports.U64_ENCODING = new U64Encoding();
//# sourceMappingURL=encoding.js.map