/// <reference types="node" />
/**
 * Accept two bigints and return the larger of the two,
 * in the case of equality, b is returned
 */
declare function max(a: bigint, b: bigint): bigint;
/**
 * Accept two bigints and return the smaller of the two,
 * in the case of equality, b is returned
 */
declare function min(a: bigint, b: bigint): bigint;
/**
 * Courtesy of https://coolaj86.com/articles/convert-js-bigints-to-typedarrays/
 *
 * Convert a Buffer to a big integer number, in big endian format.
 *
 * I'm concerned about efficiency here. Converting a string and back and... WTF?
 * Every block hash attempt has to be converted to a Target, so this is a function
 * that should be optimized. We may want to compile this to wasm if there isn't
 * a less janky way to do it.
 *
 * I'm pushing it out like this for now so I can focus on bigger architecture concerns.
 *
 * Sorry.
 */
declare function fromBytesBE(bytes: Buffer): bigint;
declare function fromBytesLE(bytes: Buffer): bigint;
/**
 * Writes a bigint to a Buffer, in big endian format.
 *
 * TODO: Handle negative numbers, or add an assertion that the
 * incoming bigint is non-negative, and fix the places where we're calling
 * it with a negative number (at least one place is miners fee serialization)
 */
declare function toBytesBE(value: bigint): Buffer;
/**
 * TODO: Handle negative numbers, or add an assertion that the
 * incoming bigint is non-negative, and fix the places where we're calling
 * it with a negative number (at least one place is miners fee serialization)
 */
declare function toBytesLE(value: bigint): Buffer;
declare function writeBigU64BE(value: bigint): Buffer;
declare function writeBigU256BE(value: bigint): Buffer;
/**
 * Divides two BigInt types and returns a number. That has floating
 * point precision. Regular BigInt division will not have decimals
 */
declare function divide(a: bigint, b: bigint): number;
declare function tryParse(value: string): [bigint, null] | [null, Error];
export declare const BigIntUtils: {
    fromBytesBE: typeof fromBytesBE;
    fromBytesLE: typeof fromBytesLE;
    toBytesBE: typeof toBytesBE;
    toBytesLE: typeof toBytesLE;
    max: typeof max;
    min: typeof min;
    divide: typeof divide;
    tryParse: typeof tryParse;
    writeBigU64BE: typeof writeBigU64BE;
    writeBigU256BE: typeof writeBigU256BE;
};
export {};
//# sourceMappingURL=bigint.d.ts.map