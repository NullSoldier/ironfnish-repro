"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.BenchUtils = void 0;
/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/. */
const file_1 = require("./file");
const math_1 = require("./math");
const time_1 = require("./time");
function startTime() {
    return process.hrtime();
}
/**
 * @returns milliseconds since start
 */
function endTime(start) {
    const [sec, nanosec] = process.hrtime(start);
    return sec * 1000 + nanosec / 1e6;
}
function diffTime(startTime, endTime) {
    const [secStart, nanosecStart] = startTime;
    const [secEnd, nanosecEnd] = endTime;
    const start = secStart * 1000 + nanosecStart / 1e6;
    const end = secEnd * 1000 + nanosecEnd / 1e6;
    return end - start;
}
function getSegment() {
    const time = startTime();
    if (global.gc) {
        // Need to mark and sweep multiple times to try to collect all of it. You
        // could also just continue to do this until memory stabilizes but this
        // is good enough.
        for (let i = 0; i < 5; ++i) {
            global.gc();
        }
    }
    const startMem = process.memoryUsage();
    const heap = startMem.heapUsed;
    const rss = startMem.rss;
    const mem = heap + rss;
    return { time, heap, rss, mem };
}
function startSegment() {
    return getSegment();
}
function endSegment(start) {
    const end = getSegment();
    return {
        time: diffTime(start.time, end.time),
        heap: end.heap - start.heap,
        rss: end.rss - start.rss,
        mem: end.mem - start.mem,
    };
}
function renderSegment(segment, title = 'Benchmark', delimiter = ', ') {
    const result = [];
    result.push(`Timespan: ${time_1.TimeUtils.renderSpan(segment.time)}`);
    result.push(`Heap: ${file_1.FileUtils.formatMemorySize(segment.heap)}`);
    result.push(`RSS: ${file_1.FileUtils.formatMemorySize(segment.rss)}`);
    result.push(`Mem: ${file_1.FileUtils.formatMemorySize(segment.mem)}`);
    let rendered = result.join(delimiter);
    if (title) {
        rendered = `${title} - ` + rendered;
    }
    return rendered;
}
function renderSegmentAggregate(segmentAggregate, title = 'Benchmark', delimiter = '\n') {
    const result = [];
    const renderAggregate = (name, aggregate, renderFn) => {
        return `${name}: min: ${renderFn(aggregate.min)}, avg: ${renderFn(aggregate.avg)}, median: ${renderFn(aggregate.median)}, max ${renderFn(aggregate.max)}`;
    };
    result.push(`Iterations: ${segmentAggregate.iterations}`);
    result.push(renderAggregate('Time', segmentAggregate.time, time_1.TimeUtils.renderSpan));
    result.push(renderAggregate('Heap', segmentAggregate.heap, file_1.FileUtils.formatMemorySize));
    result.push(renderAggregate('Rss', segmentAggregate.rss, file_1.FileUtils.formatMemorySize));
    result.push(renderAggregate('Mem', segmentAggregate.mem, file_1.FileUtils.formatMemorySize));
    let rendered = result.join(delimiter);
    if (title) {
        rendered = `${title}` + delimiter + rendered;
    }
    return rendered;
}
async function withSegment(fn) {
    const segment = startSegment();
    await fn();
    return endSegment(segment);
}
async function withSegmentIterations(warmupIterations, testIterations, fn) {
    for (let i = 0; i < warmupIterations; i++) {
        await fn();
    }
    const results = [];
    for (let i = 0; i < testIterations; i++) {
        results.push(await withSegment(fn));
    }
    return aggregateResults(results);
}
function aggregateResults(results) {
    const assignResults = (key, sortedArray) => {
        key.min = sortedArray[0];
        key.max = sortedArray[time.length - 1];
        key.avg = math_1.MathUtils.arrayAverage(sortedArray);
        key.median = math_1.MathUtils.arrayMedian(sortedArray, true);
    };
    const aggregateResults = {
        iterations: results.length,
        time: { min: 0, max: 0, avg: 0, median: 0 },
        heap: { min: 0, max: 0, avg: 0, median: 0 },
        rss: { min: 0, max: 0, avg: 0, median: 0 },
        mem: { min: 0, max: 0, avg: 0, median: 0 },
    };
    const time = results.map((r) => r.time).sort();
    const heap = results.map((r) => r.heap).sort();
    const rss = results.map((r) => r.rss).sort();
    const mem = results.map((r) => r.mem).sort();
    assignResults(aggregateResults.time, time);
    assignResults(aggregateResults.heap, heap);
    assignResults(aggregateResults.rss, rss);
    assignResults(aggregateResults.mem, mem);
    return aggregateResults;
}
exports.BenchUtils = {
    start: startTime,
    end: endTime,
    startSegment,
    endSegment,
    renderSegment,
    renderSegmentAggregate,
    withSegment,
    withSegmentIterations,
};
//# sourceMappingURL=bench.js.map