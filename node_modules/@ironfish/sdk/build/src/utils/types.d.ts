/// <reference types="node" />
/**
 * Equivalent to the builtin Partial<T> just recursive.
 *
 * @see https://www.typescriptlang.org/docs/handbook/utility-types.html#partialtype
 */
export declare type PartialRecursive<T> = {
    [P in keyof T]?: T[P] extends (infer U)[] ? PartialRecursive<U>[] : T[P] extends Record<string, unknown> ? PartialRecursive<T[P]> : T[P];
};
/**
 * Converts a type from Promise<T> to T.
 *
 * This does not unwrap recursively.
 */
export declare type UnwrapPromise<T> = T extends Promise<infer U> ? U : T extends (...args: unknown[]) => Promise<infer U> ? U : T extends (...args: unknown[]) => infer U ? U : T;
/**
 * The return type of setTimeout, this type be used with clearTimeout
 *
 * This exists because the return type is different on the web versus node
 * */
export declare type SetTimeoutToken = ReturnType<typeof setTimeout>;
/**
 * The return type of `setInterval`. This type can be used with `clearInterval`.
 */
export declare type SetIntervalToken = ReturnType<typeof setInterval>;
export declare function IsNodeTimeout(timer: number | NodeJS.Timeout): timer is NodeJS.Timeout;
export declare type Constructor<T> = new (...args: any[]) => T;
export declare function HasOwnProperty<X extends {}, Y extends PropertyKey>(obj: X, prop: Y): boolean;
export declare type WithNonNull<T, K extends keyof T> = T & {
    [P in K]: NonNullable<T[P]>;
};
//# sourceMappingURL=types.d.ts.map