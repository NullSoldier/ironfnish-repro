"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ChainProcessor = void 0;
const assert_1 = require("./assert");
const event_1 = require("./event");
const logger_1 = require("./logger");
/**
 * This is used to get a non synchronous chain of block events from the blockchain
 * As blocks are added and removed, this system will call onAdd() and onRemove() in
 * a guaranteed correct order. If you have this chain:
 *      G -> A1
 *
 * You'll get
 *  - onAdd(G)
 *  - onAdd(A1)
 *
 * If you then reorg and have received
 *      G -> A1
 *        -> B1 -> B2
 *
 * - onAdd(G)
 * - onAdd(A1)
 * - onRemove(A1)
 * - onAdd(B1)
 * - onAdd(B2)
 */
class ChainProcessor {
    constructor(options) {
        // TODO: Consider refactoring to store a BlockHeader rather than a hash + sequence
        this.hash = null;
        this.sequence = null;
        this.onAdd = new event_1.Event();
        this.onRemove = new event_1.Event();
        this.chain = options.chain;
        this.logger = (options.logger ?? logger_1.createRootLogger()).withTag('chainprocessor');
        this.hash = options.head;
    }
    async add(header) {
        await this.onAdd.emitAsync(header);
    }
    async remove(header) {
        await this.onRemove.emitAsync(header);
    }
    async update({ signal } = {}) {
        const oldHash = this.hash;
        if (!this.hash) {
            await this.add(this.chain.genesis);
            this.hash = this.chain.genesis.hash;
            this.sequence = this.chain.genesis.sequence;
        }
        // Freeze this value in case it changes while we're updating the head
        const chainHead = this.chain.head;
        if (chainHead.hash.equals(this.hash)) {
            return { hashChanged: false };
        }
        const head = await this.chain.getHeader(this.hash);
        assert_1.Assert.isNotNull(head, `Chain processor head not found in chain: ${this.hash.toString('hex')}`);
        const fork = await this.chain.findFork(head, chainHead);
        // All cases can be handled by rewinding to the fork point
        // and then fast-forwarding to the destination. In cases where `head` and `chainHead`
        // are on the same linear chain, either rewind or fast-forward will just be a no-op
        const iterBackwards = this.chain.iterateFrom(head, fork, undefined, false);
        for await (const remove of iterBackwards) {
            if (signal?.aborted) {
                return { hashChanged: !oldHash || !this.hash.equals(oldHash) };
            }
            if (remove.hash.equals(fork.hash)) {
                continue;
            }
            await this.remove(remove);
            this.hash = remove.previousBlockHash;
            this.sequence = remove.sequence - 1;
        }
        const iterForwards = this.chain.iterateTo(fork, chainHead, undefined, false);
        for await (const add of iterForwards) {
            if (signal?.aborted) {
                return { hashChanged: !oldHash || !this.hash.equals(oldHash) };
            }
            if (add.hash.equals(fork.hash)) {
                continue;
            }
            await this.add(add);
            this.hash = add.hash;
            this.sequence = add.sequence;
        }
        return { hashChanged: !oldHash || !this.hash.equals(oldHash) };
    }
}
exports.ChainProcessor = ChainProcessor;
//# sourceMappingURL=chainProcessor.js.map