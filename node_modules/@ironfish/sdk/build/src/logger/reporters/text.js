"use strict";
/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/. */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.TextReporter = void 0;
// The reporter intentionally logs to the console, so disable the lint
/* eslint-disable no-console */
const safe_1 = __importDefault(require("colors/safe"));
const consola_1 = require("consola");
const date_fns_1 = require("date-fns");
const string_1 = require("../../utils/string");
const COLORS = [
    safe_1.default.red,
    safe_1.default.green,
    safe_1.default.yellow,
    safe_1.default.blue,
    safe_1.default.magenta,
    safe_1.default.cyan,
    safe_1.default.white,
    safe_1.default.gray,
    safe_1.default.grey,
];
class TextReporter {
    constructor() {
        /**
         * Maps tags to log level overrides.
         */
        this.tagToLogLevelMap = new Map();
        /**
         * The default minimum log level to display (inclusive),
         * if no specific overrides apply.
         */
        this.defaultMinimumLogLevel = consola_1.LogLevel.Info;
        /**
         * Prefix template string to prepend to all logs.
         */
        this.logPrefix = '';
        /**
         * enable colorizing log elements
         */
        this.colorEnabled = false;
    }
    /**
     * Updates the reporter's log levels for a given tag.
     *
     * `*` as a tag sets `defaultMinimumLogLevel`.
     * @param tag A tag set on a logger.
     * @param level Filter out logs less than or equal to this value.
     */
    setLogLevel(tag, level) {
        if (tag === '*') {
            this.defaultMinimumLogLevel = level;
        }
        else {
            this.tagToLogLevelMap.set(tag, level);
        }
    }
    /**
     * Determines whether to output logs based on the configured minimum log levels.
     * @param logObj a logObj instance from the consola reporter's log function
     */
    shouldLog(logObj) {
        // logs with multiple tags come with the tags joined with ':'
        const tags = logObj.tag.split(':');
        // Start with the default log level, then check tags from least specific
        // to most specific and override the log level if we have an override for that tag.
        let level = this.defaultMinimumLogLevel;
        for (const tag of tags) {
            const tagLevel = this.tagToLogLevelMap.get(tag);
            if (tagLevel !== undefined) {
                level = tagLevel;
            }
        }
        return logObj.level <= level;
    }
    /**
     * Materializes the variables on the logPrefix template string into a new string
     * @param logObj a logObj instance from the consola reporter's log function
     */
    buildLogPrefix(logObj) {
        const formattedDate = date_fns_1.format(logObj.date, 'HH:mm:ss.SSS');
        let formattedTag = logObj.tag;
        if (this.colorEnabled && formattedTag) {
            const hash = string_1.StringUtils.hashToNumber(logObj.tag);
            const index = hash % COLORS.length;
            const color = COLORS[index];
            formattedTag = color(logObj.tag);
        }
        return this.logPrefix
            .replace(/%time%/g, formattedDate)
            .replace(/%level%/g, logObj.type)
            .replace(/%tag%/g, formattedTag);
    }
    logText(_logObj, _args) {
        throw new Error('Not implemented');
    }
    log(logObj) {
        if (!this.shouldLog(logObj)) {
            return;
        }
        const args = logObj.args;
        if (this.logPrefix) {
            args.unshift(this.buildLogPrefix(logObj));
        }
        this.logText(logObj, args);
    }
}
exports.TextReporter = TextReporter;
//# sourceMappingURL=text.js.map