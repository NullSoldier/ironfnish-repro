"use strict";
/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/. */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.IsAxiosError = exports.WebApi = void 0;
const axios_1 = __importDefault(require("axios"));
const serializers_1 = require("./network/utils/serializers");
const serde_1 = require("./serde");
const utils_1 = require("./utils");
const types_1 = require("./utils/types");
/**
 *  The API should be compatible with the Ironfish API here
 *  used to host our Facuet, BlockExplorer, and other things.
 *  https://github.com/iron-fish/ironfish-api
 */
class WebApi {
    constructor(options) {
        let host = options?.host ?? 'https://api.ironfish.network';
        if (host.endsWith('/')) {
            host = host.slice(0, -1);
        }
        this.host = host;
        this.token = options?.token || '';
        this.getFundsEndpoint = options?.getFundsEndpoint || null;
    }
    async headBlocks() {
        const response = await axios_1.default
            .get(`${this.host}/blocks/head`)
            .catch((e) => {
            // The API returns 404 for no head
            if (IsAxiosError(e) && e.response?.status === 404) {
                return null;
            }
            throw e;
        });
        return response?.data.hash || null;
    }
    async blocks(blocks) {
        this.requireToken();
        const serialized = blocks.map(({ type, block }) => ({
            type: type,
            hash: block.hash,
            sequence: block.sequence,
            timestamp: block.timestamp,
            previous_block_hash: block.previous,
            difficulty: block.difficulty,
            size: block.size,
            graffiti: block.graffiti,
            main: block.main,
            transactions: block.transactions,
            work: block.work,
        }));
        const options = this.options({ 'Content-Type': 'application/json' });
        await axios_1.default.post(`${this.host}/blocks`, { blocks: serialized }, options);
    }
    async transactions(transactions) {
        this.requireToken();
        const serialized = [];
        for (const transaction of transactions) {
            serialized.push({
                hash: serde_1.BlockHashSerdeInstance.serialize(transaction.hash()),
                size: serializers_1.getTransactionSize(transaction),
                fee: Number(transaction.fee()),
                notes: transaction.notes.map((note) => ({
                    commitment: note.hash().toString('hex'),
                })),
                spends: transaction.spends.map((spend) => ({
                    nullifier: spend.nullifier.toString('hex'),
                })),
                mints: transaction.mints.map((mint) => ({
                    id: mint.asset.id().toString('hex'),
                    metadata: utils_1.BufferUtils.toHuman(mint.asset.metadata()),
                    name: utils_1.BufferUtils.toHuman(mint.asset.name()),
                    // TODO(mat) IFL-1357: Rename this when the API is updated; will need to be released together
                    owner: mint.asset.creator().toString('hex'),
                    value: mint.value.toString(),
                })),
                burns: transaction.burns.map((burn) => ({
                    id: burn.assetId.toString('hex'),
                    value: burn.value.toString(),
                })),
                expiration: transaction.expiration(),
            });
        }
        const options = this.options({ 'Content-Type': 'application/json' });
        await axios_1.default.post(`${this.host}/transactions`, { transactions: serialized }, options);
    }
    async getFunds(data) {
        const endpoint = this.getFundsEndpoint || `${this.host}/faucet_transactions`;
        const options = this.options({ 'Content-Type': 'application/json' });
        const response = await axios_1.default.post(endpoint, {
            email: data.email,
            public_key: data.public_key,
        }, options);
        return response.data;
    }
    async getNextFaucetTransactions(count) {
        this.requireToken();
        const response = await axios_1.default.get(`${this.host}/faucet_transactions/next?count=${count}`, this.options());
        return response.data.data;
    }
    async startFaucetTransaction(id) {
        this.requireToken();
        const response = await axios_1.default.post(`${this.host}/faucet_transactions/${id}/start`, undefined, this.options());
        return response.data;
    }
    async completeFaucetTransaction(id, hash) {
        this.requireToken();
        const response = await axios_1.default.post(`${this.host}/faucet_transactions/${id}/complete`, { hash }, this.options());
        return response.data;
    }
    async submitTelemetry(payload) {
        await axios_1.default.post(`${this.host}/telemetry`, payload);
    }
    options(headers = {}) {
        return {
            headers: {
                Authorization: `Bearer ${this.token}`,
                ...headers,
            },
        };
    }
    requireToken() {
        if (!this.token) {
            throw new Error(`Token required for endpoint`);
        }
    }
}
exports.WebApi = WebApi;
function IsAxiosError(e) {
    return typeof e === 'object' && e != null && types_1.HasOwnProperty(e, 'isAxiosError');
}
exports.IsAxiosError = IsAxiosError;
//# sourceMappingURL=webApi.js.map