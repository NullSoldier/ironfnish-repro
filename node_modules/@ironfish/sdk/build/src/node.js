"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.FullNode = void 0;
/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/. */
const rust_nodejs_1 = require("@ironfish/rust-nodejs");
const uuid_1 = require("uuid");
const assets_1 = require("./assets");
const blockchain_1 = require("./blockchain");
const consensus_1 = require("./consensus");
const fileStores_1 = require("./fileStores");
const logger_1 = require("./logger");
const memPool_1 = require("./memPool");
const feeEstimator_1 = require("./memPool/feeEstimator");
const metrics_1 = require("./metrics");
const migrations_1 = require("./migrations");
const mining_1 = require("./mining");
const network_1 = require("./network");
const networkDefinition_1 = require("./networkDefinition");
const platform_1 = require("./platform");
const rpc_1 = require("./rpc");
const server_1 = require("./rpc/server");
const strategy_1 = require("./strategy");
const syncer_1 = require("./syncer");
const telemetry_1 = require("./telemetry/telemetry");
const wallet_1 = require("./wallet");
const workerPool_1 = require("./workerPool");
class FullNode {
    constructor({ pkg, chain, files, config, internal, wallet, strategy, metrics, memPool, workerPool, logger, webSocket, privateIdentity, hostsStore, networkId, assetsVerifier, }) {
        this.started = false;
        this.shutdownPromise = null;
        this.shutdownResolve = null;
        this.files = files;
        this.config = config;
        this.internal = internal;
        this.wallet = wallet;
        this.chain = chain;
        this.strategy = strategy;
        this.metrics = metrics;
        this.miningManager = new mining_1.MiningManager({ chain, memPool, node: this, metrics });
        this.memPool = memPool;
        this.workerPool = workerPool;
        this.rpc = new server_1.RpcServer(this, internal);
        this.logger = logger;
        this.pkg = pkg;
        this.migrator = new migrations_1.Migrator({ node: this, logger });
        const identity = privateIdentity || new rust_nodejs_1.BoxKeyPair();
        this.telemetry = new telemetry_1.Telemetry({
            chain,
            logger,
            config,
            metrics,
            workerPool,
            localPeerIdentity: network_1.privateIdentityToIdentity(identity),
            defaultTags: [
                { name: 'version', value: pkg.version },
                { name: 'agent', value: platform_1.Platform.getAgent(pkg) },
            ],
            defaultFields: [
                { name: 'node_id', type: 'string', value: internal.get('telemetryNodeId') },
                { name: 'session_id', type: 'string', value: uuid_1.v4() },
            ],
            networkId,
        });
        this.peerNetwork = new network_1.PeerNetwork({
            networkId,
            identity: identity,
            agent: platform_1.Platform.getAgent(pkg),
            port: config.get('peerPort'),
            name: config.get('nodeName'),
            maxPeers: config.get('maxPeers'),
            minPeers: config.get('minPeers'),
            listen: config.get('enableListenP2P'),
            enableSyncing: config.get('enableSyncing'),
            targetPeers: config.get('targetPeers'),
            logPeerMessages: config.get('logPeerMessages'),
            simulateLatency: config.get('p2pSimulateLatency'),
            bootstrapNodes: config.getArray('bootstrapNodes'),
            stunServers: config.getArray('p2pStunServers'),
            webSocket: webSocket,
            node: this,
            chain: chain,
            metrics: this.metrics,
            hostsStore: hostsStore,
            logger: logger,
            telemetry: this.telemetry,
            incomingWebSocketWhitelist: config.getArray('incomingWebSocketWhitelist'),
        });
        this.miningManager.onNewBlock.on((block) => {
            this.telemetry.submitBlockMined(block);
        });
        this.peerNetwork.onTransactionAccepted.on((transaction, received) => {
            this.telemetry.submitNewTransactionSeen(transaction, received);
        });
        this.syncer = new syncer_1.Syncer({
            chain,
            metrics,
            logger,
            telemetry: this.telemetry,
            peerNetwork: this.peerNetwork,
            blocksPerMessage: config.get('blocksPerMessage'),
        });
        this.assetsVerifier = assetsVerifier;
        this.config.onConfigChange.on((key, value) => this.onConfigChange(key, value));
    }
    static async init({ pkg: pkg, dataDir, config, internal, autoSeed, logger = logger_1.createRootLogger(), metrics, files, strategyClass, webSocket, privateIdentity, }) {
        logger = logger.withTag('ironfishnode');
        dataDir = dataDir || fileStores_1.DEFAULT_DATA_DIR;
        if (!config) {
            config = new fileStores_1.Config(files, dataDir);
            await config.load();
        }
        if (!internal) {
            internal = new fileStores_1.InternalStore(files, dataDir);
            await internal.load();
        }
        const hostsStore = new fileStores_1.HostsStore(files, dataDir);
        await hostsStore.load();
        const verifiedAssetsCache = new fileStores_1.VerifiedAssetsCacheStore(files, dataDir);
        await verifiedAssetsCache.load();
        const assetsVerifier = new assets_1.AssetsVerifier({
            apiUrl: config.get('assetVerificationApi'),
            cache: verifiedAssetsCache,
            logger,
        });
        const numWorkers = workerPool_1.calculateWorkers(config.get('nodeWorkers'), config.get('nodeWorkersMax'));
        const workerPool = new workerPool_1.WorkerPool({ metrics, numWorkers });
        metrics = metrics || new metrics_1.MetricsMonitor({ logger });
        const networkDefinition = await networkDefinition_1.getNetworkDefinition(config, internal, files);
        if (!config.isSet('bootstrapNodes')) {
            config.setOverride('bootstrapNodes', networkDefinition.bootstrapNodes);
        }
        const consensus = new consensus_1.TestnetConsensus(networkDefinition.consensus);
        strategyClass = strategyClass || strategy_1.Strategy;
        const strategy = new strategyClass({ workerPool, consensus });
        const chain = new blockchain_1.Blockchain({
            location: config.chainDatabasePath,
            strategy,
            logger,
            metrics,
            autoSeed,
            workerPool,
            files,
            consensus,
            genesis: networkDefinition.genesis,
            config,
        });
        const feeEstimator = new feeEstimator_1.FeeEstimator({
            consensus,
            maxBlockHistory: config.get('feeEstimatorMaxBlockHistory'),
            percentiles: {
                slow: config.get('feeEstimatorPercentileSlow'),
                average: config.get('feeEstimatorPercentileAverage'),
                fast: config.get('feeEstimatorPercentileFast'),
            },
        });
        const memPool = new memPool_1.MemPool({
            chain,
            feeEstimator,
            metrics,
            logger,
            consensus,
            maxSizeBytes: config.get('memPoolMaxSizeBytes'),
            recentlyEvictedCacheSize: config.get('memPoolRecentlyEvictedCacheSize'),
        });
        const walletDB = new wallet_1.WalletDB({
            location: config.walletDatabasePath,
            workerPool,
            files,
        });
        const memoryClient = new rpc_1.RpcMemoryClient(logger);
        const wallet = new wallet_1.Wallet({
            config,
            database: walletDB,
            workerPool,
            consensus,
            nodeClient: memoryClient,
        });
        const node = new FullNode({
            pkg,
            chain,
            strategy,
            files,
            config,
            internal,
            wallet,
            metrics,
            memPool,
            workerPool,
            logger,
            webSocket,
            privateIdentity,
            hostsStore,
            networkId: networkDefinition.id,
            assetsVerifier,
        });
        memoryClient.router = node.rpc.getRouter(rpc_1.ALL_API_NAMESPACES);
        return node;
    }
    async openDB() {
        const migrate = this.config.get('databaseMigrate');
        const initial = await this.migrator.isInitial();
        if (migrate || initial) {
            await this.migrator.migrate({ quiet: !migrate, quietNoop: true });
        }
        try {
            await this.chain.open();
            await this.wallet.open();
        }
        catch (e) {
            await this.chain.close();
            await this.wallet.close();
            throw e;
        }
    }
    async closeDB() {
        await this.chain.close();
        await this.wallet.close();
    }
    async start() {
        this.shutdownPromise = new Promise((r) => (this.shutdownResolve = r));
        this.started = true;
        // Work in the worker pool happens concurrently,
        // so we should start it as soon as possible
        this.workerPool.start();
        if (this.config.get('enableTelemetry')) {
            this.telemetry.start();
        }
        if (this.config.get('enableMetrics')) {
            this.metrics.start();
        }
        if (this.config.get('enableWallet')) {
            await this.wallet.start();
        }
        this.peerNetwork.start();
        if (this.config.get('enableRpc')) {
            await this.rpc.start();
        }
        await this.memPool.start();
        if (this.config.get('enableAssetVerification')) {
            this.assetsVerifier.start();
        }
        this.telemetry.submitNodeStarted();
    }
    async waitForShutdown() {
        await this.shutdownPromise;
    }
    async shutdown() {
        await Promise.allSettled([
            this.wallet.stop(),
            this.syncer.stop(),
            this.peerNetwork.stop(),
            this.rpc.stop(),
            this.assetsVerifier.stop(),
            this.telemetry.stop(),
            this.metrics.stop(),
        ]);
        // Do after to avoid unhandled error from aborted jobs
        await Promise.allSettled([this.workerPool.stop()]);
        if (this.shutdownResolve) {
            this.shutdownResolve();
        }
        this.started = false;
    }
    onPeerNetworkReady() {
        if (this.config.get('enableSyncing')) {
            void this.syncer.start();
        }
    }
    onPeerNetworkNotReady() {
        void this.syncer.stop();
    }
    async onConfigChange(key, newValue) {
        switch (key) {
            case 'enableTelemetry': {
                if (newValue) {
                    this.telemetry.start();
                }
                else {
                    await this.telemetry.stop();
                }
                break;
            }
            case 'enableMetrics': {
                if (newValue) {
                    this.metrics.start();
                }
                else {
                    this.metrics.stop();
                }
                break;
            }
            case 'enableWallet': {
                if (newValue) {
                    await this.wallet.start();
                }
                else {
                    await this.wallet.stop();
                }
                break;
            }
            case 'enableRpc': {
                if (newValue) {
                    await this.rpc.start();
                }
                else {
                    await this.rpc.stop();
                }
                break;
            }
            case 'enableAssetVerification': {
                if (newValue) {
                    this.assetsVerifier.start();
                }
                else {
                    this.assetsVerifier.stop();
                }
                break;
            }
        }
    }
}
exports.FullNode = FullNode;
//# sourceMappingURL=node.js.map