"use strict";
/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/. */
Object.defineProperty(exports, "__esModule", { value: true });
exports.BlockTemplateSerde = void 0;
const block_1 = require("../primitives/block");
const blockheader_1 = require("../primitives/blockheader");
const noteEncrypted_1 = require("../primitives/noteEncrypted");
const target_1 = require("../primitives/target");
const transaction_1 = require("../primitives/transaction");
const utils_1 = require("../utils");
class BlockTemplateSerde {
    static serialize(block, previousBlock) {
        const header = {
            sequence: block.header.sequence,
            previousBlockHash: block.header.previousBlockHash.toString('hex'),
            noteCommitment: block.header.noteCommitment.toString('hex'),
            transactionCommitment: block.header.transactionCommitment.toString('hex'),
            target: utils_1.BigIntUtils.writeBigU256BE(block.header.target.asBigInt()).toString('hex'),
            randomness: utils_1.BigIntUtils.writeBigU64BE(block.header.randomness).toString('hex'),
            timestamp: block.header.timestamp.getTime(),
            graffiti: block.header.graffiti.toString('hex'),
        };
        const previousBlockInfo = {
            target: utils_1.BigIntUtils.writeBigU256BE(previousBlock.header.target.asBigInt()).toString('hex'),
            timestamp: previousBlock.header.timestamp.getTime(),
        };
        const transactions = block.transactions.map((t) => t.serialize().toString('hex'));
        return {
            header,
            transactions,
            previousBlockInfo,
        };
    }
    static deserialize(blockTemplate) {
        const noteHasher = new noteEncrypted_1.NoteEncryptedHashSerde();
        const header = new blockheader_1.BlockHeader(blockTemplate.header.sequence, Buffer.from(blockTemplate.header.previousBlockHash, 'hex'), noteHasher.deserialize(Buffer.from(blockTemplate.header.noteCommitment, 'hex')), Buffer.from(blockTemplate.header.transactionCommitment, 'hex'), new target_1.Target(Buffer.from(blockTemplate.header.target, 'hex')), utils_1.BigIntUtils.fromBytesBE(Buffer.from(blockTemplate.header.randomness, 'hex')), new Date(blockTemplate.header.timestamp), Buffer.from(blockTemplate.header.graffiti, 'hex'));
        const transactions = blockTemplate.transactions.map((t) => new transaction_1.Transaction(Buffer.from(t, 'hex')));
        return new block_1.Block(header, transactions);
    }
}
exports.BlockTemplateSerde = BlockTemplateSerde;
//# sourceMappingURL=BlockTemplateSerde.js.map