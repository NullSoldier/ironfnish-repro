"use strict";
/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/. */
Object.defineProperty(exports, "__esModule", { value: true });
exports.WalletNode = void 0;
const assert_1 = require("./assert");
const assets_1 = require("./assets");
const consensus_1 = require("./consensus");
const fileStores_1 = require("./fileStores");
const logger_1 = require("./logger");
const metrics_1 = require("./metrics");
const migrations_1 = require("./migrations");
const migration_1 = require("./migrations/migration");
const networkDefinition_1 = require("./networkDefinition");
const blockheader_1 = require("./primitives/blockheader");
const server_1 = require("./rpc/server");
const strategy_1 = require("./strategy");
const wallet_1 = require("./wallet");
const workerPool_1 = require("./workerPool");
class WalletNode {
    constructor({ pkg, files, config, internal, wallet, strategy, metrics, workerPool, logger, assetsVerifier, nodeClient, }) {
        this.started = false;
        this.shutdownPromise = null;
        this.shutdownResolve = null;
        this.onDisconnectRpc = (startWallet) => {
            this.logger.info('');
            this.logger.info('Disconnected from node unexpectedly. Reconnecting.');
            void this.wallet.stop();
            void this.startConnectingRpc(startWallet);
        };
        this.files = files;
        this.config = config;
        this.internal = internal;
        this.wallet = wallet;
        this.strategy = strategy;
        this.metrics = metrics;
        this.workerPool = workerPool;
        this.rpc = new server_1.RpcServer(this, internal);
        this.logger = logger;
        this.pkg = pkg;
        this.nodeClient = nodeClient;
        this.assetsVerifier = assetsVerifier;
        this.migrator = new migrations_1.Migrator({ node: this, logger, databases: [migration_1.Database.WALLET] });
        this.nodeClientConnectionWarned = false;
        this.nodeClientConnectionTimeout = null;
        this.config.onConfigChange.on((key, value) => this.onConfigChange(key, value));
    }
    static async init({ pkg: pkg, dataDir, config, internal, logger = logger_1.createRootLogger(), metrics, files, strategyClass, nodeClient, }) {
        logger = logger.withTag('walletnode');
        dataDir = dataDir || fileStores_1.DEFAULT_DATA_DIR;
        if (!config) {
            config = new fileStores_1.Config(files, dataDir);
            await config.load();
        }
        if (!internal) {
            internal = new fileStores_1.InternalStore(files, dataDir);
            await internal.load();
        }
        const verifiedAssetsCache = new fileStores_1.VerifiedAssetsCacheStore(files, dataDir);
        await verifiedAssetsCache.load();
        const assetsVerifier = new assets_1.AssetsVerifier({
            apiUrl: config.get('assetVerificationApi'),
            cache: verifiedAssetsCache,
            logger,
        });
        const numWorkers = workerPool_1.calculateWorkers(config.get('nodeWorkers'), config.get('nodeWorkersMax'));
        const workerPool = new workerPool_1.WorkerPool({ metrics, numWorkers });
        metrics = metrics || new metrics_1.MetricsMonitor({ logger });
        const networkDefinition = await networkDefinition_1.getNetworkDefinition(config, internal, files);
        const consensus = new consensus_1.TestnetConsensus(networkDefinition.consensus);
        strategyClass = strategyClass || strategy_1.Strategy;
        const strategy = new strategyClass({ workerPool, consensus });
        const walletDB = new wallet_1.WalletDB({
            location: config.walletDatabasePath,
            workerPool,
            files,
        });
        const wallet = new wallet_1.Wallet({
            config,
            database: walletDB,
            workerPool,
            consensus,
            nodeClient,
        });
        return new WalletNode({
            pkg,
            strategy,
            files,
            config,
            internal,
            wallet,
            metrics,
            workerPool,
            logger,
            assetsVerifier,
            nodeClient,
        });
    }
    async openDB() {
        const migrate = this.config.get('databaseMigrate');
        const initial = await this.migrator.isInitial();
        if (migrate || initial) {
            await this.migrator.migrate({
                quiet: !migrate,
                quietNoop: true,
            });
        }
        try {
            await this.wallet.open();
        }
        catch (e) {
            await this.wallet.close();
            throw e;
        }
    }
    async closeDB() {
        await this.wallet.close();
    }
    async start() {
        this.shutdownPromise = new Promise((r) => (this.shutdownResolve = r));
        this.started = true;
        // Work in the worker pool happens concurrently,
        // so we should start it as soon as possible
        this.workerPool.start();
        if (this.config.get('enableMetrics')) {
            this.metrics.start();
        }
        if (this.config.get('enableRpc')) {
            await this.rpc.start();
        }
        if (this.config.get('enableAssetVerification')) {
            this.assetsVerifier.start();
        }
        await this.connectRpc(true);
        await this.verifyGenesisBlockHash();
    }
    async verifyGenesisBlockHash() {
        const networkDefinition = await networkDefinition_1.getNetworkDefinition(this.config, this.internal, this.files);
        assert_1.Assert.isNotNull(this.nodeClient);
        const response = await this.nodeClient.chain.getChainInfo();
        const nodeGenesisHash = Buffer.from(response.content.genesisBlockIdentifier.hash, 'hex');
        const walletGenesisHeader = blockheader_1.BlockHeaderSerde.deserialize(networkDefinition.genesis.header);
        if (walletGenesisHeader.hash.equals(nodeGenesisHash)) {
            this.logger.info('Verified genesis block hash');
        }
        else {
            throw new Error(`Cannot sync from this node because the node's genesis block hash ${nodeGenesisHash.toString('hex')} does not match the wallet's genesis block hash ${walletGenesisHeader.hash.toString('hex')}`);
        }
    }
    async connectRpc(startWallet) {
        assert_1.Assert.isNotNull(this.nodeClient);
        this.nodeClient.onClose.on(() => this.onDisconnectRpc(startWallet));
        await this.startConnectingRpc(startWallet);
    }
    async startConnectingRpc(startWallet) {
        assert_1.Assert.isNotNull(this.nodeClient);
        const connected = await this.nodeClient.tryConnect();
        if (!connected) {
            if (!this.nodeClientConnectionWarned) {
                this.logger.warn(`Failed to connect to node on ${this.nodeClient.describe()}, retrying...`);
                this.logger.warn('');
                this.nodeClientConnectionWarned = true;
            }
            this.nodeClientConnectionTimeout = setTimeout(() => void this.startConnectingRpc(startWallet), 5000);
            return;
        }
        this.nodeClientConnectionWarned = false;
        this.logger.info('Successfully connected to node');
        if (startWallet) {
            await this.wallet.start();
        }
    }
    async waitForShutdown() {
        await this.shutdownPromise;
    }
    async shutdown() {
        assert_1.Assert.isNotNull(this.nodeClient);
        this.nodeClient.onClose.off(this.onDisconnectRpc);
        this.nodeClient.close();
        if (this.nodeClientConnectionTimeout) {
            clearTimeout(this.nodeClientConnectionTimeout);
        }
        await Promise.allSettled([
            this.wallet.stop(),
            this.rpc.stop(),
            this.assetsVerifier.stop(),
            this.metrics.stop(),
        ]);
        // Do after to avoid unhandled error from aborted jobs
        await Promise.allSettled([this.workerPool.stop()]);
        if (this.shutdownResolve) {
            this.shutdownResolve();
        }
        this.started = false;
    }
    async onConfigChange(key, newValue) {
        switch (key) {
            case 'enableMetrics': {
                if (newValue) {
                    this.metrics.start();
                }
                else {
                    this.metrics.stop();
                }
                break;
            }
            case 'enableRpc': {
                if (newValue) {
                    await this.rpc.start();
                }
                else {
                    await this.rpc.stop();
                }
                break;
            }
            case 'enableAssetVerification': {
                if (newValue) {
                    this.assetsVerifier.start();
                }
                else {
                    this.assetsVerifier.stop();
                }
                break;
            }
        }
    }
}
exports.WalletNode = WalletNode;
//# sourceMappingURL=walletNode.js.map