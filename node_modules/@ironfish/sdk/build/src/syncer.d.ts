/// <reference types="node" />
import { Blockchain } from './blockchain';
import { VerificationResultReason } from './consensus';
import { Logger } from './logger';
import { Meter, MetricsMonitor } from './metrics';
import { RollingAverage } from './metrics/rollingAverage';
import { Peer, PeerNetwork } from './network';
import { PeerState } from './network/peers/peer';
import { Block } from './primitives/block';
import { Telemetry } from './telemetry';
import { SetTimeoutToken } from './utils';
export declare class Syncer {
    readonly peerNetwork: PeerNetwork;
    readonly chain: Blockchain;
    readonly metrics: MetricsMonitor;
    readonly telemetry: Telemetry;
    readonly logger: Logger;
    readonly speed: Meter;
    readonly downloadSpeed: RollingAverage;
    state: 'stopped' | 'idle' | 'stopping' | 'syncing';
    stopping: Promise<void> | null;
    eventLoopTimeout: SetTimeoutToken | null;
    loader: Peer | null;
    blocksPerMessage: number;
    constructor(options: {
        peerNetwork: PeerNetwork;
        chain: Blockchain;
        telemetry: Telemetry;
        metrics?: MetricsMonitor;
        logger?: Logger;
        blocksPerMessage?: number;
    });
    start(): Promise<void>;
    stop(): Promise<void>;
    eventLoop(): void;
    findPeer(): void;
    startSync(peer: Peer): void;
    stopSync(peer: Peer): void;
    wait(): Promise<void>;
    syncFrom(peer: Peer): Promise<void>;
    /**
     * Find the sequence of the ancestor block between you and peer
     */
    findAncestor(peer: Peer): Promise<{
        sequence: number;
        ancestor: Buffer;
        requests: number;
    }>;
    private getBlocks;
    syncBlocks(peer: Peer, head: Buffer, sequence: number): Promise<void>;
    addBlock(peer: Peer, block: Block): Promise<{
        added: boolean;
        block: Block;
        reason: VerificationResultReason | null;
    }>;
    /**
     * Throws AbortSyncingError which safely stops the syncing
     * with a peer if we should no longer sync from this peer
     */
    protected abort(peer: Peer): void;
    /**
     * When the peer disconnects we use this to stop syncing from them
     */
    protected onPeerStateChanged: ({ peer, state }: {
        peer: Peer;
        state: PeerState;
    }) => void;
}
//# sourceMappingURL=syncer.d.ts.map