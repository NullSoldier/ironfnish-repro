"use strict";
/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/. */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.RawTransactionSerde = exports.RawTransaction = void 0;
const rust_nodejs_1 = require("@ironfish/rust-nodejs");
const rust_nodejs_2 = require("@ironfish/rust-nodejs");
const bufio_1 = __importDefault(require("bufio"));
const merkletree_1 = require("../merkletree");
const hasher_1 = require("../merkletree/hasher");
const merkletree_2 = require("../merkletree/merkletree");
const currency_1 = require("../utils/currency");
const assetBalances_1 = require("../wallet/assetBalances");
const note_1 = require("./note");
const noteEncrypted_1 = require("./noteEncrypted");
const spend_1 = require("./spend");
const transaction_1 = require("./transaction");
// Needed for constructing a witness when creating transactions
const noteHasher = new hasher_1.NoteHasher();
const MAX_MINT_OR_BURN_VALUE = BigInt(100000000000000000n);
class RawTransaction {
    constructor() {
        this.version = rust_nodejs_1.TRANSACTION_VERSION;
        this.expiration = null;
        this.fee = 0n;
        this.mints = [];
        this.burns = [];
        this.outputs = [];
        this.spends = [];
    }
    postedSize(publicAddress) {
        let size = 0;
        size += 1; // version
        size += 8; // spends length
        size += 8; // notes length
        size += 8; // mints length
        size += 8; // burns length
        size += rust_nodejs_1.TRANSACTION_FEE_LENGTH; // fee
        size += rust_nodejs_1.TRANSACTION_EXPIRATION_LENGTH; // expiration
        size += rust_nodejs_1.TRANSACTION_PUBLIC_KEY_RANDOMNESS_LENGTH; // public key randomness
        size += this.spends.length * spend_1.SPEND_SERIALIZED_SIZE_IN_BYTE;
        size += this.outputs.length * (rust_nodejs_1.PROOF_LENGTH + noteEncrypted_1.NoteEncrypted.size);
        size += this.mints
            .map((mint) => {
            let mintSize = rust_nodejs_1.PROOF_LENGTH + rust_nodejs_1.ASSET_LENGTH + rust_nodejs_1.AMOUNT_VALUE_LENGTH + rust_nodejs_1.TRANSACTION_SIGNATURE_LENGTH;
            if (transaction_1.TransactionFeatures.hasMintTransferOwnershipTo(this.version)) {
                mintSize += rust_nodejs_1.PUBLIC_ADDRESS_LENGTH; // owner
                // transferOwnershipTo
                mintSize += 1;
                if (mint.transferOwnershipTo) {
                    mintSize += rust_nodejs_1.PUBLIC_ADDRESS_LENGTH;
                }
            }
            return mintSize;
        })
            .reduce((size, mintSize) => size + mintSize, 0);
        size += this.burns.length * (rust_nodejs_2.ASSET_ID_LENGTH + 8);
        size += rust_nodejs_1.TRANSACTION_SIGNATURE_LENGTH; // signature
        // Each asset might have a change note, which would need to be accounted for
        const assetTotals = new assetBalances_1.AssetBalances();
        for (const mint of this.mints) {
            const asset = new rust_nodejs_2.Asset(publicAddress, mint.name, mint.metadata);
            assetTotals.increment(asset.id(), mint.value);
        }
        for (const burn of this.burns) {
            assetTotals.increment(burn.assetId, -burn.value);
        }
        for (const spend of this.spends) {
            assetTotals.increment(spend.note.assetId(), -spend.note.value());
        }
        for (const output of this.outputs) {
            assetTotals.increment(output.note.assetId(), output.note.value());
        }
        assetTotals.increment(rust_nodejs_2.Asset.nativeId(), this.fee);
        for (const [, value] of assetTotals) {
            if (value !== 0n) {
                size += rust_nodejs_1.PROOF_LENGTH + noteEncrypted_1.NoteEncrypted.size;
            }
        }
        return size;
    }
    post(spendingKey) {
        const builder = new rust_nodejs_1.Transaction(spendingKey, this.version);
        for (const spend of this.spends) {
            builder.spend(spend.note.takeReference(), spend.witness);
            spend.note.returnReference();
        }
        for (const output of this.outputs) {
            builder.output(output.note.takeReference());
            output.note.returnReference();
        }
        for (const mint of this.mints) {
            if (mint.value > MAX_MINT_OR_BURN_VALUE) {
                throw new Error(`Cannot post transaction. Mint value ${currency_1.CurrencyUtils.renderIron(mint.value)} exceededs maximum ${currency_1.CurrencyUtils.renderIron(MAX_MINT_OR_BURN_VALUE)}. `);
            }
            const key = rust_nodejs_1.generateKeyFromPrivateKey(spendingKey);
            const asset = new rust_nodejs_2.Asset(key.publicAddress, mint.name, mint.metadata);
            builder.mint(asset, mint.value, mint.transferOwnershipTo);
        }
        for (const burn of this.burns) {
            if (burn.value > MAX_MINT_OR_BURN_VALUE) {
                throw new Error(`Cannot post transaction. Burn value ${currency_1.CurrencyUtils.renderIron(burn.value)} exceededs maximum ${currency_1.CurrencyUtils.renderIron(MAX_MINT_OR_BURN_VALUE)}`);
            }
            builder.burn(burn.assetId, burn.value);
        }
        if (this.expiration !== null) {
            builder.setExpiration(this.expiration);
        }
        const serialized = builder.post(null, this.fee);
        const posted = new transaction_1.Transaction(serialized);
        return posted;
    }
}
exports.RawTransaction = RawTransaction;
class RawTransactionSerde {
    static serialize(raw) {
        const bw = bufio_1.default.write(this.getSize(raw));
        bw.writeBigU64(raw.fee);
        bw.writeU64(raw.spends.length);
        for (const spend of raw.spends) {
            bw.writeVarBytes(spend.note.serialize());
            bw.writeU64(spend.witness.treeSize());
            bw.writeVarBytes(spend.witness.rootHash);
            bw.writeU64(spend.witness.authPath().length);
            for (const step of spend.witness.authPath()) {
                switch (step.side()) {
                    case merkletree_2.Side.Left:
                        bw.writeU8(0);
                        break;
                    case merkletree_2.Side.Right:
                        bw.writeU8(1);
                        break;
                }
                bw.writeVarBytes(step.hashOfSibling());
            }
        }
        bw.writeU64(raw.outputs.length);
        for (const output of raw.outputs) {
            bw.writeVarBytes(output.note.serialize());
        }
        bw.writeU64(raw.mints.length);
        for (const mint of raw.mints) {
            bw.writeVarString(mint.name, 'utf8');
            bw.writeVarString(mint.metadata, 'utf8');
            bw.writeBigU64(mint.value);
        }
        bw.writeU64(raw.burns.length);
        for (const burn of raw.burns) {
            bw.writeBytes(burn.assetId);
            bw.writeBigU64(burn.value);
        }
        bw.writeU8(Number(raw.expiration != null));
        if (raw.expiration != null) {
            bw.writeU32(raw.expiration);
        }
        return bw.render();
    }
    static deserialize(buffer) {
        const reader = bufio_1.default.read(buffer, true);
        const raw = new RawTransaction();
        raw.fee = reader.readBigU64();
        const spendsLength = reader.readU64();
        for (let i = 0; i < spendsLength; i++) {
            const note = new note_1.Note(reader.readVarBytes());
            const treeSize = reader.readU64();
            const rootHash = reader.readVarBytes();
            const authPathLength = reader.readU64();
            const authPath = [];
            for (let j = 0; j < authPathLength; j++) {
                const side = reader.readU8() ? merkletree_2.Side.Right : merkletree_2.Side.Left;
                const hashOfSibling = reader.readVarBytes();
                authPath.push({ side, hashOfSibling });
            }
            const witness = new merkletree_1.Witness(treeSize, rootHash, authPath, noteHasher);
            raw.spends.push({ note, witness });
        }
        const outputsLength = reader.readU64();
        for (let i = 0; i < outputsLength; i++) {
            const note = new note_1.Note(reader.readVarBytes());
            raw.outputs.push({ note });
        }
        const mintsLength = reader.readU64();
        for (let i = 0; i < mintsLength; i++) {
            const name = reader.readVarString('utf8');
            const metadata = reader.readVarString('utf8');
            const value = reader.readBigU64();
            raw.mints.push({ name, metadata, value });
        }
        const burnsLength = reader.readU64();
        for (let i = 0; i < burnsLength; i++) {
            const assetId = reader.readBytes(rust_nodejs_2.ASSET_ID_LENGTH);
            const value = reader.readBigU64();
            raw.burns.push({ assetId, value });
        }
        const hasExpiration = reader.readU8();
        if (hasExpiration) {
            raw.expiration = reader.readU32();
        }
        return raw;
    }
    static getSize(raw) {
        let size = 0;
        size += rust_nodejs_1.TRANSACTION_FEE_LENGTH; // raw.fee
        size += 8; // raw.spends.length
        for (const spend of raw.spends) {
            size += bufio_1.default.sizeVarBytes(spend.note.serialize());
            size += 8; // spend.witness.treeSize()
            size += bufio_1.default.sizeVarBytes(spend.witness.rootHash);
            size += 8; // spend.witness.authPath.length
            for (const step of spend.witness.authPath()) {
                size += 1; // step.side()
                size += bufio_1.default.sizeVarBytes(step.hashOfSibling());
            }
        }
        size += 8; // raw.outputs.length
        for (const output of raw.outputs) {
            size += bufio_1.default.sizeVarBytes(output.note.serialize());
        }
        size += 8; // raw.mints.length
        for (const mint of raw.mints) {
            size += bufio_1.default.sizeVarString(mint.name, 'utf8');
            size += bufio_1.default.sizeVarString(mint.metadata, 'utf8');
            size += rust_nodejs_1.AMOUNT_VALUE_LENGTH; // mint.value
        }
        size += 8; // raw.burns.length
        for (const _ of raw.burns) {
            size += rust_nodejs_2.ASSET_ID_LENGTH; // burn.assetId
            size += rust_nodejs_1.AMOUNT_VALUE_LENGTH; // burn.value
        }
        size += 1; // has expiration sequence
        if (raw.expiration != null) {
            size += rust_nodejs_1.TRANSACTION_EXPIRATION_LENGTH; // raw.expiration
        }
        return size;
    }
}
exports.RawTransactionSerde = RawTransactionSerde;
//# sourceMappingURL=rawTransaction.js.map