/// <reference types="node" />
import { TransactionPosted } from '@ironfish/rust-nodejs';
import { BurnDescription } from './burnDescription';
import { MintDescription } from './mintDescription';
import { NoteEncrypted } from './noteEncrypted';
import { Spend } from './spend';
export declare type TransactionHash = Buffer;
export declare type SerializedTransaction = Buffer;
export declare enum TransactionVersion {
    V1 = 1,
    V2 = 2
}
export declare class TransactionFeatures {
    static hasMintTransferOwnershipTo(version: TransactionVersion): boolean;
}
export declare class UnsupportedVersionError extends Error {
    readonly version: number;
    constructor(version: number);
}
export declare class Transaction {
    private readonly transactionPostedSerialized;
    readonly notes: NoteEncrypted[];
    readonly spends: Spend[];
    readonly mints: MintDescription[];
    readonly burns: BurnDescription[];
    private readonly _version;
    private readonly _fee;
    private readonly _expiration;
    private readonly _signature;
    private _hash?;
    private _unsignedHash?;
    private transactionPosted;
    private referenceCount;
    constructor(transactionPostedSerialized: Buffer);
    serialize(): Buffer;
    /**
     * The transaction serialization version. This can be incremented when
     * changes need to be made to the transaction format
     */
    version(): TransactionVersion;
    /**
     * Preallocate any resources necessary for using the transaction.
     */
    takeReference(): TransactionPosted;
    /**
     * Return any resources necessary for using the transaction.
     */
    returnReference(): void;
    /**
     * Wraps the given callback in takeReference and returnReference.
     */
    withReference<R>(callback: (transaction: TransactionPosted) => R): R;
    isMinersFee(): boolean;
    getNote(index: number): NoteEncrypted;
    getSpend(index: number): Spend;
    /**
     * Get the transaction fee for this transactions.
     *
     * In general, each transaction has outputs lower than the amount spent; the
     * miner can collect the difference as a transaction fee.
     *
     * In a block header's minersFee transaction, the opposite happens;
     * the miner creates a block with zero spends and output equal to the sum
     * of the miner's fee for the block's transaction, plus the block chain's
     * mining reward.
     *
     * The transaction fee is the difference between outputs and spends on the
     * transaction.
     */
    fee(): bigint;
    /**
     * Get transaction signature for this transaction.
     */
    transactionSignature(): Buffer;
    /**
     * Get the transaction hash that does not include the signature. This is the hash that
     * is signed when the transaction is created
     */
    unsignedHash(): TransactionHash;
    /**
     * Generate the hash of a transaction that includes the witness (signature) data.
     * Used for cases where a signature needs to be committed to in the hash like P2P transaction gossip
     */
    hash(): TransactionHash;
    equals(other: Transaction): boolean;
    /**
     * @returns The expiration as block sequence of the transaction.
     * The transaction cannot be added to a block of equal or greater sequence
     */
    expiration(): number;
}
//# sourceMappingURL=transaction.d.ts.map