/// <reference types="node" />
export declare class Target {
    targetValue: bigint;
    constructor(targetValue: bigint | Buffer | string | number);
    /**
     * Maximum target (in terms of difficulty), which is equivalent of
     * minimum difficulty of 131072
     * maximum target == minimum difficulty
     * target == 2**256 / difficulty
     */
    static maxTarget(): Target;
    static minTarget(): Target;
    /**
     * Calculate the target for the current block given the timestamp in that
     * block's header, the previous block's timestamp and previous block's target.
     *
     * To verify whether a target on a block is correct, pass in the timestamp in its header,
     * its previous block's timestamp, and its previous block's target
     * and compare the resulting target to what is specified on the current block header
     *
     * @param time the block's timestamp for which the target is calculated for
     * @param previousBlockTimestamp the block's previous block header's timestamp
     * @param previousBlockTarget the block's previous block header's target
     */
    static calculateTarget(time: Date, previousBlockTimestamp: Date, previousBlockTarget: Target, targetBlockTimeInSeconds: number, targetBucketTimeInSeconds: number): Target;
    /**
     * Calculate the difficulty for the current block given the timestamp in that
     * block's header, the previous block's timestamp and previous block's target.
     *
     * Note that difficulty == 2**256 / target and target == 2**256 / difficulty
     *
     * Algorithm: difficulty = parentDifficulty - (parentDifficulty / 2048) * bucket
     * Where bucket is how many steps (in TARGET_BUCKET_TIME_IN_SECONDS) the new time is away from
     * our target bucket range, e.g. for target block time of 60 seconds (with +/-5 seconds forgiveness):
     * 35 - 45 seconds: bucket -2
     * 45 - 55 seconds: bucket -1
     * 55 - 65 seconds: bucket 0
     * 65 - 75 seconds: bucket 1
     * 75 - 85 seconds: bucket 2
     * .. and so on
     *
     * Returns the difficulty for a block given it timestamp for that block and its parent.
     * @param time the block's timestamp for which the target is calculated for
     * @param previousBlockTimestamp the block's previous block header's timestamp
     * @param previousBlockTarget the block's previous block header's target
     */
    static calculateDifficulty(time: Date, previousBlockTimestamp: Date, previousBlockDifficulty: bigint, targetBlockTimeInSeconds: number, targetBucketTimeInSeconds: number): bigint;
    /**
     * Returns the minimum difficulty that can be used for Iron Fish blocks
     * To be used in calculateTarget for easier mocking
     */
    static minDifficulty(): bigint;
    /**
     * Converts difficulty to Target
     */
    static fromDifficulty(difficulty: bigint): Target;
    /**
     * Return the difficulty representation as a big integer
     */
    toDifficulty(): bigint;
    /**
     * Add the given amount to the target's value. A negative amount makes the target
     * harder to achieve, a positive one makes it easier.
     *
     * If adjustment would make target negative or higher than max allowed value,
     * the current target is returned unchanged.
     */
    adjust(amount: bigint): Target;
    /**
     * Return whether or not this target meets the requirements of the given target,
     * which is to say, this has a lower numeric value then the provided one.
     */
    static meets(hashValue: BigInt, target: Target): boolean;
    /**
     * Return the target number as a big integer
     */
    asBigInt(): bigint;
    equals(other: Target): boolean;
}
//# sourceMappingURL=target.d.ts.map