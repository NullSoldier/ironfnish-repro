/// <reference types="node" />
import { NoteEncryptedHash, SerializedNoteEncryptedHash } from './noteEncrypted';
import { Target } from './target';
import { Transaction } from './transaction';
export declare type BlockHash = Buffer;
export declare function hashBlockHeader(serializedHeader: Buffer): BlockHash;
export declare function isBlockLater(a: BlockHeader, b: BlockHeader): boolean;
export declare function isBlockHeavier(a: BlockHeader, b: BlockHeader): boolean;
export declare const TRANSACTION_ROOT_PERSONALIZATION: Buffer;
export declare const NULL_NODE: Buffer;
/**
 * Calculate a commitment to a list of transactions in a block by adding
 * the transaction hashes (including witness data) to a merkle tree and returning the merkle root
 * @param transactions transaction in the block
 * @returns 32-byte commitment to the list of transactions
 */
export declare function transactionCommitment(transactions: Transaction[]): Buffer;
export declare function transactionMerkleRoot(hashes: Buffer[]): Buffer;
export declare class BlockHeader {
    /**
     * The sequence number of the block. Blocks in a chain increase in ascending
     * order of sequence. More than one block may have the same sequence,
     * indicating a fork in the chain, but only one fork is selected at a time.
     */
    sequence: number;
    /**
     * The hash of the previous block in the chain
     */
    previousBlockHash: BlockHash;
    /**
     * Commitment (hash) to the note tree after all new notes from transactions in this
     * block have been added to it.
     */
    noteCommitment: NoteEncryptedHash;
    /**
     * Commitment to the set of transactions in this block. Generated by a merkle
     * tree of transaction hashes which include transaction data + witness/signature data.
     */
    transactionCommitment: Buffer;
    /**
     * The hash of the block must be lower than this target value in order for
     * the blocks to be accepted on the chain. Essentially a numerical comparison
     * of a very big integer.
     */
    target: Target;
    /**
     * A value added to the block to try to make it hash to something that is below
     * the target number.
     */
    randomness: bigint;
    /**
     * Unix timestamp according to the miner who mined the block. This value
     * must be taken with a grain of salt, but miners must verify that it is an
     * appropriate distance to the previous blocks timestamp.
     *
     * TODO: this is called timestamp but it's not a timestamp, it's a date.
     * Fix this to be a timestamp or rename it
     */
    timestamp: Date;
    /**
     * A 32 byte field that may be assigned at will by the miner who mined the block.
     */
    graffiti: Buffer;
    /**
     * (For internal uses - excluded when sent over the network)
     * The size of the notes tree after adding transactions from this block.
     */
    noteSize: number | null;
    /**
     * (For internal uses â€” excluded when sent over the network)
     * Cumulative work from genesis to this block
     */
    work: bigint;
    hash: Buffer;
    constructor(sequence: number, previousBlockHash: BlockHash, noteCommitment: NoteEncryptedHash, transactionCommitment: Buffer, target: Target, randomness: bigint | undefined, timestamp: Date | undefined, graffiti: Buffer, noteSize?: number | null, work?: bigint, hash?: Buffer);
    /**
     * Construct a partial block header without the randomness and convert
     * it to buffer.
     *
     * This is used for calculating the hash in miners and for verifying it.
     */
    serializePartial(): Buffer;
    /**
     * Hash all the values in the block header to get a commitment to the entire
     * header and the global trees it models.
     */
    recomputeHash(): BlockHash;
    /**
     * Check whether the hash of this block is less than the target stored
     * within the block header. This is the primary proof of work function.
     *
     * Hashes cannot be predicted, and the only way to find one that is lower
     * than the target that is inside it is to tweak the randomness number
     * repeatedly.
     */
    verifyTarget(): boolean;
    equals(other: BlockHeader): boolean;
}
export declare type SerializedBlockHeader = {
    sequence: number;
    previousBlockHash: string;
    noteCommitment: SerializedNoteEncryptedHash;
    transactionCommitment: Buffer;
    target: string;
    randomness: string;
    timestamp: number;
    noteSize: number | null;
    work?: string;
    graffiti: string;
};
export declare class BlockHeaderSerde {
    static serialize(header: BlockHeader): SerializedBlockHeader;
    static deserialize(data: SerializedBlockHeader): BlockHeader;
}
//# sourceMappingURL=blockheader.d.ts.map