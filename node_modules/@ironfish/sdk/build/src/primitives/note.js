"use strict";
/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/. */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Note = void 0;
const rust_nodejs_1 = require("@ironfish/rust-nodejs");
const bufio_1 = __importDefault(require("bufio"));
const buffer_1 = require("../utils/buffer");
class Note {
    constructor(noteSerialized) {
        this.note = null;
        this.referenceCount = 0;
        this.noteSerialized = noteSerialized;
        const reader = bufio_1.default.read(this.noteSerialized, true);
        this._owner = reader.readBytes(rust_nodejs_1.PUBLIC_ADDRESS_LENGTH, true).toString('hex');
        this._assetId = reader.readBytes(rust_nodejs_1.ASSET_ID_LENGTH, true);
        this._value = reader.readBigU64();
        // skip randomness
        reader.seek(rust_nodejs_1.RANDOMNESS_LENGTH);
        this._memo = reader.readBytes(rust_nodejs_1.MEMO_LENGTH, true);
        this._sender = reader.readBytes(rust_nodejs_1.PUBLIC_ADDRESS_LENGTH, true).toString('hex');
    }
    serialize() {
        return this.noteSerialized;
    }
    takeReference() {
        this.referenceCount++;
        if (this.note === null) {
            this.note = rust_nodejs_1.Note.deserialize(this.noteSerialized);
        }
        return this.note;
    }
    returnReference() {
        this.referenceCount--;
        if (this.referenceCount <= 0) {
            this.referenceCount = 0;
            this.note = null;
        }
    }
    hash() {
        const hash = this.takeReference().hash();
        this.returnReference();
        return hash;
    }
    value() {
        return this._value;
    }
    owner() {
        return this._owner;
    }
    sender() {
        return this._sender;
    }
    memo() {
        return buffer_1.BufferUtils.toHuman(this._memo);
    }
    assetId() {
        return this._assetId;
    }
    nullifier(ownerViewKey, position) {
        const buf = this.takeReference().nullifier(ownerViewKey, position);
        this.returnReference();
        return buf;
    }
    equals(other) {
        return this.noteSerialized.equals(other.noteSerialized);
    }
}
exports.Note = Note;
Note.size = rust_nodejs_1.PUBLIC_ADDRESS_LENGTH +
    rust_nodejs_1.ASSET_ID_LENGTH +
    8 + // VALUE
    rust_nodejs_1.RANDOMNESS_LENGTH +
    rust_nodejs_1.MEMO_LENGTH +
    rust_nodejs_1.PUBLIC_ADDRESS_LENGTH;
//# sourceMappingURL=note.js.map