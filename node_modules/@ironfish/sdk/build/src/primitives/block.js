"use strict";
/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/. */
Object.defineProperty(exports, "__esModule", { value: true });
exports.BlockSerde = exports.Block = exports.GRAFFITI_SIZE = exports.GENESIS_BLOCK_SEQUENCE = exports.GENESIS_BLOCK_PREVIOUS = void 0;
const lodash_1 = require("lodash");
const assert_1 = require("../assert");
const blockheader_1 = require("./blockheader");
const transaction_1 = require("./transaction");
/**
 * The hash used in the "previousHash" field on the initial block in the
 * chain. The initial block is intentionally invalid, so we need to special
 * case it.
 */
exports.GENESIS_BLOCK_PREVIOUS = Buffer.alloc(32);
exports.GENESIS_BLOCK_SEQUENCE = 1;
exports.GRAFFITI_SIZE = 32;
/**
 * Represent a single block in the chain. Essentially just a block header
 * and the list of transactions that were added to the tree between the
 * previous block and the ones committed to in this header.
 */
class Block {
    constructor(header, transactions) {
        this.header = header;
        this.transactions = transactions;
    }
    /**
     * Get the number of notes and nullifiers stored on this block.
     */
    counts() {
        let notes = 0;
        let nullifiers = 0;
        for (const transaction of this.transactions) {
            notes += transaction.notes.length;
            nullifiers += transaction.spends.length;
        }
        return { notes, nullifiers };
    }
    /**
     * Get a list of all spends on transactions in this block.
     *
     * Note: there is no spend on a miner's fee transaction in the header
     */
    *spends() {
        for (const transaction of this.transactions) {
            for (const spend of transaction.spends) {
                yield spend;
            }
        }
    }
    /**
     * Get a list of all notes created in this block including the miner's fee
     * note on the header.
     */
    *notes() {
        for (const transaction of this.transactions) {
            for (const note of transaction.notes) {
                yield note;
            }
        }
    }
    /**
     * Get a list of all mints on transactions in this block.
     */
    *mints() {
        for (const transaction of this.transactions) {
            for (const mint of transaction.mints) {
                yield mint;
            }
        }
    }
    equals(block) {
        if (block === this) {
            return true;
        }
        if (!this.header.equals(block.header)) {
            return false;
        }
        if (this.transactions.length !== block.transactions.length) {
            return false;
        }
        for (const [transaction1, transaction2] of lodash_1.zip(this.transactions, block.transactions)) {
            if (!transaction1 || !transaction2 || !transaction1.equals(transaction2)) {
                return false;
            }
        }
        return true;
    }
    get minersFee() {
        const tx = this.transactions[0];
        assert_1.Assert.isNotUndefined(tx, 'Block has no miners fee');
        return tx;
    }
    toCompactBlock() {
        const header = this.header;
        const [minersFee, ...transactions] = this.transactions;
        const transactionHashes = transactions.map((t) => t.hash());
        return {
            header,
            transactionHashes,
            transactions: [
                {
                    index: 0,
                    transaction: minersFee,
                },
            ],
        };
    }
}
exports.Block = Block;
class BlockSerde {
    static serialize(block) {
        return {
            header: blockheader_1.BlockHeaderSerde.serialize(block.header),
            transactions: block.transactions.map((t) => t.serialize()),
        };
    }
    static deserialize(data) {
        if (typeof data === 'object' &&
            data !== null &&
            'header' in data &&
            'transactions' in data &&
            Array.isArray(data.transactions)) {
            const header = blockheader_1.BlockHeaderSerde.deserialize(data.header);
            const transactions = data.transactions.map((t) => new transaction_1.Transaction(t));
            return new Block(header, transactions);
        }
        throw new Error('Unable to deserialize');
    }
}
exports.BlockSerde = BlockSerde;
//# sourceMappingURL=block.js.map