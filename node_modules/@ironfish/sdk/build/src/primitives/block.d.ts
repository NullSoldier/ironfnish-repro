/// <reference types="node" />
import { BlockHeader, SerializedBlockHeader } from './blockheader';
import { MintDescription } from './mintDescription';
import { NoteEncrypted, NoteEncryptedHash } from './noteEncrypted';
import { Nullifier } from './nullifier';
import { SerializedTransaction, Transaction } from './transaction';
/**
 * The hash used in the "previousHash" field on the initial block in the
 * chain. The initial block is intentionally invalid, so we need to special
 * case it.
 */
export declare const GENESIS_BLOCK_PREVIOUS: Buffer;
export declare const GENESIS_BLOCK_SEQUENCE = 1;
export declare const GRAFFITI_SIZE = 32;
/**
 * Represent a single block in the chain. Essentially just a block header
 * and the list of transactions that were added to the tree between the
 * previous block and the ones committed to in this header.
 */
export declare class Block {
    header: BlockHeader;
    transactions: Transaction[];
    constructor(header: BlockHeader, transactions: Transaction[]);
    /**
     * Get the number of notes and nullifiers stored on this block.
     */
    counts(): SerializedCounts;
    /**
     * Get a list of all spends on transactions in this block.
     *
     * Note: there is no spend on a miner's fee transaction in the header
     */
    spends(): Generator<{
        nullifier: Nullifier;
        commitment: NoteEncryptedHash;
        size: number;
    }>;
    /**
     * Get a list of all notes created in this block including the miner's fee
     * note on the header.
     */
    notes(): Generator<NoteEncrypted>;
    /**
     * Get a list of all mints on transactions in this block.
     */
    mints(): Generator<MintDescription>;
    equals(block: Block): boolean;
    get minersFee(): Transaction;
    toCompactBlock(): CompactBlock;
}
export declare type CompactBlockTransaction = {
    index: number;
    transaction: Transaction;
};
export declare type CompactBlock = {
    header: BlockHeader;
    transactionHashes: Buffer[];
    transactions: CompactBlockTransaction[];
};
export declare type SerializedBlock = {
    header: SerializedBlockHeader;
    transactions: SerializedTransaction[];
};
export declare type SerializedCounts = {
    notes: number;
    nullifiers: number;
};
export declare class BlockSerde {
    static serialize(block: Block): SerializedBlock;
    static deserialize(data: SerializedBlock): Block;
}
//# sourceMappingURL=block.d.ts.map