"use strict";
/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/. */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.NoteEncryptedHashSerde = exports.NoteEncryptedSerde = exports.NoteEncrypted = void 0;
const rust_nodejs_1 = require("@ironfish/rust-nodejs");
const bufio_1 = __importDefault(require("bufio"));
const note_1 = require("./note");
class NoteEncrypted {
    constructor(noteEncryptedSerialized) {
        this.noteEncrypted = null;
        this.referenceCount = 0;
        this.noteEncryptedSerialized = noteEncryptedSerialized;
        const reader = bufio_1.default.read(noteEncryptedSerialized, true);
        // value commitment
        reader.seek(32);
        // note commitment
        this._noteCommitment = reader.readBytes(32);
        // ephemeral public key
        reader.seek(32);
        // encrypted note
        reader.seek(rust_nodejs_1.ENCRYPTED_NOTE_PLAINTEXT_LENGTH);
        // note encryption keys
        reader.seek(rust_nodejs_1.NOTE_ENCRYPTION_KEY_LENGTH);
    }
    serialize() {
        return this.noteEncryptedSerialized;
    }
    takeReference() {
        this.referenceCount++;
        if (this.noteEncrypted === null) {
            this.noteEncrypted = new rust_nodejs_1.NoteEncrypted(this.noteEncryptedSerialized);
        }
        return this.noteEncrypted;
    }
    returnReference() {
        this.referenceCount--;
        if (this.referenceCount <= 0) {
            this.referenceCount = 0;
            this.noteEncrypted = null;
        }
    }
    decryptNoteForOwner(ownerHexKey) {
        const note = this.takeReference().decryptNoteForOwner(ownerHexKey);
        this.returnReference();
        if (note) {
            return new note_1.Note(note);
        }
    }
    decryptNoteForSpender(spenderHexKey) {
        const note = this.takeReference().decryptNoteForSpender(spenderHexKey);
        this.returnReference();
        if (note) {
            return new note_1.Note(note);
        }
    }
    hash() {
        return this._noteCommitment;
    }
    equals(other) {
        return this.serialize().equals(other.serialize());
    }
}
exports.NoteEncrypted = NoteEncrypted;
NoteEncrypted.size = 32 + // value commitment
    32 + // note commitment
    32 + // ephemeral public key
    rust_nodejs_1.ENCRYPTED_NOTE_PLAINTEXT_LENGTH +
    rust_nodejs_1.NOTE_ENCRYPTION_KEY_LENGTH;
/**
 * Serde implementation to convert an encrypted note to its serialized form and back.
 */
class NoteEncryptedSerde {
    equals(note1, note2) {
        return note1.equals(note2);
    }
    serialize(note) {
        return note.serialize();
    }
    deserialize(serializedNote) {
        return new NoteEncrypted(serializedNote);
    }
}
exports.NoteEncryptedSerde = NoteEncryptedSerde;
/**
 * Serde implementation to convert an encrypted note's hash to its serialized form and back.
 */
class NoteEncryptedHashSerde {
    equals(hash1, hash2) {
        return hash1.equals(hash2);
    }
    serialize(note) {
        return note;
    }
    deserialize(serializedNote) {
        return serializedNote;
    }
}
exports.NoteEncryptedHashSerde = NoteEncryptedHashSerde;
//# sourceMappingURL=noteEncrypted.js.map