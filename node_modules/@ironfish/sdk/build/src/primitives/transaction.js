"use strict";
/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/. */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Transaction = exports.UnsupportedVersionError = exports.TransactionFeatures = exports.TransactionVersion = void 0;
const rust_nodejs_1 = require("@ironfish/rust-nodejs");
const blake_hash_1 = require("@napi-rs/blake-hash");
const bufio_1 = __importDefault(require("bufio"));
const noteEncrypted_1 = require("./noteEncrypted");
var TransactionVersion;
(function (TransactionVersion) {
    TransactionVersion[TransactionVersion["V1"] = 1] = "V1";
    TransactionVersion[TransactionVersion["V2"] = 2] = "V2";
})(TransactionVersion = exports.TransactionVersion || (exports.TransactionVersion = {}));
class TransactionFeatures {
    static hasMintTransferOwnershipTo(version) {
        return version >= TransactionVersion.V2;
    }
}
exports.TransactionFeatures = TransactionFeatures;
class UnsupportedVersionError extends Error {
    constructor(version) {
        super(`Unsupported transaction version: ${version}`);
        this.version = version;
    }
}
exports.UnsupportedVersionError = UnsupportedVersionError;
class Transaction {
    constructor(transactionPostedSerialized) {
        this.transactionPosted = null;
        this.referenceCount = 0;
        this.transactionPostedSerialized = transactionPostedSerialized;
        const reader = bufio_1.default.read(this.transactionPostedSerialized, true);
        this._version = reader.readU8(); // 1
        if (this._version < 1 || this._version > 2) {
            throw new UnsupportedVersionError(this._version);
        }
        const _spendsLength = reader.readU64(); // 8
        const _notesLength = reader.readU64(); // 8
        const _mintsLength = reader.readU64(); // 8
        const _burnsLength = reader.readU64(); // 8
        this._fee = reader.readBigI64(); // 8
        this._expiration = reader.readU32(); // 4
        // randomized public key of sender
        // to read the value of rpk reader.readBytes(PUBLIC_ADDRESS_LENGTH, true).toString('hex')
        reader.seek(rust_nodejs_1.TRANSACTION_PUBLIC_KEY_RANDOMNESS_LENGTH);
        // spend description
        this.spends = Array.from({ length: _spendsLength }, () => {
            // proof 192
            reader.seek(rust_nodejs_1.PROOF_LENGTH);
            // value commitment
            reader.seek(32);
            const rootHash = reader.readHash(); // 32
            const treeSize = reader.readU32(); // 4
            const nullifier = reader.readHash(); // 32
            // signature 64
            reader.seek(rust_nodejs_1.TRANSACTION_SIGNATURE_LENGTH);
            // total serialized size: 192 + 32 + 32 + 4 + 32 + 64 = 356 bytes
            return {
                size: treeSize,
                commitment: rootHash,
                nullifier,
            };
        });
        // output description
        this.notes = Array.from({ length: _notesLength }, () => {
            // proof
            reader.seek(rust_nodejs_1.PROOF_LENGTH);
            // output note
            return new noteEncrypted_1.NoteEncrypted(reader.readBytes(rust_nodejs_1.ENCRYPTED_NOTE_LENGTH, true));
        });
        this.mints = Array.from({ length: _mintsLength }, () => {
            // proof
            reader.seek(rust_nodejs_1.PROOF_LENGTH);
            const asset = rust_nodejs_1.Asset.deserialize(reader.readBytes(rust_nodejs_1.ASSET_LENGTH));
            const value = reader.readBigU64();
            let owner = null;
            let transferOwnershipTo = null;
            if (TransactionFeatures.hasMintTransferOwnershipTo(this._version)) {
                owner = reader.readBytes(rust_nodejs_1.PUBLIC_ADDRESS_LENGTH);
                if (reader.readU8()) {
                    transferOwnershipTo = reader.readBytes(rust_nodejs_1.PUBLIC_ADDRESS_LENGTH);
                }
            }
            else {
                owner = asset.creator();
            }
            // authorizing signature
            reader.seek(rust_nodejs_1.TRANSACTION_SIGNATURE_LENGTH);
            return { asset, value, owner, transferOwnershipTo };
        });
        this.burns = Array.from({ length: _burnsLength }, () => {
            const assetId = reader.readBytes(rust_nodejs_1.ASSET_ID_LENGTH);
            const value = reader.readBigU64();
            return { assetId, value };
        });
        this._signature = reader.readBytes(rust_nodejs_1.TRANSACTION_SIGNATURE_LENGTH, true);
    }
    serialize() {
        return this.transactionPostedSerialized;
    }
    /**
     * The transaction serialization version. This can be incremented when
     * changes need to be made to the transaction format
     */
    version() {
        return this._version;
    }
    /**
     * Preallocate any resources necessary for using the transaction.
     */
    takeReference() {
        this.referenceCount++;
        if (this.transactionPosted === null) {
            this.transactionPosted = new rust_nodejs_1.TransactionPosted(this.transactionPostedSerialized);
        }
        return this.transactionPosted;
    }
    /**
     * Return any resources necessary for using the transaction.
     */
    returnReference() {
        this.referenceCount--;
        if (this.referenceCount <= 0) {
            this.referenceCount = 0;
            this.transactionPosted = null;
        }
    }
    /**
     * Wraps the given callback in takeReference and returnReference.
     */
    withReference(callback) {
        const transaction = this.takeReference();
        const result = callback(transaction);
        Promise.resolve(result).finally(() => {
            this.returnReference();
        });
        return result;
    }
    isMinersFee() {
        return (this.spends.length === 0 &&
            this.notes.length === 1 &&
            this.mints.length === 0 &&
            this.burns.length === 0 &&
            this._fee <= 0);
    }
    getNote(index) {
        return this.notes[index];
    }
    getSpend(index) {
        return this.spends[index];
    }
    /**
     * Get the transaction fee for this transactions.
     *
     * In general, each transaction has outputs lower than the amount spent; the
     * miner can collect the difference as a transaction fee.
     *
     * In a block header's minersFee transaction, the opposite happens;
     * the miner creates a block with zero spends and output equal to the sum
     * of the miner's fee for the block's transaction, plus the block chain's
     * mining reward.
     *
     * The transaction fee is the difference between outputs and spends on the
     * transaction.
     */
    fee() {
        return this._fee;
    }
    /**
     * Get transaction signature for this transaction.
     */
    transactionSignature() {
        return this._signature;
    }
    /**
     * Get the transaction hash that does not include the signature. This is the hash that
     * is signed when the transaction is created
     */
    unsignedHash() {
        this._unsignedHash = this._unsignedHash || this.withReference((t) => t.hash());
        return this._unsignedHash;
    }
    /**
     * Generate the hash of a transaction that includes the witness (signature) data.
     * Used for cases where a signature needs to be committed to in the hash like P2P transaction gossip
     */
    hash() {
        this._hash = this._hash || blake_hash_1.blake3(this.transactionPostedSerialized);
        return this._hash;
    }
    equals(other) {
        return this.transactionPostedSerialized.equals(other.transactionPostedSerialized);
    }
    /**
     * @returns The expiration as block sequence of the transaction.
     * The transaction cannot be added to a block of equal or greater sequence
     */
    expiration() {
        return this._expiration;
    }
}
exports.Transaction = Transaction;
//# sourceMappingURL=transaction.js.map