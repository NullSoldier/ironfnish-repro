/// <reference types="node" />
import { BufferMap } from 'buffer-map';
import { Blockchain } from '../blockchain';
import { Spend } from '../primitives';
import { Block } from '../primitives/block';
import { BlockHeader } from '../primitives/blockheader';
import { BurnDescription } from '../primitives/burnDescription';
import { MintDescription } from '../primitives/mintDescription';
import { Transaction } from '../primitives/transaction';
import { IDatabaseTransaction } from '../storage';
import { WorkerPool } from '../workerPool';
import { Consensus } from './consensus';
export declare class Verifier {
    chain: Blockchain;
    private readonly workerPool;
    /**
     * Used to disable verifying the target on the Verifier for testing purposes
     */
    enableVerifyTarget: boolean;
    constructor(chain: Blockchain, workerPool: WorkerPool);
    /**
     * Verify that the block is internally consistent:
     *  *  Header is valid
     *  *  All transaction proofs are valid
     *  *  Miner's fee is transaction list fees + miner's reward
     */
    verifyBlock(block: Block, options?: {
        verifyTarget?: boolean;
    }, tx?: IDatabaseTransaction): Promise<VerificationResult>;
    /**
     * Verify that this block header is internally consistent. Does not verify
     * the trees or its relationship to other blocks on the chain, and does not
     * verify the transactions in the block.
     *
     * Specifically, it verifies that:
     *  *  graffiti is the appropriate length
     *  *  the block hash meets the target hash on the block
     *  *  the timestamp is not in future by our local clock time
     */
    verifyBlockHeader(blockHeader: BlockHeader, options?: {
        verifyTarget?: boolean;
    }): VerificationResult;
    /**
     * Verify that the header of this block is consistent with the one before it.
     *
     * Specifically, it checks:
     *  -  The block's previousHash equals the hash of the previous block header
     *  -  The timestamp of the block is within a threshold of not being before
     *     the previous block
     *  -  The block sequence has incremented by one
     *  -  The target matches the expected value
     */
    verifyBlockHeaderContextual(current: BlockHeader, previousHeader: BlockHeader): VerificationResult;
    /**
     * Verify that a new transaction received over the network can be accepted into
     * the mempool and rebroadcasted to the network.
     */
    verifyNewTransaction(transaction: Transaction): Promise<VerificationResult>;
    static getMaxTransactionBytes(maxBlockSizeBytes: number): number;
    /**
     * Verify that a transaction created by the account can be accepted into the mempool
     * and rebroadcasted to the network.
     */
    static verifyCreatedTransaction(transaction: Transaction, consensus: Consensus): VerificationResult;
    verifyTransactionSpends(transaction: Transaction, tx?: IDatabaseTransaction): Promise<VerificationResult>;
    verifyTransactionAdd(transaction: Transaction, tx?: IDatabaseTransaction): Promise<VerificationResult>;
    /**
     * Verify that the target of this block is correct against the block before it.
     */
    protected isValidTarget(header: BlockHeader, previous: BlockHeader): boolean;
    verifyBlockAdd(block: Block, prev: BlockHeader | null, tx?: IDatabaseTransaction): Promise<VerificationResult>;
    /**
     * Loop over all spends in the block and check that:
     *  -  The nullifier has not previously been spent
     *  -  the note being spent really existed in the tree at the time it was spent
     */
    verifyConnectedSpends(block: Block, tx?: IDatabaseTransaction): Promise<VerificationResult>;
    /**
     * Verify the block does not contain any double spends before connecting it
     */
    verifyBlockConnect(block: Block, tx?: IDatabaseTransaction): Promise<VerificationResult>;
    /**
     * Verify that the root of the notes tree is the one that is actually associated with the
     * spend's spend root.
     *
     * @param spend the spend to be verified
     * @param notesSize the size of the notes tree
     * @param tx optional transaction context within which to check the spends.
     */
    verifySpend(spend: Spend, notesSize: number, tx?: IDatabaseTransaction): Promise<VerificationResultReason | undefined>;
    /**
     * Determine whether the notes tree matches the commitment in the provided block.
     *
     * Matching means that the root hash of the tree when the tree is the size
     * specified in the commitment is the same as the commitment. Also verifies the spends,
     * which have commitments as well.
     */
    verifyConnectedBlock(block: Block, tx?: IDatabaseTransaction): Promise<VerificationResult>;
    static verifyMints(mints: MintDescription[]): VerificationResult;
    static verifyBurns(burns: BurnDescription[]): VerificationResult;
    /**
     * Given an iterator over some spends, verify that none of the spends reveal
     * the same nullifier as any other in the group. Should be checked at both the
     * block and transaction level.
     */
    static verifyInternalNullifiers(spends: Iterable<Spend>): VerificationResult;
    /**
     * Given a transaction, verify that the hash is not present in the blockchain
     * already. Most of the time, we can count on spends being present, so regular
     * double-spend checks are sufficient. However, if the minimum fee is 0,
     * transactions that do not contain spends could be replayable in some
     * scenarios.
     */
    verifyUnseenTransaction(transaction: Transaction, tx?: IDatabaseTransaction): Promise<VerificationResult>;
    /**
     * Validates that the given owner for each mint is the correct owner based on
     * the current state of the chain and returns the state of the asset owners
     * after processing the mints, taking into account new mints and ownership
     * transfers. Takes an optional existing BufferMap to use as a starting point.
     */
    verifyMintOwnersIncremental(mints: Iterable<MintDescription>, lastKnownAssetOwners?: BufferMap<Buffer>, tx?: IDatabaseTransaction): Promise<{
        valid: boolean;
        assetOwners: BufferMap<Buffer>;
    }>;
    /**
     * Validates that the given owner for each mint is the correct owner based on
     * the current state of the chain
     */
    verifyMintOwners(mints: Iterable<MintDescription>, tx?: IDatabaseTransaction): Promise<VerificationResult>;
}
export declare enum VerificationResultReason {
    BLOCK_TOO_OLD = "Block timestamp is in past",
    DESERIALIZATION = "Failed to deserialize",
    DOUBLE_SPEND = "Double spend",
    DUPLICATE = "Duplicate",
    DUPLICATE_TRANSACTION = "Transaction is a duplicate",
    ERROR = "Error",
    GOSSIPED_GENESIS_BLOCK = "Peer gossiped its genesis block",
    GRAFFITI = "Graffiti field is not 32 bytes in length",
    HASH_NOT_MEET_TARGET = "Hash does not meet target",
    INVALID_ASSET_NAME = "Asset name is blank",
    INVALID_GENESIS_BLOCK = "Peer is using a different genesis block",
    INVALID_MINERS_FEE = "Miner's fee is incorrect",
    INVALID_MINT_OWNER = "Mint owner is not consistent with chain state",
    INVALID_PARENT = "Invalid_parent",
    INVALID_SPEND = "Invalid spend",
    INVALID_TARGET = "Invalid target",
    INVALID_TRANSACTION_COMMITMENT = "Transaction commitment does not match transactions",
    INVALID_TRANSACTION_FEE = "Transaction fee is incorrect",
    INVALID_TRANSACTION_PROOF = "Invalid transaction proof",
    INVALID_TRANSACTION_VERSION = "Invalid transaction version",
    MAX_BLOCK_SIZE_EXCEEDED = "Block size exceeds maximum",
    MAX_TRANSACTION_SIZE_EXCEEDED = "Transaction size exceeds maximum",
    MINERS_FEE_EXPECTED = "Miners fee expected",
    MINIMUM_FEE_NOT_MET = "Transaction fee is below the minimum required fee",
    NATIVE_BURN = "Attempting to burn the native asset",
    NOTE_COMMITMENT = "Note_commitment",
    NOTE_COMMITMENT_SIZE_TOO_LARGE = "Note commitment tree is smaller than referenced by the spend",
    ORPHAN = "Block is an orphan",
    PREV_HASH_MISMATCH = "Previous block hash does not match expected hash",
    PREV_HASH_NULL = "Previous block hash is null",
    SEQUENCE_OUT_OF_ORDER = "Block sequence is out of order",
    TOO_FAR_IN_FUTURE = "Timestamp is in future",
    TRANSACTION_EXPIRED = "Transaction expired",
    VERIFY_TRANSACTION = "Verify_transaction"
}
/**
 * Indicate whether some entity is valid, and if not, provide a reason and
 * hash.
 */
export interface VerificationResult {
    valid: boolean;
    reason?: VerificationResultReason;
}
//# sourceMappingURL=verifier.d.ts.map