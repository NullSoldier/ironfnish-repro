export declare class Event<A extends unknown[]> {
    private handlers;
    /**
     * @returns true if the Event has no listeners
     */
    get isEmpty(): boolean;
    /**
     * @returns the amount of subscriptions on this event
     */
    get subscribers(): number;
    /**
     * Adds a handler for when the event is emitted
     * Make sure you unsubscribe using [[Event.off]]
     */
    on(handler: (...args: A) => void | Promise<void>): void;
    /**
     * Removes an event handler by reference
     *
     * @returns true if the handler was removed
     */
    off(handler: (...args: A) => void | Promise<void>): boolean;
    /**
     * Adds an event handler that's removed after the next event is emitted
     */
    once(handler: (...args: A) => void | Promise<void>): void;
    /**
     * Emits the event, calling all handlers for this event
     */
    emit(...args: A): void;
    /**
     * Emits the event, calling all handlers, and returns a promise that awaits any async handlers
     */
    emitAsync(...args: A): Promise<void>;
    /**
     * Removes all handlers from the event
     */
    clear(): void;
    /**
     * Removes all handlers from the event in the next tick.
     * Useful if you want to clear an event, but allow remaining
     * handlers to execute
     */
    clearAfter(): void;
}
/**
 * A utility function that accepts an Event and returns a
 * promise that resolves the first time the event emits.
 *
 * @param event The event to wait for
 * @returns a promise that resolves the first time the event emits
 */
export declare const waitForEmit: <T extends unknown[]>(event: Event<T>) => Promise<T>;
//# sourceMappingURL=event.d.ts.map