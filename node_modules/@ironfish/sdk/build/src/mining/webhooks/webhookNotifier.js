"use strict";
/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/. */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.WebhookNotifier = void 0;
const axios_1 = __importDefault(require("axios"));
const logger_1 = require("../../logger");
const utils_1 = require("../../utils");
const file_1 = require("../../utils/file");
class WebhookNotifier {
    constructor(options) {
        this.webhook = null;
        this.client = null;
        this.explorerBlocksUrl = null;
        this.explorerTransactionsUrl = null;
        this.logger = options.logger ?? logger_1.createRootLogger();
        this.explorerBlocksUrl = options.explorerBlocksUrl ?? null;
        this.explorerTransactionsUrl = options.explorerTransactionsUrl ?? null;
        if (options.webhook) {
            this.webhook = options.webhook;
            this.client = axios_1.default.create();
        }
    }
    poolConnected() {
        this.sendText('Successfully connected to node');
    }
    poolDisconnected() {
        this.sendText('Disconnected from node unexpectedly. Reconnecting.');
    }
    poolSubmittedBlock(hashedHeaderHex, hashRate, clients) {
        this.sendText(`Block ${this.renderHashHex(hashedHeaderHex, this.explorerBlocksUrl)} submitted successfully! ${file_1.FileUtils.formatHashRate(hashRate)}/s with ${clients} miners`);
    }
    poolPayoutSuccess(payoutPeriodId, transactionHashHex, outputs, shareCount) {
        const total = outputs.reduce((m, c) => BigInt(c.amount) + m, BigInt(0));
        this.sendText(`Successfully created payout of ${shareCount} shares to ${outputs.length} users for ${utils_1.CurrencyUtils.renderIron(total, true)} in transaction ${this.renderHashHex(transactionHashHex, this.explorerTransactionsUrl)}. Transaction pending (${payoutPeriodId})`);
    }
    poolPayoutError(error) {
        this.sendText(`Error while sending payout transaction: ${utils_1.ErrorUtils.renderError(error, true)}`);
    }
    poolPayoutStarted(payoutPeriodId, outputs, shareCount) {
        const total = outputs.reduce((m, c) => BigInt(c.amount) + m, BigInt(0));
        this.sendText(`Creating payout of ${shareCount} shares to ${outputs.length} users for ${utils_1.CurrencyUtils.renderIron(total, true)} (${payoutPeriodId})`);
    }
    poolStatus(status) {
        this.sendText(`Status for mining pool '${status.name}':\n\tHashrate: ${file_1.FileUtils.formatHashRate(status.hashRate)}/s\n\tMiners: ${status.miners}\n\tShares pending: ${status.sharesPending}\n\tClients: ${status.clients}\n\tBans: ${status.bans}`);
    }
    renderHashHex(hashHex, explorerUrl) {
        if (explorerUrl == null) {
            return `\`${hashHex}\``;
        }
        return `${explorerUrl + hashHex}`;
    }
}
exports.WebhookNotifier = WebhookNotifier;
//# sourceMappingURL=webhookNotifier.js.map