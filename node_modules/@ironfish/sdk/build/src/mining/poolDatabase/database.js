"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.PoolDatabase = void 0;
/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/. */
const sqlite_1 = require("sqlite");
const sqlite3_1 = __importDefault(require("sqlite3"));
const assert_1 = require("../../assert");
const nodeFileSystem_1 = require("../../fileSystems/nodeFileSystem");
const migrator_1 = require("./migrator");
const PREVIOUS_PAYOUT_PERIODS = 3;
const MAX_ADDRESSES_PER_PAYOUT = 250;
class PoolDatabase {
    constructor(options) {
        this.db = options.db;
        this.migrations = new migrator_1.Migrator({ db: options.db, logger: options.logger });
    }
    static async init(options) {
        const fs = new nodeFileSystem_1.NodeFileProvider();
        await fs.init();
        const poolFolder = fs.join(options.config.dataDir, '/pool');
        await fs.mkdir(poolFolder, { recursive: true });
        const db = await sqlite_1.open({
            filename: options.dbPath || fs.join(poolFolder, '/database.sqlite'),
            driver: sqlite3_1.default.Database,
        });
        return new PoolDatabase({
            db,
            logger: options.logger,
            config: options.config,
        });
    }
    async start() {
        await this.migrations.migrate();
    }
    async stop() {
        await this.db.close();
    }
    async newShare(publicAddress) {
        const sql = `
      INSERT INTO payoutShare (payoutPeriodId, publicAddress)
      VALUES (
        (SELECT id FROM payoutPeriod WHERE end IS NULL),
        ?
      )
    `;
        await this.db.run(sql, publicAddress);
    }
    async shareCountSince(timestamp, publicAddress) {
        // JS timestamps have millisecond resolution, sqlite timestamps have second resolution
        const sqlTimestamp = Math.floor(timestamp / 1000);
        let sql = "SELECT COUNT(id) AS count FROM payoutShare WHERE createdAt > datetime(?, 'unixepoch')";
        if (publicAddress) {
            sql += ' AND publicAddress = ?';
        }
        const result = await this.db.get(sql, sqlTimestamp, publicAddress);
        if (result === undefined) {
            return 0;
        }
        return result.count;
    }
    async getCurrentPayoutPeriod() {
        return await this.db.get('SELECT * FROM payoutPeriod WHERE end is null');
    }
    async rolloverPayoutPeriod(timestamp) {
        await this.db.run('BEGIN');
        await this.db.run('UPDATE payoutPeriod SET end = ? WHERE end IS NULL', timestamp - 1);
        await this.db.run('INSERT INTO payoutPeriod (start) VALUES (?)', timestamp);
        await this.db.run('COMMIT');
    }
    async newBlock(sequence, hash, reward) {
        const sql = `
      INSERT INTO block (payoutPeriodId, blockSequence, blockHash, minerReward)
      VALUES (
        (SELECT id FROM payoutPeriod WHERE end IS NULL),
        ?, ?, ?
      )
    `;
        const result = await this.db.run(sql, sequence, hash, reward);
        return result.lastID;
    }
    async unconfirmedBlocks() {
        const rows = await this.db.all('SELECT * FROM block WHERE confirmed = FALSE');
        const results = [];
        for (const row of rows) {
            results.push(parseDatabaseBlock(row));
        }
        return results;
    }
    async updateBlockStatus(blockId, main, confirmed) {
        await this.db.run('UPDATE block SET main = ?, confirmed = ? WHERE id = ?', main, confirmed, blockId);
    }
    async newTransaction(hash, payoutPeriodId) {
        const result = await this.db.run('INSERT INTO payoutTransaction (transactionHash, payoutPeriodId) VALUES (?, ?)', hash, payoutPeriodId);
        return result.lastID;
    }
    async unconfirmedTransactions() {
        const rows = await this.db.all('SELECT * FROM payoutTransaction WHERE confirmed = FALSE AND expired = FALSE');
        const result = [];
        for (const row of rows) {
            result.push(parseDatabasePayoutTransaction(row));
        }
        return result;
    }
    async updateTransactionStatus(transactionId, confirmed, expired) {
        await this.db.run('UPDATE payoutTransaction SET confirmed = ?, expired = ? WHERE id = ?', confirmed, expired, transactionId);
    }
    // Returns a capped number of unique public addresses and the amount of shares
    // they earned for a specific payout period
    async payoutAddresses(payoutPeriodId) {
        const sql = `
      SELECT publicAddress, COUNT(id) shareCount
      FROM payoutShare
      WHERE
        payoutPeriodId = ?
        AND payoutTransactionId IS NULL
      GROUP BY publicAddress
      LIMIT ?
    `;
        return await this.db.all(sql, payoutPeriodId, MAX_ADDRESSES_PER_PAYOUT);
    }
    async markSharesPaid(payoutPeriodId, payoutTransactionId, publicAddresses) {
        assert_1.Assert.isGreaterThan(publicAddresses.length, 0, 'markSharesPaid must be called with at least 1 address');
        const sql = `
      UPDATE payoutShare
      SET payoutTransactionId = ?
      WHERE
        payoutPeriodId = ?
        AND publicAddress IN ('${publicAddresses.join("','")}')
    `;
        await this.db.run(sql, payoutTransactionId, payoutPeriodId);
    }
    async markSharesUnpaid(transactionId) {
        await this.db.run('UPDATE payoutShare SET payoutTransactionId = NULL WHERE payoutTransactionId = ?', transactionId);
    }
    async deleteUnpayableShares(payoutPeriodId) {
        await this.db.run('DELETE FROM payoutShare WHERE payoutPeriodId = ?', payoutPeriodId);
    }
    async earliestOutstandingPayoutPeriod() {
        const sql = `
      SELECT * FROM payoutPeriod WHERE id = (
        SELECT payoutPeriodId FROM payoutShare WHERE payoutTransactionId IS NULL ORDER BY id LIMIT 1
      ) AND end IS NOT NULL
    `;
        return await this.db.get(sql);
    }
    async payoutPeriodShareCount(payoutPeriodId) {
        const result = await this.db.get('SELECT COUNT(*) AS count FROM payoutShare WHERE payoutPeriodId = ?', payoutPeriodId);
        if (result === undefined) {
            return 0;
        }
        return result.count;
    }
    // Returns the shares that have not been paid out independent of payout period
    async pendingShareCount(publicAddress) {
        let sql = 'SELECT COUNT(*) AS count FROM payoutShare WHERE payoutTransactionId IS NULL';
        if (publicAddress) {
            sql += ' AND publicAddress = ?';
        }
        const result = await this.db.get(sql, publicAddress);
        if (result === undefined) {
            return 0;
        }
        return result.count;
    }
    // Returns the total payout reward for a specific payout period
    async getPayoutReward(payoutPeriodId) {
        const sql = `
      SELECT
        *,
        (SELECT SUM(minerReward) FROM block
          WHERE
            payoutPeriodId = payoutPeriod.id
            AND confirmed = TRUE
            AND main = TRUE
        ) reward
      FROM payoutPeriod
      WHERE id BETWEEN ? AND ?
    `;
        const results = await this.db.all(sql, payoutPeriodId - PREVIOUS_PAYOUT_PERIODS, payoutPeriodId);
        const percentAmount = {
            [payoutPeriodId]: BigInt(50),
            [payoutPeriodId - 1]: BigInt(25),
            [payoutPeriodId - 2]: BigInt(15),
            [payoutPeriodId - 3]: BigInt(10), // 10% of payout period x-3
        };
        // Safety check in case the associated const is changed
        assert_1.Assert.isEqual(PREVIOUS_PAYOUT_PERIODS + 1, Object.keys(percentAmount).length, 'Payout period percent amount needs to have a value for each period');
        let totalReward = BigInt(0);
        for (const result of results) {
            const reward = BigInt(result.reward || '0');
            const amount = (reward * percentAmount[result.id]) / BigInt(100);
            totalReward += amount;
        }
        return totalReward;
    }
    // Checks the related payouts (the given payout period and the payouts within
    // PREVIOUS_PAYOUT_PERIODS) to see if any of them have unconfirmed blocks
    async payoutPeriodBlocksConfirmed(payoutPeriodId) {
        const sql = `
      SELECT *
      FROM block
      WHERE
        payoutPeriodId BETWEEN ? AND ?
        AND confirmed = FALSE
    `;
        const results = await this.db.all(sql, payoutPeriodId - PREVIOUS_PAYOUT_PERIODS, payoutPeriodId);
        if (results.length > 0) {
            return false;
        }
        return true;
    }
}
exports.PoolDatabase = PoolDatabase;
function parseDatabaseBlock(rawBlock) {
    return {
        id: rawBlock.id,
        createdAt: new Date(rawBlock.createdAt),
        blockSequence: rawBlock.blockSequence,
        blockHash: rawBlock.blockHash,
        minerReward: BigInt(rawBlock.minerReward),
        confirmed: Boolean(rawBlock.confirmed),
        main: Boolean(rawBlock.main),
        payoutPeriodId: rawBlock.payoutPeriodId,
    };
}
function parseDatabasePayoutTransaction(rawTransaction) {
    return {
        id: rawTransaction.id,
        createdAt: new Date(rawTransaction.createdAt),
        transactionHash: rawTransaction.transactionHash,
        confirmed: Boolean(rawTransaction.confirmed),
        expired: Boolean(rawTransaction.expired),
        payoutPeriodId: rawTransaction.payoutPeriodId,
    };
}
//# sourceMappingURL=database.js.map