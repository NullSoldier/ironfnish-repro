"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MiningPoolMiner = void 0;
/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/. */
const rust_nodejs_1 = require("@ironfish/rust-nodejs");
const assert_1 = require("../assert");
const meter_1 = require("../metrics/meter");
const file_1 = require("../utils/file");
const graffiti_1 = require("../utils/graffiti");
const promise_1 = require("../utils/promise");
const validator_1 = require("../wallet/validator");
const utils_1 = require("./utils");
class MiningPoolMiner {
    constructor(options) {
        this.logger = options.logger;
        this.graffiti = null;
        this.name = options.name;
        this.publicAddress = options.publicAddress;
        if (!validator_1.isValidPublicAddress(this.publicAddress)) {
            throw new Error(`Invalid public address: ${this.publicAddress}`);
        }
        const threadCount = options.threadCount ?? 1;
        this.threadPool = new rust_nodejs_1.ThreadPoolHandler(threadCount, options.batchSize, false);
        this.stratum = options.stratum;
        this.stratum.onConnected.on(() => this.stratum.subscribe(this.publicAddress, this.name));
        this.stratum.onSubscribed.on((m) => this.setGraffiti(graffiti_1.GraffitiUtils.fromString(m.graffiti)));
        this.stratum.onSetTarget.on((m) => this.setTarget(m.target));
        this.stratum.onNotify.on((m) => this.newWork(m.miningRequestId, Buffer.from(m.header, 'hex')));
        this.stratum.onWaitForWork.on(() => this.waitForWork());
        this.hashRate = new meter_1.Meter();
        this.miningRequestId = 0;
        this.target = Buffer.alloc(32, 0);
        this.stopPromise = null;
        this.stopResolve = null;
        this.started = false;
        this.waiting = false;
    }
    start() {
        if (this.started) {
            return;
        }
        this.stopPromise = new Promise((r) => (this.stopResolve = r));
        this.started = true;
        this.stratum.start();
        this.hashRate.start();
        void this.mine();
    }
    stop() {
        if (!this.started) {
            return;
        }
        this.logger.debug('Stopping miner, goodbye');
        this.started = false;
        this.stratum.stop();
        this.hashRate.stop();
        if (this.stopResolve) {
            this.stopResolve();
        }
    }
    async waitForStop() {
        await this.stopPromise;
    }
    setTarget(target) {
        this.target = Buffer.from(target, 'hex');
    }
    setGraffiti(graffiti) {
        this.graffiti = graffiti;
    }
    newWork(miningRequestId, header) {
        assert_1.Assert.isNotNull(this.graffiti);
        this.logger.debug(`new work ${header
            .toString('hex')
            .slice(0, 50)}... ${miningRequestId} ${file_1.FileUtils.formatHashRate(this.hashRate.rate1s)}/s`);
        const headerBytes = Buffer.concat([header]);
        headerBytes.set(this.graffiti, utils_1.MINEABLE_BLOCK_HEADER_GRAFFITI_OFFSET);
        this.waiting = false;
        this.threadPool.newWork(headerBytes, this.target, miningRequestId);
    }
    waitForWork() {
        this.waiting = true;
        this.threadPool.pause();
    }
    async mine() {
        while (this.started) {
            if (!this.stratum.isConnected()) {
                await promise_1.PromiseUtils.sleep(500);
                continue;
            }
            if (this.graffiti == null) {
                this.logger.info('Waiting for graffiti from pool...');
                await promise_1.PromiseUtils.sleep(500);
                continue;
            }
            const blockResult = this.threadPool.getFoundBlock();
            if (blockResult != null) {
                const { miningRequestId, randomness } = blockResult;
                this.logger.info(`Found share: ${randomness} ${miningRequestId} ${file_1.FileUtils.formatHashRate(this.hashRate.rate1s)}/s`);
                this.stratum.submit(miningRequestId, randomness);
            }
            const hashRate = this.threadPool.getHashRateSubmission();
            this.hashRate.add(hashRate);
            await promise_1.PromiseUtils.sleep(10);
        }
        this.hashRate.stop();
    }
}
exports.MiningPoolMiner = MiningPoolMiner;
//# sourceMappingURL=poolMiner.js.map