"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.StratumServer = void 0;
const assert_1 = require("../../assert");
const block_1 = require("../../primitives/block");
const utils_1 = require("../../utils");
const error_1 = require("../../utils/error");
const yup_1 = require("../../utils/yup");
const validator_1 = require("../../wallet/validator");
const utils_2 = require("../utils");
const constants_1 = require("./constants");
const errors_1 = require("./errors");
const messages_1 = require("./messages");
const stratumPeers_1 = require("./stratumPeers");
const stratumServerClient_1 = require("./stratumServerClient");
const version_1 = require("./version");
const FIVE_MINUTES_MS = 5 * 60 * 1000;
class StratumServer {
    constructor(options) {
        this.adapters = [];
        this.currentWork = null;
        this.currentMiningRequestId = null;
        this._isRunning = false;
        this._startPromise = null;
        this.pool = options.pool;
        this.config = options.config;
        this.logger = options.logger;
        this.version = version_1.VERSION_PROTOCOL_STRATUM;
        this.versionMin = version_1.VERSION_PROTOCOL_STRATUM_MIN;
        this.clients = new Map();
        this.nextMinerId = 1;
        this.nextMessageId = 1;
        this.subscribed = 0;
        this.peers = new stratumPeers_1.StratumPeers({
            config: this.config,
            server: this,
            banning: options.banning,
        });
    }
    get isRunning() {
        return this._isRunning;
    }
    /** Starts the Stratum server and tells any attached adapters to start serving requests */
    async start() {
        if (this._isRunning) {
            return;
        }
        this.peers.start();
        this._startPromise = Promise.all(this.adapters.map((a) => a.start()));
        this._isRunning = true;
        await this._startPromise;
    }
    /** Stops the Stratum server and tells any attached adapters to stop serving requests */
    async stop() {
        if (!this._isRunning) {
            return;
        }
        if (this._startPromise) {
            await this._startPromise;
        }
        await Promise.all(this.adapters.map((a) => a.stop()));
        this._isRunning = false;
    }
    /** Adds an adapter to the Stratum server and starts it if the server has already been started */
    mount(adapter) {
        this.adapters.push(adapter);
        adapter.attach(this);
        if (this._isRunning) {
            let promise = adapter.start();
            if (this._startPromise) {
                // Attach this promise to the start promise chain
                // in case we call stop while were still starting up
                promise = Promise.all([this._startPromise, promise]);
            }
            this._startPromise = promise;
        }
    }
    newWork(miningRequestId, block) {
        this.currentMiningRequestId = miningRequestId;
        this.currentWork = utils_2.mineableHeaderString(block.header);
        this.logger.info(`Setting work for request: ${this.currentMiningRequestId} ${this.currentWork
            .toString('hex')
            .slice(0, 50)}...`);
        this.broadcast('mining.notify', this.getNotifyMessage());
    }
    waitForWork() {
        this.broadcast('mining.wait_for_work');
    }
    hasWork() {
        return this.currentWork != null;
    }
    onConnection(socket) {
        if (!this.peers.isAllowed(socket)) {
            if (this.peers.isBanned(socket)) {
                this.peers.sendBanMessage(socket);
            }
            socket.destroy();
            return;
        }
        const client = stratumServerClient_1.StratumServerClient.accept(socket, this.nextMinerId++);
        this.peers.addConnectionCount(client);
        socket.on('data', (data) => {
            this.onData(client, data).catch((e) => this.onError(client, e));
        });
        socket.on('close', () => this.onDisconnect(client));
        socket.on('error', (e) => this.onError(client, e));
        this.logger.debug(`Client ${client.id} connected: ${client.remoteAddress}`);
        this.clients.set(client.id, client);
    }
    onDisconnect(client) {
        this.logger.debug(`Client ${client.id} disconnected  (${this.clients.size - 1} total)`);
        if (client.subscribed) {
            this.subscribed--;
        }
        this.clients.delete(client.id);
        this.peers.removeConnectionCount(client);
        client.close();
        client.socket.removeAllListeners('close');
        client.socket.removeAllListeners('error');
    }
    async onData(client, data) {
        if (this.peers.isShadowBanned(client)) {
            return;
        }
        client.messageBuffer += data.toString('utf-8');
        const lastDelimiterIndex = client.messageBuffer.lastIndexOf('\n');
        const splits = client.messageBuffer.substring(0, lastDelimiterIndex).trim().split('\n');
        client.messageBuffer = client.messageBuffer.substring(lastDelimiterIndex + 1);
        for (const split of splits) {
            const payload = JSON.parse(split);
            const header = await yup_1.YupUtils.tryValidate(messages_1.StratumMessageSchema, payload);
            if (header.error) {
                this.peers.ban(client, {
                    message: header.error.message,
                });
                return;
            }
            this.logger.debug(`Client ${client.id} sent ${header.result.method} message`);
            switch (header.result.method) {
                case 'mining.subscribe': {
                    const body = await yup_1.YupUtils.tryValidate(messages_1.MiningSubscribeSchema, header.result.body);
                    if (body.error) {
                        this.peers.ban(client, {
                            message: body.error.message,
                        });
                        return;
                    }
                    if (body.result.version < this.versionMin) {
                        this.peers.ban(client, {
                            message: `Client version ${body.result.version} does not meet minimum version ${this.versionMin}`,
                            reason: constants_1.DisconnectReason.BAD_VERSION,
                            until: Date.now() + FIVE_MINUTES_MS,
                            versionExpected: this.version,
                        });
                        return;
                    }
                    if (!validator_1.isValidPublicAddress(body.result.publicAddress)) {
                        this.peers.ban(client, {
                            message: `Invalid public address: ${body.result.publicAddress}`,
                        });
                        return;
                    }
                    client.publicAddress = body.result.publicAddress;
                    client.name = body.result.name;
                    client.subscribed = true;
                    this.subscribed++;
                    const idHex = client.id.toString(16);
                    const graffiti = `${this.pool.name}.${idHex}`;
                    assert_1.Assert.isTrue(utils_1.StringUtils.getByteLength(graffiti) <= block_1.GRAFFITI_SIZE);
                    client.graffiti = utils_1.GraffitiUtils.fromString(graffiti);
                    this.logger.info(`Miner ${idHex} connected (${this.subscribed} total)`);
                    this.send(client.socket, 'mining.subscribed', {
                        clientId: client.id,
                        graffiti: graffiti,
                    });
                    this.send(client.socket, 'mining.set_target', this.getSetTargetMessage());
                    if (this.hasWork()) {
                        this.send(client.socket, 'mining.notify', this.getNotifyMessage());
                    }
                    break;
                }
                case 'mining.submit': {
                    const body = await yup_1.YupUtils.tryValidate(messages_1.MiningSubmitSchema, header.result.body);
                    if (body.error) {
                        this.peers.ban(client, {
                            message: body.error.message,
                        });
                        return;
                    }
                    const submittedRequestId = body.result.miningRequestId;
                    const submittedRandomness = body.result.randomness;
                    void this.pool.submitWork(client, submittedRequestId, submittedRandomness);
                    break;
                }
                case 'mining.get_status': {
                    const body = await yup_1.YupUtils.tryValidate(messages_1.MiningGetStatusSchema, header.result.body);
                    if (body.error) {
                        this.peers.ban(client, {
                            message: body.error.message,
                        });
                        return;
                    }
                    const publicAddress = body.result?.publicAddress;
                    if (publicAddress && !validator_1.isValidPublicAddress(publicAddress)) {
                        this.peers.ban(client, {
                            message: `Invalid public address: ${publicAddress}`,
                        });
                        return;
                    }
                    this.send(client.socket, 'mining.status', await this.pool.getStatus(publicAddress));
                    break;
                }
                default:
                    throw new errors_1.ClientMessageMalformedError(client, `Invalid message ${header.result.method}`);
            }
        }
    }
    onError(client, error) {
        this.logger.debug(`Error during handling of data from client ${client.id}: ${error_1.ErrorUtils.renderError(error, true)}`);
        client.socket.removeAllListeners();
        client.close();
        if (client.subscribed) {
            this.subscribed--;
        }
        this.clients.delete(client.id);
        this.peers.removeConnectionCount(client);
    }
    getNotifyMessage() {
        assert_1.Assert.isNotNull(this.currentMiningRequestId);
        assert_1.Assert.isNotNull(this.currentWork);
        return {
            miningRequestId: this.currentMiningRequestId,
            header: this.currentWork?.toString('hex'),
        };
    }
    getSetTargetMessage() {
        return {
            target: this.pool.getTarget(),
        };
    }
    broadcast(method, body) {
        const message = {
            id: this.nextMessageId++,
            method: method,
            body: body,
        };
        const serialized = JSON.stringify(message) + '\n';
        this.logger.debug('broadcasting to clients', {
            method,
            id: message.id,
            numClients: this.clients.size,
            messageLength: serialized.length,
        });
        let broadcasted = 0;
        for (const client of this.clients.values()) {
            if (!client.subscribed) {
                continue;
            }
            if (!client.connected) {
                continue;
            }
            if (this.peers.isShadowBanned(client)) {
                continue;
            }
            client.socket.write(serialized);
            broadcasted++;
        }
        this.logger.debug('completed broadcast to clients', {
            method,
            id: message.id,
            numClients: broadcasted,
            messageLength: serialized.length,
        });
    }
    send(socket, method, body) {
        const message = {
            id: this.nextMessageId++,
            method: method,
            body: body,
        };
        const serialized = JSON.stringify(message) + '\n';
        socket.write(serialized);
    }
}
exports.StratumServer = StratumServer;
//# sourceMappingURL=stratumServer.js.map