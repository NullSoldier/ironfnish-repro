"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.StratumClient = void 0;
/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/. */
const event_1 = require("../../../event");
const rpc_1 = require("../../../rpc");
const utils_1 = require("../../../utils");
const yup_1 = require("../../../utils/yup");
const constants_1 = require("../constants");
const errors_1 = require("../errors");
const messages_1 = require("../messages");
const version_1 = require("../version");
class StratumClient {
    constructor(options) {
        this.messageBuffer = new rpc_1.MessageBuffer('\n');
        this.disconnectReason = null;
        this.disconnectUntil = null;
        this.disconnectVersion = null;
        this.disconnectMessage = null;
        this.onConnected = new event_1.Event();
        this.onSubscribed = new event_1.Event();
        this.onSetTarget = new event_1.Event();
        this.onNotify = new event_1.Event();
        this.onWaitForWork = new event_1.Event();
        this.onStatus = new event_1.Event();
        this.onDisconnect = () => {
            this.connected = false;
            this.messageBuffer.clear();
            this.onWaitForWork.emit(undefined);
            if (this.disconnectReason === constants_1.DisconnectReason.BAD_VERSION) {
                this.logger.info(`Disconnected: You are running stratum version ${this.version} and the pool is running version ${String(this.disconnectVersion)}.`);
            }
            else if (this.disconnectUntil) {
                let message = `Disconnected: You have been banned from the pool until ${new Date(this.disconnectUntil).toUTCString()}`;
                if (this.disconnectMessage) {
                    message += ': ' + this.disconnectMessage;
                }
                this.logger.info(message);
            }
            else {
                this.logger.info('Disconnected from pool unexpectedly. Reconnecting.');
            }
            this.connectTimeout = setTimeout(() => void this.startConnecting(), 5000);
        };
        this.onError = (error) => {
            this.logger.error(`Stratum Error ${utils_1.ErrorUtils.renderError(error)}`);
        };
        this.logger = options.logger;
        this.version = version_1.VERSION_PROTOCOL_STRATUM;
        this.started = false;
        this.id = null;
        this.nextMessageId = 0;
        this.connected = false;
        this.connectWarned = false;
        this.connectTimeout = null;
    }
    start() {
        if (this.started) {
            return;
        }
        this.started = true;
        this.logger.info('Connecting to pool...');
        void this.startConnecting();
    }
    async startConnecting() {
        if (this.disconnectUntil && this.disconnectUntil > Date.now()) {
            this.connectTimeout = setTimeout(() => void this.startConnecting(), 60 * 1000);
            return;
        }
        const connected = await this.connect()
            .then(() => true)
            .catch(() => false);
        if (!this.started) {
            return;
        }
        if (!connected) {
            if (!this.connectWarned) {
                this.logger.warn(`Failed to connect to pool, retrying...`);
                this.connectWarned = true;
            }
            this.connectTimeout = setTimeout(() => void this.startConnecting(), 5000);
            return;
        }
        this.connectWarned = false;
        this.onConnect();
        this.onConnected.emit();
    }
    stop() {
        void this.close();
        if (this.connectTimeout) {
            clearTimeout(this.connectTimeout);
        }
    }
    subscribe(publicAddress, name) {
        this.send('mining.subscribe', {
            version: this.version,
            name,
            publicAddress: publicAddress,
        });
        this.logger.info('Subscribing to pool to receive work');
    }
    submit(miningRequestId, randomness) {
        this.send('mining.submit', {
            miningRequestId: miningRequestId,
            randomness: randomness,
        });
    }
    getStatus(publicAddress) {
        this.send('mining.get_status', { publicAddress: publicAddress });
    }
    isConnected() {
        return this.connected;
    }
    send(method, body) {
        if (!this.connected) {
            return;
        }
        const message = {
            id: this.nextMessageId++,
            method: method,
            body: body,
        };
        this.writeData(JSON.stringify(message) + '\n');
    }
    onConnect() {
        this.connected = true;
        this.logger.info('Successfully connected to pool');
    }
    async onData(data) {
        this.messageBuffer.write(data);
        for (const message of this.messageBuffer.readMessages()) {
            const payload = JSON.parse(message);
            const header = await yup_1.YupUtils.tryValidate(messages_1.StratumMessageSchema, payload);
            if (header.error) {
                throw new errors_1.ServerMessageMalformedError(header.error);
            }
            this.logger.debug(`Server sent ${header.result.method} message`);
            switch (header.result.method) {
                case 'mining.disconnect': {
                    const body = await yup_1.YupUtils.tryValidate(messages_1.MiningDisconnectMessageSchema, header.result.body);
                    this.disconnectReason = body.result?.reason ?? null;
                    this.disconnectVersion = body.result?.versionExpected ?? null;
                    this.disconnectUntil = body.result?.bannedUntil ?? null;
                    this.disconnectMessage = body.result?.message ?? null;
                    this.stop();
                    break;
                }
                case 'mining.subscribed': {
                    const body = await yup_1.YupUtils.tryValidate(messages_1.MiningSubscribedMessageSchema, header.result.body);
                    if (body.error) {
                        throw new errors_1.ServerMessageMalformedError(body.error, header.result.method);
                    }
                    this.id = body.result.clientId;
                    this.logger.debug(`Server has identified us as client ${this.id}`);
                    this.onSubscribed.emit(body.result);
                    break;
                }
                case 'mining.set_target': {
                    const body = await yup_1.YupUtils.tryValidate(messages_1.MiningSetTargetSchema, header.result.body);
                    if (body.error) {
                        throw new errors_1.ServerMessageMalformedError(body.error, header.result.method);
                    }
                    this.onSetTarget.emit(body.result);
                    break;
                }
                case 'mining.notify': {
                    const body = await yup_1.YupUtils.tryValidate(messages_1.MiningNotifySchema, header.result.body);
                    if (body.error) {
                        throw new errors_1.ServerMessageMalformedError(body.error, header.result.method);
                    }
                    this.onNotify.emit(body.result);
                    break;
                }
                case 'mining.wait_for_work': {
                    const body = await yup_1.YupUtils.tryValidate(messages_1.MiningWaitForWorkSchema, header.result.body);
                    if (body.error) {
                        throw new errors_1.ServerMessageMalformedError(body.error, header.result.method);
                    }
                    this.onWaitForWork.emit(body.result);
                    break;
                }
                case 'mining.status': {
                    const body = await yup_1.YupUtils.tryValidate(messages_1.MiningStatusSchema, header.result.body);
                    if (body.error) {
                        throw new errors_1.ServerMessageMalformedError(body.error, header.result.method);
                    }
                    this.onStatus.emit(body.result);
                    break;
                }
                default:
                    throw new errors_1.ServerMessageMalformedError(`Invalid message ${header.result.method}`);
            }
        }
    }
}
exports.StratumClient = StratumClient;
//# sourceMappingURL=client.js.map