"use strict";
/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/. */
Object.defineProperty(exports, "__esModule", { value: true });
exports.StratumPeers = void 0;
const event_1 = require("../../event");
const logger_1 = require("../../logger");
const constants_1 = require("./constants");
const FIVE_MINUTES_MS = 5 * 60 * 1000;
const PEERS_TICK_MS = 10000;
class StratumPeers {
    constructor(options) {
        this.onBanned = new event_1.Event();
        this.banCount = 0;
        this.bannedByIp = new Map();
        this.connectionsByIp = new Map();
        this.scoreByIp = new Map();
        this.shadowBans = new Set();
        this.eventLoopTimeout = null;
        this.logger = options.logger ?? logger_1.createRootLogger();
        this.server = options.server;
        this.banning = options.banning ?? options.config.get('poolBanning');
        this.maxConnectionsByIp =
            options.maxConnectionsPerIp ?? options.config.get('poolMaxConnectionsPerIp');
    }
    start() {
        this.eventLoop();
    }
    stop() {
        if (this.eventLoopTimeout) {
            clearTimeout(this.eventLoopTimeout);
        }
    }
    punish(client, message, amount = 1) {
        if (this.isBanned(client.socket)) {
            return;
        }
        let banScore = this.scoreByIp.get(client.remoteAddress) ?? 0;
        banScore += amount;
        if (banScore < 10) {
            this.scoreByIp.set(client.remoteAddress, banScore);
            return;
        }
        this.ban(client, { message });
        this.scoreByIp.delete(client.remoteAddress);
    }
    shadowBan(client) {
        this.shadowBans.add(client.id);
    }
    ban(client, options) {
        if (!this.banning) {
            this.shadowBan(client);
            return;
        }
        const until = options?.until ?? Date.now() + FIVE_MINUTES_MS;
        let existing = this.bannedByIp.get(client.remoteAddress);
        if (!existing || existing.until < until) {
            existing = {
                until: until,
                reason: options?.reason ?? constants_1.DisconnectReason.UNKNOWN,
                message: options?.message,
                versionExpected: options?.versionExpected,
            };
        }
        this.bannedByIp.set(client.remoteAddress, existing);
        this.scoreByIp.delete(client.remoteAddress);
        this.banCount++;
        this.sendBanMessage(client.socket);
        client.close();
        this.onBanned.emit(client);
        this.logger.info(`Banned ${client.remoteAddress}: ${options?.message ?? options?.reason ?? 'unknown'} until: ${new Date(until).toUTCString()} (${this.banCount} bans)`);
    }
    sendBanMessage(socket) {
        if (!socket.remoteAddress) {
            return;
        }
        const ban = this.bannedByIp.get(socket.remoteAddress);
        if (!ban) {
            return;
        }
        this.server.send(socket, 'mining.disconnect', {
            reason: ban.reason,
            versionExpected: ban.versionExpected,
            bannedUntil: ban.until,
            message: ban.message,
        });
    }
    isShadowBanned(client) {
        return this.shadowBans.has(client.id);
    }
    isBanned(socket) {
        if (!socket.remoteAddress) {
            return false;
        }
        const ban = this.bannedByIp.get(socket.remoteAddress);
        if (!ban?.until) {
            return false;
        }
        return ban.until > Date.now();
    }
    isAllowed(socket) {
        if (!socket.remoteAddress) {
            return false;
        }
        if (this.isBanned(socket)) {
            return false;
        }
        const connections = this.connectionsByIp.get(socket.remoteAddress) ?? 0;
        if (this.maxConnectionsByIp > 0 && connections >= this.maxConnectionsByIp) {
            return false;
        }
        return true;
    }
    addConnectionCount(client) {
        const count = this.connectionsByIp.get(client.remoteAddress) ?? 0;
        this.connectionsByIp.set(client.remoteAddress, count + 1);
    }
    removeConnectionCount(client) {
        const count = this.connectionsByIp.get(client.remoteAddress) ?? 0;
        this.connectionsByIp.set(client.remoteAddress, count - 1);
        if (count - 1 <= 0) {
            this.connectionsByIp.delete(client.remoteAddress);
        }
        this.shadowBans.delete(client.id);
    }
    unpunish(remoteAddress, reduceBy = 1) {
        let score = this.scoreByIp.get(remoteAddress);
        if (score === undefined) {
            return;
        }
        score -= reduceBy;
        if (score > 0) {
            this.scoreByIp.set(remoteAddress, score);
        }
        else {
            this.scoreByIp.delete(remoteAddress);
        }
    }
    eventLoop() {
        for (const remoteAddress of this.scoreByIp.keys()) {
            this.unpunish(remoteAddress);
        }
        this.eventLoopTimeout = setTimeout(() => this.eventLoop(), PEERS_TICK_MS);
    }
}
exports.StratumPeers = StratumPeers;
//# sourceMappingURL=stratumPeers.js.map