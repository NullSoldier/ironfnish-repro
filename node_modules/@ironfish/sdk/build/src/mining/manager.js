"use strict";
/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/. */
Object.defineProperty(exports, "__esModule", { value: true });
exports.MiningManager = exports.MINED_RESULT = void 0;
const buffer_map_1 = require("buffer-map");
const assert_1 = require("../assert");
const blockchain_1 = require("../blockchain");
const consensus_1 = require("../consensus");
const event_1 = require("../event");
const serializers_1 = require("../network/utils/serializers");
const blockheader_1 = require("../primitives/blockheader");
const serde_1 = require("../serde");
const utils_1 = require("../utils");
const bench_1 = require("../utils/bench");
const graffiti_1 = require("../utils/graffiti");
const minersFeeCache_1 = require("./minersFeeCache");
var MINED_RESULT;
(function (MINED_RESULT) {
    MINED_RESULT["UNKNOWN_REQUEST"] = "UNKNOWN_REQUEST";
    MINED_RESULT["CHAIN_CHANGED"] = "CHAIN_CHANGED";
    MINED_RESULT["ADD_FAILED"] = "ADD_FAILED";
    MINED_RESULT["FORK"] = "FORK";
    MINED_RESULT["SUCCESS"] = "SUCCESS";
})(MINED_RESULT = exports.MINED_RESULT || (exports.MINED_RESULT = {}));
class MiningManager {
    constructor(options) {
        this.blocksMined = 0;
        // Called when a new block has been mined and added to the chain
        this.onNewBlock = new event_1.Event();
        this.node = options.node;
        this.memPool = options.memPool;
        this.chain = options.chain;
        this.metrics = options.metrics;
        this.minersFeeCache = new minersFeeCache_1.MinersFeeCache({ node: this.node });
        this.chain.onConnectBlock.on((block) => void this.onConnectedBlock(block).catch((error) => this.handleOnConnectBlockError(error, block)));
    }
    handleOnConnectBlockError(error, block) {
        if (error instanceof blockchain_1.HeadChangedError) {
            this.node.logger.debug(`Chain head changed while creating block template for sequence ${block.header.sequence + 1}`);
        }
        else {
            this.node.logger.error(`Error creating block template: ${utils_1.ErrorUtils.renderError(error)}`);
        }
    }
    get minersConnected() {
        return this.templateStream?.onNewBlockTemplate.subscribers || 0;
    }
    onNewBlockTemplate(listener) {
        if (!this.templateStream) {
            const onNewBlockTemplate = new event_1.Event();
            onNewBlockTemplate.on(listener);
            this.templateStream = { onNewBlockTemplate };
            // Send an initial block template to the requester so they can begin working immediately
            void this.chain.getBlock(this.chain.head).then((currentBlock) => {
                if (currentBlock) {
                    void this.onConnectedBlock(currentBlock).catch((error) => this.handleOnConnectBlockError(error, currentBlock));
                }
            });
            return;
        }
        if (this.templateStream.mostRecent) {
            listener(this.templateStream.mostRecent);
        }
        this.templateStream.onNewBlockTemplate.on(listener);
    }
    offNewBlockTemplate(listener) {
        if (this.templateStream) {
            this.templateStream.onNewBlockTemplate.off(listener);
            if (this.templateStream.onNewBlockTemplate.isEmpty) {
                this.templateStream = undefined;
            }
        }
    }
    streamBlockTemplate(currentBlock, template) {
        // If there are not listeners for new blocks, return early
        if (!this.templateStream) {
            return;
        }
        // The head of the chain has changed, abort working on this template
        if (!this.chain.head.hash.equals(currentBlock.header.hash)) {
            return;
        }
        this.templateStream.onNewBlockTemplate.emit(template);
        this.templateStream.mostRecent = template;
    }
    async onConnectedBlock(currentBlock) {
        const connectedAt = bench_1.BenchUtils.start();
        // If there are not listeners for new blocks, then return early
        if (!this.templateStream) {
            return;
        }
        // If we mine when we're not synced, then we will mine a fork no one cares about
        if (!this.node.chain.synced && !this.node.config.get('miningForce')) {
            return;
        }
        // If we mine when we're not connected to anyone, then no one will get our blocks
        if (!this.node.peerNetwork.isReady && !this.node.config.get('miningForce')) {
            return;
        }
        // The head of the chain has changed, abort working on this template
        if (!this.chain.head.hash.equals(currentBlock.header.hash)) {
            return;
        }
        const account = this.node.wallet.getDefaultAccount();
        if (!account) {
            this.node.logger.info('Cannot mine without an account');
            return;
        }
        if (!account.isSpendingAccount()) {
            this.node.logger.info('Account must have spending key in order to mine');
            return;
        }
        const emptyTemplate = await this.createNewBlockTemplate(currentBlock, account, false);
        this.metrics.mining_newEmptyBlockTemplate.add(bench_1.BenchUtils.end(connectedAt));
        this.streamBlockTemplate(currentBlock, emptyTemplate);
        // The head of the chain has changed, abort working on this template
        if (!this.chain.head.hash.equals(currentBlock.header.hash)) {
            return;
        }
        // Kick off job to create the next empty miners fee
        this.minersFeeCache.startCreatingEmptyMinersFee(currentBlock.header.sequence + 2, account);
        // Only try creating a block with transactions if there are transactions in
        // the mempool
        if (this.memPool.count()) {
            const template = await this.createNewBlockTemplate(currentBlock, account);
            this.metrics.mining_newBlockTemplate.add(bench_1.BenchUtils.end(connectedAt));
            this.streamBlockTemplate(currentBlock, template);
            const block = serde_1.BlockTemplateSerde.deserialize(template);
            const verification = await this.chain.verifier.verifyBlock(block, {
                verifyTarget: false,
            });
            if (!verification.valid) {
                // Abort working on invalid block template and re-send empty block
                this.streamBlockTemplate(currentBlock, emptyTemplate);
                throw new Error(verification.reason);
            }
        }
    }
    /**
     * Construct the set of transactions to include in the new block and
     * the sum of the associated fees.
     *
     * @param sequence The sequence of the next block to be included in the chain
     * @returns
     */
    async getNewBlockTransactions(sequence, currBlockSize) {
        const startTime = bench_1.BenchUtils.start();
        // Fetch pending transactions
        const blockTransactions = [];
        const nullifiers = new buffer_map_1.BufferSet();
        const assetOwners = new buffer_map_1.BufferMap();
        let totalTransactionFees = BigInt(0);
        for (const transaction of this.memPool.orderedTransactions()) {
            // Skip transactions that would cause the block to exceed the max size
            const transactionSize = serializers_1.getTransactionSize(transaction);
            if (currBlockSize + transactionSize > this.chain.consensus.parameters.maxBlockSizeBytes) {
                continue;
            }
            if (consensus_1.isExpiredSequence(transaction.expiration(), sequence)) {
                continue;
            }
            const isConflicted = transaction.spends.find((spend) => nullifiers.has(spend.nullifier));
            if (isConflicted) {
                continue;
            }
            const { valid: isValid } = await this.chain.verifier.verifyTransactionSpends(transaction);
            if (!isValid) {
                continue;
            }
            for (const spend of transaction.spends) {
                nullifiers.add(spend.nullifier);
            }
            if (transaction.mints.length) {
                const mintOwnerResult = await this.chain.verifier.verifyMintOwnersIncremental(transaction.mints, assetOwners);
                // If the transaction is valid with the state of this new block
                // template, we need to update the assetOwners map with the latest state
                // of the owners, accounting for new mints and ownership transfer
                if (mintOwnerResult.valid) {
                    for (const [assetId, assetOwner] of mintOwnerResult.assetOwners.entries()) {
                        assetOwners.set(assetId, assetOwner);
                    }
                }
                else {
                    continue;
                }
            }
            currBlockSize += transactionSize;
            totalTransactionFees += transaction.fee();
            blockTransactions.push(transaction);
        }
        this.metrics.mining_newBlockTransactions.add(bench_1.BenchUtils.end(startTime));
        return {
            totalFees: totalTransactionFees,
            blockTransactions,
            newBlockSize: currBlockSize,
        };
    }
    /**
     * Construct the new block template which is everything a miner needs to begin mining.
     *
     * @param currentBlock The head block of the current heaviest chain
     * @returns
     */
    async createNewBlockTemplate(currentBlock, account, includeTransactions = true) {
        const newBlockSequence = currentBlock.header.sequence + 1;
        let currBlockSize = serializers_1.getBlockWithMinersFeeSize();
        let transactions = [];
        let minersFee;
        if (includeTransactions) {
            const { totalFees, blockTransactions, newBlockSize } = await this.getNewBlockTransactions(newBlockSequence, currBlockSize);
            transactions = blockTransactions;
            currBlockSize = newBlockSize;
            // Calculate the final fee for the miner of this block
            minersFee = await this.node.strategy.createMinersFee(totalFees, newBlockSequence, account.spendingKey);
        }
        else {
            minersFee = await this.minersFeeCache.createEmptyMinersFee(newBlockSequence, account);
        }
        this.node.logger.debug(`Constructed miner's reward transaction for account ${account.displayName}, block sequence ${newBlockSequence}`);
        const txSize = serializers_1.getTransactionSize(minersFee);
        assert_1.Assert.isEqual(serializers_1.MINERS_FEE_TRANSACTION_SIZE_BYTES, txSize, "Incorrect miner's fee transaction size used during block creation");
        // Create the new block as a template for mining
        const newBlock = await this.chain.newBlock(transactions, minersFee, graffiti_1.GraffitiUtils.fromString(this.node.config.get('blockGraffiti')), currentBlock.header, false);
        assert_1.Assert.isEqual(currBlockSize, serializers_1.getBlockSize(newBlock), 'Incorrect block size calculated during block creation');
        this.node.logger.debug(`Current block template ${newBlock.header.sequence}, has ${newBlock.transactions.length} transactions`);
        return serde_1.BlockTemplateSerde.serialize(newBlock, currentBlock);
    }
    async submitBlockTemplate(blockTemplate) {
        const block = serde_1.BlockTemplateSerde.deserialize(blockTemplate);
        const blockDisplay = `${block.header.hash.toString('hex')} (${block.header.sequence})`;
        if (!block.header.previousBlockHash.equals(this.node.chain.head.hash)) {
            const previous = await this.node.chain.getPrevious(block.header);
            const work = block.header.target.toDifficulty();
            block.header.work = (previous ? previous.work : BigInt(0)) + work;
            if (!blockheader_1.isBlockHeavier(block.header, this.node.chain.head)) {
                this.node.logger.info(`Discarding mined block ${blockDisplay} that no longer attaches to heaviest head`);
                return MINED_RESULT.CHAIN_CHANGED;
            }
        }
        const { isAdded, reason, isFork } = await this.node.chain.addBlock(block);
        if (!isAdded) {
            this.node.logger.info(`Failed to add mined block ${blockDisplay} to chain with reason ${String(reason)}`);
            return MINED_RESULT.ADD_FAILED;
        }
        if (isFork) {
            this.node.logger.info(`Failed to add mined block ${blockDisplay} to main chain. Block was added as a fork`);
            return MINED_RESULT.FORK;
        }
        this.node.logger.info(`Successfully mined block ${blockDisplay} with ${block.transactions.length} transactions`);
        this.blocksMined++;
        this.onNewBlock.emit(block);
        return MINED_RESULT.SUCCESS;
    }
}
exports.MiningManager = MiningManager;
//# sourceMappingURL=manager.js.map