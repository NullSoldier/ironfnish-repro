"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.MiningPool = void 0;
/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/. */
const blake_hash_1 = require("@napi-rs/blake-hash");
const blru_1 = __importDefault(require("blru"));
const assert_1 = require("../assert");
const target_1 = require("../primitives/target");
const transaction_1 = require("../primitives/transaction");
const bigint_1 = require("../utils/bigint");
const error_1 = require("../utils/error");
const file_1 = require("../utils/file");
const wallet_1 = require("../wallet");
const poolShares_1 = require("./poolShares");
const adapters_1 = require("./stratum/adapters");
const stratumServer_1 = require("./stratum/stratumServer");
const utils_1 = require("./utils");
const RECALCULATE_TARGET_TIMEOUT = 10000;
const EVENT_LOOP_MS = 10 * 1000;
class MiningPool {
    constructor(options) {
        this.stopPromise = null;
        this.stopResolve = null;
        this.onDisconnectRpc = () => {
            this.stratum.waitForWork();
            this.logger.info('Disconnected from node unexpectedly. Reconnecting.');
            this.webhooks.map((w) => w.poolDisconnected());
            void this.startConnectingRpc();
        };
        this.rpc = options.rpc;
        this.logger = options.logger;
        this.webhooks = options.webhooks ?? [];
        this.stratum = new stratumServer_1.StratumServer({
            pool: this,
            config: options.config,
            logger: this.logger,
            banning: options.banning,
        });
        this.config = options.config;
        this.shares = options.shares;
        this.nextMiningRequestId = 0;
        this.miningRequestBlocks = new blru_1.default(12);
        this.recentSubmissions = new Map();
        this.currentHeadTimestamp = null;
        this.currentHeadDifficulty = null;
        this.name = this.config.get('poolName');
        this.difficulty = BigInt(this.config.get('poolDifficulty'));
        const basePoolTarget = target_1.Target.fromDifficulty(this.difficulty).asBigInt();
        this.target = bigint_1.BigIntUtils.writeBigU256BE(basePoolTarget);
        this.connectTimeout = null;
        this.connectWarned = false;
        this.started = false;
        this.eventLoopTimeout = null;
        this.recalculateTargetInterval = null;
        this.notifyStatusInterval = null;
    }
    static async init(options) {
        const shares = await poolShares_1.MiningPoolShares.init({
            rpc: options.rpc,
            config: options.config,
            logger: options.logger,
            webhooks: options.webhooks,
            enablePayouts: options.enablePayouts,
        });
        const pool = new MiningPool({
            rpc: options.rpc,
            logger: options.logger,
            config: options.config,
            webhooks: options.webhooks,
            shares,
            banning: options.banning,
        });
        if (options.tls) {
            assert_1.Assert.isNotUndefined(options.tlsOptions);
            pool.stratum.mount(new adapters_1.StratumTlsAdapter({
                logger: options.logger,
                host: options.host,
                port: options.port,
                tlsOptions: options.tlsOptions,
            }));
        }
        else {
            pool.stratum.mount(new adapters_1.StratumTcpAdapter({
                logger: options.logger,
                host: options.host,
                port: options.port,
            }));
        }
        return pool;
    }
    async start() {
        if (this.started) {
            return;
        }
        this.stopPromise = new Promise((r) => (this.stopResolve = r));
        this.started = true;
        this.logger.info(`Starting stratum server v${String(this.stratum.version)}`);
        await this.stratum.start();
        this.logger.info('Connecting to node...');
        this.rpc.onClose.on(this.onDisconnectRpc);
        await this.startConnectingRpc();
        await this.shares.start();
        const statusInterval = this.config.get('poolStatusNotificationInterval');
        if (statusInterval > 0) {
            this.notifyStatusInterval = setInterval(() => void this.notifyStatus(), statusInterval * 1000);
        }
        void this.eventLoop();
    }
    async stop() {
        if (!this.started) {
            return;
        }
        this.logger.debug('Stopping pool, goodbye');
        this.started = false;
        this.rpc.onClose.off(this.onDisconnectRpc);
        this.rpc.close();
        await this.stratum.stop();
        await this.shares.stop();
        if (this.stopResolve) {
            this.stopResolve();
        }
        if (this.connectTimeout) {
            clearTimeout(this.connectTimeout);
        }
        if (this.eventLoopTimeout) {
            clearTimeout(this.eventLoopTimeout);
        }
        if (this.recalculateTargetInterval) {
            clearInterval(this.recalculateTargetInterval);
        }
        if (this.notifyStatusInterval) {
            clearInterval(this.notifyStatusInterval);
        }
    }
    async eventLoop() {
        if (!this.started) {
            return;
        }
        const eventLoopStartTime = new Date().getTime();
        await this.shares.rolloverPayoutPeriod();
        await this.updateUnconfirmedBlocks();
        await this.updateUnconfirmedPayoutTransactions();
        await this.shares.createNewPayout();
        const eventLoopEndTime = new Date().getTime();
        const eventLoopDuration = eventLoopEndTime - eventLoopStartTime;
        this.logger.debug(`Mining pool event loop took ${eventLoopDuration} milliseconds`);
        this.eventLoopTimeout = setTimeout(() => void this.eventLoop(), EVENT_LOOP_MS);
    }
    async waitForStop() {
        await this.stopPromise;
    }
    getTarget() {
        return this.target.toString('hex');
    }
    async submitWork(client, miningRequestId, randomness) {
        assert_1.Assert.isNotNull(client.publicAddress);
        assert_1.Assert.isNotNull(client.graffiti);
        if (miningRequestId !== this.nextMiningRequestId - 1) {
            this.logger.debug(`Client ${client.id} submitted work for stale mining request: ${miningRequestId}`);
            return;
        }
        const originalBlockTemplate = this.miningRequestBlocks.get(miningRequestId);
        if (!originalBlockTemplate) {
            this.logger.warn(`Client ${client.id} work for invalid mining request: ${miningRequestId}`);
            return;
        }
        const blockTemplate = Object.assign({}, originalBlockTemplate);
        blockTemplate.header = Object.assign({}, originalBlockTemplate.header);
        const isDuplicate = this.isDuplicateSubmission(client.id, randomness);
        if (isDuplicate) {
            this.logger.warn(`Client ${client.id} submitted a duplicate mining request: ${miningRequestId}, ${randomness}`);
            return;
        }
        this.addWorkSubmission(client.id, randomness);
        blockTemplate.header.graffiti = client.graffiti.toString('hex');
        blockTemplate.header.randomness = randomness;
        let headerBytes;
        try {
            headerBytes = utils_1.mineableHeaderString(blockTemplate.header);
        }
        catch (error) {
            this.stratum.peers.punish(client, `${client.id} sent malformed work.`);
            return;
        }
        const hashedHeader = blake_hash_1.blake3(headerBytes);
        if (hashedHeader.compare(Buffer.from(blockTemplate.header.target, 'hex')) !== 1) {
            this.logger.debug('Valid block, submitting to node');
            const result = await this.rpc.miner.submitBlock(blockTemplate);
            if (result.content.added) {
                const hashRate = await this.estimateHashRate();
                const hashedHeaderHex = hashedHeader.toString('hex');
                const minersFee = new transaction_1.Transaction(Buffer.from(blockTemplate.transactions[0], 'hex')).fee();
                await this.shares.submitBlock(blockTemplate.header.sequence, hashedHeaderHex, minersFee);
                this.logger.info(`Block ${hashedHeaderHex} submitted successfully! ${file_1.FileUtils.formatHashRate(hashRate)}/s`);
                this.webhooks.map((w) => w.poolSubmittedBlock(hashedHeaderHex, hashRate, this.stratum.subscribed));
            }
            else {
                this.logger.info(`Block was rejected: ${result.content.reason}`);
            }
        }
        if (hashedHeader.compare(this.target) !== 1) {
            this.logger.debug('Valid pool share submitted');
            await this.shares.submitShare(client.publicAddress);
        }
    }
    async startConnectingRpc() {
        const connected = await this.rpc.tryConnect();
        if (!this.started) {
            return;
        }
        if (!connected) {
            if (!this.connectWarned) {
                this.logger.warn(`Failed to connect to node on ${this.rpc.describe()}, retrying...`);
                this.connectWarned = true;
            }
            this.connectTimeout = setTimeout(() => void this.startConnectingRpc(), 5000);
            return;
        }
        if (connected) {
            this.webhooks.map((w) => w.poolConnected());
        }
        this.connectWarned = false;
        this.logger.info('Successfully connected to node');
        this.logger.info('Listening to node for new blocks');
        void this.processNewBlocks().catch(async (e) => {
            this.logger.error('Fatal error occurred while processing blocks from node:');
            this.logger.error(error_1.ErrorUtils.renderError(e, true));
            await this.stop();
        });
    }
    async processNewBlocks() {
        const consensusParameters = (await this.rpc.chain.getConsensusParameters()).content;
        for await (const payload of this.rpc.miner.blockTemplateStream().contentStream()) {
            assert_1.Assert.isNotUndefined(payload.previousBlockInfo);
            this.restartCalculateTargetInterval(consensusParameters.targetBlockTimeInSeconds, consensusParameters.targetBucketTimeInSeconds);
            const currentHeadTarget = new target_1.Target(Buffer.from(payload.previousBlockInfo.target, 'hex'));
            this.currentHeadDifficulty = currentHeadTarget.toDifficulty();
            this.currentHeadTimestamp = payload.previousBlockInfo.timestamp;
            this.distributeNewBlock(payload);
        }
    }
    recalculateTarget(targetBlockTimeInSeconds, targetBucketTimeInSeconds) {
        this.logger.debug('recalculating target');
        assert_1.Assert.isNotNull(this.currentHeadTimestamp);
        assert_1.Assert.isNotNull(this.currentHeadDifficulty);
        const currentBlock = this.miningRequestBlocks.get(this.nextMiningRequestId - 1);
        assert_1.Assert.isNotNull(currentBlock);
        const latestBlock = Object.assign({}, currentBlock);
        latestBlock.header = Object.assign({}, currentBlock.header);
        assert_1.Assert.isNotNull(latestBlock);
        const newTime = new Date();
        const newTarget = target_1.Target.fromDifficulty(target_1.Target.calculateDifficulty(newTime, new Date(this.currentHeadTimestamp), this.currentHeadDifficulty, targetBlockTimeInSeconds, targetBucketTimeInSeconds));
        // Target might be the same if there is a slight timing issue or if the block is at max target.
        // In this case, it is detrimental to send out new work as it will needlessly reset miner's search
        // space, resulting in duplicated work.
        const existingTarget = bigint_1.BigIntUtils.fromBytesBE(Buffer.from(latestBlock.header.target, 'hex'));
        if (newTarget.asBigInt() === existingTarget) {
            this.logger.debug(`New target ${newTarget.asBigInt()} is the same as the existing target, no need to send out new work.`);
            return;
        }
        latestBlock.header.target = bigint_1.BigIntUtils.writeBigU256BE(newTarget.asBigInt()).toString('hex');
        latestBlock.header.timestamp = newTime.getTime();
        this.distributeNewBlock(latestBlock);
        this.logger.debug('target recalculated', { prevHash: latestBlock.header.previousBlockHash });
    }
    distributeNewBlock(newBlock) {
        assert_1.Assert.isNotNull(this.currentHeadTimestamp);
        assert_1.Assert.isNotNull(this.currentHeadDifficulty);
        const miningRequestId = this.nextMiningRequestId++;
        this.miningRequestBlocks.set(miningRequestId, newBlock);
        this.recentSubmissions.clear();
        this.stratum.newWork(miningRequestId, newBlock);
    }
    restartCalculateTargetInterval(targetBlockTimeInSeconds, targetBucketTimeInSeconds) {
        if (this.recalculateTargetInterval) {
            clearInterval(this.recalculateTargetInterval);
        }
        this.recalculateTargetInterval = setInterval(() => {
            this.recalculateTarget(targetBlockTimeInSeconds, targetBucketTimeInSeconds);
        }, RECALCULATE_TARGET_TIMEOUT);
    }
    isDuplicateSubmission(clientId, randomness) {
        const submissions = this.recentSubmissions.get(clientId);
        if (submissions == null) {
            return false;
        }
        return submissions.includes(randomness);
    }
    addWorkSubmission(clientId, randomness) {
        const submissions = this.recentSubmissions.get(clientId);
        if (submissions == null) {
            this.recentSubmissions.set(clientId, [randomness]);
        }
        else {
            submissions.push(randomness);
            this.recentSubmissions.set(clientId, submissions);
        }
    }
    async estimateHashRate(publicAddress) {
        // BigInt can't contain decimals, so multiply then divide to give decimal precision
        const shareRate = await this.shares.shareRate(publicAddress);
        const decimalPrecision = 1000000;
        return (Number(BigInt(Math.floor(shareRate * decimalPrecision)) * this.difficulty) /
            decimalPrecision);
    }
    async notifyStatus() {
        const status = await this.getStatus();
        this.logger.debug(`Mining pool status: ${JSON.stringify(status)}`);
        this.webhooks.map((w) => w.poolStatus(status));
    }
    async getStatus(publicAddress) {
        const [hashRate, sharesPending] = await Promise.all([
            this.estimateHashRate(),
            this.shares.sharesPendingPayout(),
        ]);
        let addressMinerCount = 0;
        const status = {
            name: this.name,
            hashRate: hashRate,
            miners: this.stratum.subscribed,
            sharesPending: sharesPending,
            bans: this.stratum.peers.banCount,
            clients: this.stratum.clients.size,
        };
        if (publicAddress) {
            const [addressHashRate, addressSharesPending] = await Promise.all([
                this.estimateHashRate(publicAddress),
                this.shares.sharesPendingPayout(publicAddress),
            ]);
            const addressConnectedMiners = [];
            for (const client of this.stratum.clients.values()) {
                if (client.subscribed && client.publicAddress === publicAddress) {
                    addressMinerCount++;
                    addressConnectedMiners.push(client.name || `Miner ${client.id}`);
                }
            }
            status.addressStatus = {
                publicAddress: publicAddress,
                hashRate: addressHashRate,
                miners: addressMinerCount,
                connectedMiners: addressConnectedMiners,
                sharesPending: addressSharesPending,
            };
        }
        return status;
    }
    async updateUnconfirmedBlocks() {
        const unconfirmedBlocks = await this.shares.unconfirmedBlocks();
        for (const block of unconfirmedBlocks) {
            const blockInfoResp = await this.rpc.chain.getBlock({
                hash: block.blockHash,
                confirmations: this.config.get('confirmations'),
            });
            const { main, confirmed } = blockInfoResp.content.metadata;
            await this.shares.updateBlockStatus(block, main, confirmed);
        }
    }
    async updateUnconfirmedPayoutTransactions() {
        const unconfirmedTransactions = await this.shares.unconfirmedPayoutTransactions();
        for (const transaction of unconfirmedTransactions) {
            const transactionInfoResp = await this.rpc.wallet.getAccountTransaction({
                hash: transaction.transactionHash,
                confirmations: this.config.get('confirmations'),
            });
            const transactionInfo = transactionInfoResp.content.transaction;
            if (!transactionInfo) {
                this.logger.debug(`Transaction ${transaction.transactionHash} not found.`);
                continue;
            }
            const confirmed = transactionInfo.status === wallet_1.TransactionStatus.CONFIRMED;
            const expired = transactionInfo.status === wallet_1.TransactionStatus.EXPIRED;
            await this.shares.updatePayoutTransactionStatus(transaction, confirmed, expired);
        }
    }
}
exports.MiningPool = MiningPool;
//# sourceMappingURL=pool.js.map