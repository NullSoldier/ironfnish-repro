"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MiningSoloMiner = void 0;
/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/. */
const rust_nodejs_1 = require("@ironfish/rust-nodejs");
const blake_hash_1 = require("@napi-rs/blake-hash");
const assert_1 = require("../assert");
const meter_1 = require("../metrics/meter");
const target_1 = require("../primitives/target");
const bigint_1 = require("../utils/bigint");
const error_1 = require("../utils/error");
const file_1 = require("../utils/file");
const promise_1 = require("../utils/promise");
const utils_1 = require("./utils");
const RECALCULATE_TARGET_TIMEOUT = 10000;
class MiningSoloMiner {
    constructor(options) {
        this.onDisconnectRpc = () => {
            this.waitForWork();
            this.logger.info('Disconnected from node unexpectedly. Reconnecting.');
            void this.startConnectingRpc();
        };
        this.rpc = options.rpc;
        this.logger = options.logger;
        this.graffiti = options.graffiti;
        const threadCount = options.threadCount ?? 1;
        this.threadPool = new rust_nodejs_1.ThreadPoolHandler(threadCount, options.batchSize, true);
        this.miningRequestId = 0;
        this.nextMiningRequestId = 0;
        this.miningRequestBlocks = new Map();
        this.target = Buffer.alloc(32, 0);
        this.currentHeadTimestamp = null;
        this.currentHeadDifficulty = null;
        this.hashRate = new meter_1.Meter();
        this.stopPromise = null;
        this.stopResolve = null;
        this.waiting = false;
        this.connectWarned = false;
        this.connectTimeout = null;
        this.recalculateTargetInterval = null;
        this.started = false;
    }
    start() {
        if (this.started) {
            return;
        }
        this.stopPromise = new Promise((r) => (this.stopResolve = r));
        this.started = true;
        this.hashRate.start();
        void this.mine();
        this.logger.info('Connecting to node...');
        this.rpc.onClose.on(this.onDisconnectRpc);
        void this.startConnectingRpc();
    }
    stop() {
        if (!this.started) {
            return;
        }
        this.logger.debug('Stopping miner, goodbye');
        this.started = false;
        this.rpc.onClose.off(this.onDisconnectRpc);
        this.rpc.close();
        this.hashRate.stop();
        if (this.stopResolve) {
            this.stopResolve();
        }
        if (this.connectTimeout) {
            clearTimeout(this.connectTimeout);
        }
        if (this.recalculateTargetInterval) {
            clearInterval(this.recalculateTargetInterval);
        }
    }
    async waitForStop() {
        await this.stopPromise;
    }
    newWork(miningRequestId, header) {
        this.logger.debug(`new work ${this.target.toString('hex')}, ${miningRequestId} ${file_1.FileUtils.formatHashRate(this.hashRate.rate1s)}/s`);
        const headerBytes = Buffer.concat([header]);
        headerBytes.set(this.graffiti, utils_1.MINEABLE_BLOCK_HEADER_GRAFFITI_OFFSET);
        this.waiting = false;
        this.threadPool.newWork(headerBytes, this.target, miningRequestId);
    }
    waitForWork() {
        this.waiting = true;
        this.threadPool.pause();
    }
    async processNewBlocks() {
        const consensusParameters = (await this.rpc.chain.getConsensusParameters()).content;
        for await (const payload of this.rpc.miner.blockTemplateStream().contentStream()) {
            assert_1.Assert.isNotUndefined(payload.previousBlockInfo);
            const currentHeadTarget = new target_1.Target(Buffer.from(payload.previousBlockInfo.target, 'hex'));
            this.currentHeadDifficulty = currentHeadTarget.toDifficulty();
            this.currentHeadTimestamp = payload.previousBlockInfo.timestamp;
            this.restartCalculateTargetInterval(consensusParameters.targetBlockTimeInSeconds, consensusParameters.targetBucketTimeInSeconds);
            this.startNewWork(payload);
        }
    }
    startNewWork(block) {
        assert_1.Assert.isNotNull(this.currentHeadTimestamp);
        assert_1.Assert.isNotNull(this.currentHeadDifficulty);
        const miningRequestId = this.nextMiningRequestId++;
        this.miningRequestBlocks.set(miningRequestId, block);
        this.miningRequestId = miningRequestId;
        this.target = Buffer.from(block.header.target, 'hex');
        const work = utils_1.mineableHeaderString(block.header);
        this.newWork(miningRequestId, work);
    }
    async mine() {
        while (this.started) {
            const blockResult = this.threadPool.getFoundBlock();
            if (blockResult != null) {
                const { miningRequestId, randomness } = blockResult;
                this.logger.info(`Found block: ${randomness} ${miningRequestId} ${file_1.FileUtils.formatHashRate(this.hashRate.rate1s)}/s`);
                void this.submitWork(miningRequestId, randomness, this.graffiti);
            }
            const hashRate = this.threadPool.getHashRateSubmission();
            this.hashRate.add(hashRate);
            await promise_1.PromiseUtils.sleep(10);
        }
        this.hashRate.stop();
    }
    async submitWork(miningRequestId, randomness, graffiti) {
        const blockTemplate = this.miningRequestBlocks.get(miningRequestId);
        assert_1.Assert.isNotUndefined(blockTemplate);
        blockTemplate.header.graffiti = graffiti.toString('hex');
        blockTemplate.header.randomness = randomness;
        const headerBytes = utils_1.mineableHeaderString(blockTemplate.header);
        const hashedHeader = blake_hash_1.blake3(headerBytes);
        if (hashedHeader.compare(Buffer.from(blockTemplate.header.target, 'hex')) !== 1) {
            this.logger.debug('Valid block, submitting to node');
            const result = await this.rpc.miner.submitBlock(blockTemplate);
            if (result.content.added) {
                this.logger.info(`Block submitted successfully! ${file_1.FileUtils.formatHashRate(this.hashRate.rate1s)}/s`);
            }
            else {
                this.logger.info(`Block was rejected: ${result.content.reason}`);
            }
        }
    }
    async startConnectingRpc() {
        const connected = await this.rpc.tryConnect();
        if (!this.started) {
            return;
        }
        if (!connected) {
            if (!this.connectWarned) {
                this.logger.warn(`Failed to connect to node on ${this.rpc.describe()}, retrying...`);
                this.connectWarned = true;
            }
            this.connectTimeout = setTimeout(() => void this.startConnectingRpc(), 5000);
            return;
        }
        this.connectWarned = false;
        this.logger.info('Successfully connected to node');
        this.logger.info('Listening to node for new blocks');
        void this.processNewBlocks().catch((e) => {
            this.logger.error('Fatal error occurred while processing blocks from node:');
            this.logger.error(error_1.ErrorUtils.renderError(e, true));
            this.stop();
        });
    }
    recalculateTarget(targetBlockTimeInSeconds, targetBucketTimeInSeconds) {
        assert_1.Assert.isNotNull(this.currentHeadTimestamp);
        assert_1.Assert.isNotNull(this.currentHeadDifficulty);
        const latestBlock = this.miningRequestBlocks.get(this.nextMiningRequestId - 1);
        assert_1.Assert.isNotUndefined(latestBlock);
        const newTime = new Date();
        const newTarget = target_1.Target.fromDifficulty(target_1.Target.calculateDifficulty(newTime, new Date(this.currentHeadTimestamp), this.currentHeadDifficulty, targetBlockTimeInSeconds, targetBucketTimeInSeconds));
        latestBlock.header.target = bigint_1.BigIntUtils.writeBigU256BE(newTarget.asBigInt()).toString('hex');
        latestBlock.header.timestamp = newTime.getTime();
        this.startNewWork(latestBlock);
    }
    restartCalculateTargetInterval(targetBlockTimeInSeconds, targetBucketTimeInSeconds) {
        if (this.recalculateTargetInterval) {
            clearInterval(this.recalculateTargetInterval);
        }
        this.recalculateTargetInterval = setInterval(() => {
            this.recalculateTarget(targetBlockTimeInSeconds, targetBucketTimeInSeconds);
        }, RECALCULATE_TARGET_TIMEOUT);
    }
}
exports.MiningSoloMiner = MiningSoloMiner;
//# sourceMappingURL=soloMiner.js.map