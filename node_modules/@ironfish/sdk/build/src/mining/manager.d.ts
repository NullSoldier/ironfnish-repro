import { Blockchain } from '../blockchain';
import { Event } from '../event';
import { MemPool } from '../memPool';
import { MetricsMonitor } from '../metrics';
import { FullNode } from '../node';
import { Block } from '../primitives/block';
import { Transaction } from '../primitives/transaction';
import { SerializedBlockTemplate } from '../serde';
import { SpendingAccount } from '../wallet';
export declare enum MINED_RESULT {
    UNKNOWN_REQUEST = "UNKNOWN_REQUEST",
    CHAIN_CHANGED = "CHAIN_CHANGED",
    ADD_FAILED = "ADD_FAILED",
    FORK = "FORK",
    SUCCESS = "SUCCESS"
}
export declare class MiningManager {
    private readonly chain;
    private readonly memPool;
    private readonly node;
    private readonly metrics;
    private readonly minersFeeCache;
    blocksMined: number;
    readonly onNewBlock: Event<[Block]>;
    private templateStream?;
    constructor(options: {
        chain: Blockchain;
        node: FullNode;
        memPool: MemPool;
        metrics: MetricsMonitor;
    });
    handleOnConnectBlockError(error: unknown, block: Block): void;
    get minersConnected(): number;
    onNewBlockTemplate(listener: (template: SerializedBlockTemplate) => void): void;
    offNewBlockTemplate(listener: (template: SerializedBlockTemplate) => void): void;
    streamBlockTemplate(currentBlock: Block, template: SerializedBlockTemplate): void;
    private onConnectedBlock;
    /**
     * Construct the set of transactions to include in the new block and
     * the sum of the associated fees.
     *
     * @param sequence The sequence of the next block to be included in the chain
     * @returns
     */
    getNewBlockTransactions(sequence: number, currBlockSize: number): Promise<{
        totalFees: bigint;
        blockTransactions: Transaction[];
        newBlockSize: number;
    }>;
    /**
     * Construct the new block template which is everything a miner needs to begin mining.
     *
     * @param currentBlock The head block of the current heaviest chain
     * @returns
     */
    createNewBlockTemplate(currentBlock: Block, account: SpendingAccount, includeTransactions?: boolean): Promise<SerializedBlockTemplate>;
    submitBlockTemplate(blockTemplate: SerializedBlockTemplate): Promise<MINED_RESULT>;
}
//# sourceMappingURL=manager.d.ts.map