"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.IronfishSdk = void 0;
/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/. */
const fileStores_1 = require("./fileStores");
const fileSystems_1 = require("./fileSystems");
const logger_1 = require("./logger");
const reporters_1 = require("./logger/reporters");
const metrics_1 = require("./metrics");
const webSocketClient_1 = require("./network/webSocketClient");
const node_1 = require("./node");
const package_1 = require("./package");
const platform_1 = require("./platform");
const rpc_1 = require("./rpc");
const ipcAdapter_1 = require("./rpc/adapters/ipcAdapter");
const tcpAdapter_1 = require("./rpc/adapters/tcpAdapter");
const ipcClient_1 = require("./rpc/clients/ipcClient");
const memoryClient_1 = require("./rpc/clients/memoryClient");
const tcpClient_1 = require("./rpc/clients/tcpClient");
const tlsClient_1 = require("./rpc/clients/tlsClient");
const router_1 = require("./rpc/routes/router");
const utils_1 = require("./utils");
const walletNode_1 = require("./walletNode");
class IronfishSdk {
    constructor(pkg, client, config, internal, fileSystem, logger, metrics, strategyClass = null, dataDir) {
        this.pkg = pkg;
        this.client = client;
        this.config = config;
        this.internal = internal;
        this.fileSystem = fileSystem;
        this.logger = logger;
        this.metrics = metrics;
        this.strategyClass = strategyClass;
        this.dataDir = dataDir;
    }
    static async init({ pkg, configName, configOverrides, internalOverrides, fileSystem, dataDir, logger = logger_1.createRootLogger(), metrics, strategyClass, } = {}) {
        const runtime = platform_1.Platform.getRuntime();
        if (!fileSystem) {
            if (runtime.type === 'node') {
                fileSystem = new fileSystems_1.NodeFileProvider();
                await fileSystem.init();
            }
            else {
                throw new Error(`No default fileSystem for ${String(runtime)}`);
            }
        }
        logger = logger.withTag('ironfishsdk');
        dataDir = dataDir || fileStores_1.DEFAULT_DATA_DIR;
        const config = new fileStores_1.Config(fileSystem, dataDir, configName);
        await config.load();
        const internal = new fileStores_1.InternalStore(fileSystem, dataDir);
        await internal.load();
        if (configOverrides) {
            Object.assign(config.overrides, configOverrides);
        }
        if (internalOverrides) {
            Object.assign(internal.overrides, internalOverrides);
        }
        // Update the logger settings
        const logLevel = config.get('logLevel');
        if (logLevel) {
            logger_1.setLogLevelFromConfig(logLevel);
        }
        const logPrefix = config.get('logPrefix');
        if (logPrefix) {
            logger_1.setLogPrefixFromConfig(logPrefix);
        }
        logger_1.setLogColorEnabledFromConfig(true);
        logger_1.setJSONLoggingFromConfig(config.get('jsonLogs'));
        const logFile = config.get('enableLogFile');
        if (logFile && fileSystem instanceof fileSystems_1.NodeFileProvider && fileSystem.path) {
            const path = fileSystem.path.join(config.dataDir, 'ironfish.log');
            const fileLogger = new reporters_1.FileReporter(fileSystem, path);
            logger.addReporter(fileLogger);
        }
        if (!metrics) {
            metrics = metrics || new metrics_1.MetricsMonitor({ logger });
        }
        let client;
        const rpcAuthToken = internal.get('rpcAuthToken');
        if (config.get('enableRpcTcp')) {
            if (config.get('enableRpcTls')) {
                client = new tlsClient_1.RpcTlsClient(config.get('rpcTcpHost'), config.get('rpcTcpPort'), logger, rpcAuthToken);
            }
            else {
                client = new tcpClient_1.RpcTcpClient(config.get('rpcTcpHost'), config.get('rpcTcpPort'), logger);
            }
        }
        else {
            client = new ipcClient_1.RpcIpcClient(config.get('ipcPath'), logger);
        }
        return new IronfishSdk(pkg || package_1.IronfishPKG, client, config, internal, fileSystem, logger, metrics, strategyClass, dataDir);
    }
    async node({ autoSeed, privateIdentity, } = {}) {
        const webSocket = webSocketClient_1.WebSocketClient;
        const node = await node_1.FullNode.init({
            pkg: this.pkg,
            config: this.config,
            internal: this.internal,
            files: this.fileSystem,
            autoSeed: autoSeed,
            logger: this.logger,
            metrics: this.metrics,
            strategyClass: this.strategyClass,
            webSocket: webSocket,
            privateIdentity: privateIdentity,
            dataDir: this.dataDir,
        });
        if (this.config.get('enableRpcIpc')) {
            await node.rpc.mount(new ipcAdapter_1.RpcIpcAdapter(this.config.get('ipcPath'), this.logger, router_1.ALL_API_NAMESPACES));
        }
        if (this.config.get('enableRpcHttp')) {
            await node.rpc.mount(new rpc_1.RpcHttpAdapter(this.config.get('rpcHttpHost'), this.config.get('rpcHttpPort'), this.logger, router_1.ALL_API_NAMESPACES));
        }
        if (this.config.get('enableRpcTcp')) {
            if (this.config.get('enableRpcTls')) {
                await node.rpc.mount(new rpc_1.RpcTlsAdapter(this.config.get('rpcTcpHost'), this.config.get('rpcTcpPort'), this.fileSystem, this.config.get('tlsKeyPath'), this.config.get('tlsCertPath'), node, this.logger, router_1.ALL_API_NAMESPACES));
            }
            else {
                await node.rpc.mount(new tcpAdapter_1.RpcTcpAdapter(this.config.get('rpcTcpHost'), this.config.get('rpcTcpPort'), this.logger, router_1.ALL_API_NAMESPACES));
            }
        }
        return node;
    }
    async connectRpc(forceLocal = false, forceRemote = false) {
        forceRemote = forceRemote || this.config.get('enableRpcTcp');
        if (!forceLocal) {
            if (forceRemote) {
                await this.client.connect();
                return this.client;
            }
            const connected = await this.client.tryConnect();
            if (connected) {
                return this.client;
            }
        }
        const node = await this.node();
        const clientMemory = new memoryClient_1.RpcMemoryClient(this.logger, node.rpc.getRouter(router_1.ALL_API_NAMESPACES));
        await utils_1.NodeUtils.waitForOpen(node);
        return clientMemory;
    }
    async walletNode(options = { connectNodeClient: true }) {
        let nodeClient = null;
        if (options.connectNodeClient) {
            if (this.config.get('walletNodeTcpEnabled')) {
                if (this.config.get('walletNodeTlsEnabled')) {
                    nodeClient = new tlsClient_1.RpcTlsClient(this.config.get('walletNodeTcpHost'), this.config.get('walletNodeTcpPort'), this.logger, this.config.get('walletNodeRpcAuthToken'));
                }
                else {
                    nodeClient = new tcpClient_1.RpcTcpClient(this.config.get('walletNodeTcpHost'), this.config.get('walletNodeTcpPort'), this.logger);
                }
            }
            else if (this.config.get('walletNodeIpcEnabled')) {
                nodeClient = new ipcClient_1.RpcIpcClient(this.config.get('walletNodeIpcPath'), this.logger);
            }
            else {
                throw new Error(`Cannot start the wallet: no node connection configuration specified.

Use 'ironfish config:set' to connect to a node via TCP, TLS, or IPC.\n`);
            }
        }
        const node = await walletNode_1.WalletNode.init({
            pkg: this.pkg,
            config: this.config,
            internal: this.internal,
            files: this.fileSystem,
            logger: this.logger,
            metrics: this.metrics,
            strategyClass: this.strategyClass,
            dataDir: this.dataDir,
            nodeClient,
        });
        const namespaces = [
            router_1.ApiNamespace.config,
            router_1.ApiNamespace.faucet,
            router_1.ApiNamespace.rpc,
            router_1.ApiNamespace.wallet,
            router_1.ApiNamespace.worker,
            router_1.ApiNamespace.node,
        ];
        if (this.config.get('enableRpcIpc')) {
            await node.rpc.mount(new ipcAdapter_1.RpcIpcAdapter(this.config.get('ipcPath'), this.logger, namespaces));
        }
        if (this.config.get('enableRpcHttp')) {
            await node.rpc.mount(new rpc_1.RpcHttpAdapter(this.config.get('rpcHttpHost'), this.config.get('rpcHttpPort'), this.logger, namespaces));
        }
        if (this.config.get('enableRpcTcp')) {
            if (this.config.get('enableRpcTls')) {
                await node.rpc.mount(new rpc_1.RpcTlsAdapter(this.config.get('rpcTcpHost'), this.config.get('rpcTcpPort'), this.fileSystem, this.config.get('tlsKeyPath'), this.config.get('tlsCertPath'), node, this.logger, namespaces));
            }
            else {
                await node.rpc.mount(new tcpAdapter_1.RpcTcpAdapter(this.config.get('rpcTcpHost'), this.config.get('rpcTcpPort'), this.logger, namespaces));
            }
        }
        return node;
    }
}
exports.IronfishSdk = IronfishSdk;
//# sourceMappingURL=sdk.js.map